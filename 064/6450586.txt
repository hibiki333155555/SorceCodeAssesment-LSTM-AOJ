import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

public class Main {
    static In in = new In();
    static Out out = new Out();
    static final long inf = 0x1fffffffffffffffL;
    static final int iinf = 0x3fffffff;
    static final double eps = 1e-9;
    static long mod = 998244353;

    List<List<Integer>> edges;
    int[] depth;
    int[][] doubling;
    long[] dp;
    void solve() {
        int n = in.nextInt();
        edges = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            edges.add(new ArrayList<>());
        }
        for (int i = 0; i < n - 1; i++) {
            int a = in.nextInt() - 1;
            int b = in.nextInt() - 1;
            edges.get(a).add(b);
            edges.get(b).add(a);
        }
        dp = new long[n];
        Arrays.fill(dp, 1);
        depth = new int[n];
        Arrays.fill(depth, -1);
        depth[0] = 0;
        doubling = new int[28][n];
        Deque<Integer> deque = new ArrayDeque<>();
        deque.addLast(0);
        List<Integer> list = new ArrayList<>();
        while (!deque.isEmpty()) {
            int p = deque.removeFirst();
            list.add(p);
            for (Integer q : edges.get(p)) {
                if (depth[q] == -1) {
                    depth[q] = depth[p] + 1;
                    doubling[0][q] = p;
                    deque.addLast(q);
                }
            }
        }
        Collections.reverse(list);
        for (int p : list) {
            dp[doubling[0][p]] = (dp[doubling[0][p]] + dp[p] * 2) % mod;
        }
        int q = in.nextInt();
        long[] pow2 = new long[n + 1];
        pow2[0] = 1;
        for (int i = 0; i < n; i++) {
            pow2[i + 1] = pow2[i] * 2 % mod;
        }
        for (int i = 1; i < 28; i++) {
            for (int j = 0; j < n; j++) {
                doubling[i][j] = doubling[i - 1][doubling[i - 1][j]];
            }
        }
        ReRooting<Long> rr = new ReRooting<>(edges, (x, i) -> (x * 2 + 1) % mod, Monoid.SUM_MOD);
        rr.calc();
        for (int i = 0; i < q; i++) {
            int x = in.nextInt() - 1;
            int y = in.nextInt() - 1;
            int xx = depth[x] > depth[y] ? x : y;
            int yy = x ^ y ^ xx;
            int prev = xx;
            for (int j = 27; j >= 0; j--) {
                if ((((depth[xx] - depth[yy]) >> j) & 1) == 1) {
                    xx = doubling[j][xx];
                }
                if (depth[prev] > depth[yy] && (((depth[prev] - depth[yy] - 1) >> j) & 1) == 1) {
                    prev = doubling[j][prev];
                }
            }
            int lca;
            if (xx != yy) {
                for (int j = 27; j >= 0; j--) {
                    if (doubling[j][xx] != doubling[j][yy]) {
                        xx = doubling[j][xx];
                        yy = doubling[j][yy];
                    }
                }
                lca = doubling[0][xx];
            } else {
                lca = xx;
            }
            int dist = depth[x] + depth[y] - depth[lca] * 2;
            if (lca == x) {
                long ans = pow2[dist] * dp[y] % mod * (mod + rr.get(x) - dp[prev] * 2 % mod) % mod;
                out.println(ans);
            } else if (lca == y) {
                long ans = pow2[dist] * dp[x] % mod * (mod + rr.get(y) - dp[prev] * 2 % mod) % mod;
                out.println(ans);
            } else {
                long ans = pow2[dist] * dp[x] % mod * dp[y] % mod;
                out.println(ans);
            }
        }
    }

    void dfs(int node, int parent) {
        if (node != parent) {
            depth[node] = depth[parent] + 1;
            doubling[0][node] = parent;
        }
        dp[node]++;
        for (int child : edges.get(node)) {
            if (child == parent) {
                continue;
            }
            dfs(child, node);
            dp[node] = (dp[node] + dp[child] * 2) % mod;
        }
    }

    public static void main(String... args) {
        Thread thread = new Thread(null, () -> new Main().solve(), "1", 1 << 23);
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        out.flush();
    }
}

class ReRooting<T> {
    private boolean isCalculated;
    private final List<List<Integer>> edges;
    private final BiFunction<T, Integer, T> addNodeFunction;
    private final Monoid<T> monoid;
    private final List<T> res = new ArrayList<>();
    private final List<List<T>> dp = new ArrayList<>();

    ReRooting(List<List<Integer>> edges, BiFunction<T, Integer, T> addNodeFunction, Monoid<T> monoid) {
        this.edges = edges;
        this.addNodeFunction = addNodeFunction;
        this.monoid = monoid;
        for (int i = 0; i < edges.size(); i++) {
            res.add(monoid.identity());
            dp.add(new ArrayList<>());
            for (int node : edges.get(i)) {
                dp.get(i).add(monoid.identity());
            }
        }
    }

    ReRooting<T> calc() {
        isCalculated = true;
        dfs1(0, -1);
        dfs2(0, -1, monoid.identity());
        return this;
    }

    private T dfs1(int node, int parent) {
        T acc = monoid.identity();
        int m = edges.get(node).size();
        for (int i = 0; i < m; i++) {
            int next = edges.get(node).get(i);
            if (next != parent) {
                T nextValue = dfs1(next, node);
                dp.get(node).set(i, nextValue);
                acc = monoid.merge(acc, nextValue);
            }
        }
        return addNodeFunction.apply(acc, node);
    }

    private void dfs2(int node, int parent, T p) {
        int m = edges.get(node).size();
        for (int i = 0; i < m; i++) {
            if (edges.get(node).get(i) == parent) {
                dp.get(node).set(i, p);
            }
        }
        List<T> dpLeft = new ArrayList<>();
        List<T> dpRight = new ArrayList<>();
        dpLeft.add(monoid.identity());
        dpRight.add(monoid.identity());
        for (int i = 0; i < m; i++) {
            dpLeft.add(monoid.merge(dpLeft.get(i), dp.get(node).get(i)));
            dpRight.add(monoid.merge(dpRight.get(i), dp.get(node).get(m - 1 - i)));
        }
        res.set(node, addNodeFunction.apply(dpLeft.get(m), node));
        for (int i = 0; i < m; i++) {
            int next = edges.get(node).get(i);
            if (next != parent) {
                dfs2(next, node, addNodeFunction.apply(monoid.merge(dpLeft.get(i), dpRight.get(m - 1 - i)), node));
            }
        }
    }

    T get(int v) {
        if (!isCalculated) {
            throw new IllegalStateException("Not calculated");
        }
        return res.get(v);
    }
}

class Monoid<T> {
    static final Monoid<Integer> SET_INTEGER = new Monoid<>((Integer)null, (a, b) -> b);
    static final Monoid<Integer> SUM_INTEGER = new Monoid<>(0, Integer::sum);
    static final Monoid<Integer> PRODUCT_INTEGER = new Monoid<>(1, (a, b) -> a * b);
    static final Monoid<Integer> XOR_INTEGER = new Monoid<>(0, (a, b) -> a ^ b);
    static final Monoid<Integer> GCD = new Monoid<>(0, (a, b) -> {
        if (b == 0) {
            return a;
        }
        while (a % b != 0) {
            int t = a % b;
            a = b;
            b = t;
        }
        return b;
    });
    static final Monoid<Integer> MIN_INTEGER = new Monoid<>(Main.iinf, Math::min);
    static final Monoid<Integer> MAX_INTEGER = new Monoid<>(-Main.iinf, Math::max);
    static final Monoid<Long> SET_LONG = new Monoid<>((Long)null, (a, b) -> b);
    static final Monoid<Long> SUM_LONG = new Monoid<>(0L, Long::sum);
    static final Monoid<Long> PRODUCT_LONG = new Monoid<>(1L, (a, b) -> a * b);
    static final Monoid<Long> XOR_LONG = new Monoid<>(0L, (a, b) -> a ^ b);
    static final Monoid<Long> MIN_LONG = new Monoid<>(Main.inf, Math::min);
    static final Monoid<Long> MAX_LONG = new Monoid<>(-Main.inf, Math::max);
    static final Monoid<Long> SUM_MOD = new Monoid<>(0L, (a, b) -> (a + b) % Main.mod);
    private T identity;
    private Supplier<T> identitySupplier;
    private final BinaryOperator<T> operation;

    Monoid(BinaryOperator<T> operation) {
        this.operation = operation;
    }

    Monoid(T identity, BinaryOperator<T> operation) {
        this(operation);
        this.identity = identity;
    }

    Monoid(Supplier<T> identitySupplier, BinaryOperator<T> operation) {
        this(operation);
        this.identitySupplier = identitySupplier;
    }

    T merge(T x, T y) {
        return operation.apply(x, y);
    }

    public T identity() {
        return identitySupplier == null ? identity : identitySupplier.get();
    }

    public boolean equalsIdentity(T obj) {
        return Objects.equals(obj, identity());
    }
}

class HLDecomposition {
    private final List<List<Integer>> edges;
    private final int n;
    private final int[] vid;
    private final int[] out;
    private final int[] head;
    private final int[] parent;
    private final int[] depth;
    private final int[] size;

    HLDecomposition(int n) {
        this.n = n;
        this.edges = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            edges.add(new ArrayList<>());
        }
        this.vid = new int[n];
        this.out = new int[n];
        this.head = new int[n];
        this.parent = new int[n];
        this.depth = new int[n];
        this.size = new int[n];
    }

    void addEdge(int u, int v) {
        edges.get(u).add(v);
        edges.get(v).add(u);
    }

    void build() {
        int root = 0;
        dfs1(root);
        dfs2(root, 0);
    }

    private void dfs1(int node) {
        size[node] = 1;
        List<Integer> children = edges.get(node);
        for (int i = 0; i < children.size(); i++) {
            int v = children.get(i);
            if (v != parent[node]) {
                parent[v] = node;
                dfs1(v);
                size[node] += size[v];
                if (size[v] > size[children.get(0)]) {
                    children.set(0, children.set(i, children.get(0)));
                }
            }
        }
    }

    private int dfs2(int node, int k) {
        vid[node] = k++;
        for (int v : edges.get(node)) {
            if (v != parent[node]) {
                if (v == edges.get(node).get(0)) {
                    head[v] = head[node];
                    depth[v] = depth[node];
                } else {
                    head[v] = v;
                    depth[v] = depth[node] + 1;
                }
                k = dfs2(v, k);
            }
        }
        out[node] = k;
        return k;
    }

    int lca(int u, int v) {
        while (true) {
            if (head[u] == head[v]) {
                return vid[u] < vid[v] ? u : v;
            }
            if (depth[u] > depth[v]) {
                u = parent[head[u]];
            } else {
                v = parent[head[v]];
            }
        }
    }

    List<Section> forEach(int u, int v) {
        List<Section> res = new ArrayList<>();
        while (true) {
            if (head[u] == head[v]) {
                res.add(new Section(Math.min(vid[u], vid[v]), Math.max(vid[u], vid[v]) + 1));
                return res;
            }
            if (depth[u] > depth[v]) {
                res.add(new Section(vid[head[u]], vid[u] + 1));
                u = parent[head[u]];
            } else {
                res.add(new Section(vid[head[v]], vid[v] + 1));
                v = parent[head[v]];
            }
        }
    }

    List<Section> forEachEdge(int u, int v) {
        List<Section> res = new ArrayList<>();
        while (true) {
            if (head[u] == head[v]) {
                res.add(new Section(Math.min(vid[u], vid[v]) + 1, Math.max(vid[u], vid[v]) + 1));
                return res;
            }
            if (depth[u] > depth[v]) {
                res.add(new Section(vid[head[u]], vid[u] + 1));
                u = parent[head[u]];
            } else {
                res.add(new Section(vid[head[v]], vid[v] + 1));
                v = parent[head[v]];
            }
        }
    }

    Section subtree(int v) {
        return new Section(vid[v], out[v]);
    }

    Section subtreeEdge(int v) {
        return new Section(vid[v] + 1, out[v]);
    }

    int getSubtreeSize(int k) {
        return size[k];
    }

    int getId(int k) {
        return vid[k];
    }

    int getId(int u, int v) {
        return Math.max(vid[u], vid[v]);
    }

    @Override
    public String toString() {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[vid[i]] = i;
        }
        return Arrays.toString(a);
    }
}

class Section {
    static boolean isHalfOpen = true;
    int left;
    int right;

    Section(int left, int right) {
        if (left > right || (isHalfOpen && left == right)) {
            throw new IllegalArgumentException();
        }
        this.left = left;
        this.right = right;
    }

    boolean contains(int x) {
        return isHalfOpen ? left <= x && x < right : left <= x && x <= right;
    }

    boolean contains(Section that) {
        return left <= that.left && that.right <= right;
    }

    int length() {
        return isHalfOpen ? right - left : right - left + 1;
    }

    int commonSectionLength(Section that) {
        if (isHalfOpen) {
            if (left >= that.right || that.left >= right) {
                return 0;
            }
        } else {
            if (left > that.right || that.left > right) {
                return 0;
            }
        }
        return Math.min(right, that.right) - Math.max(left, that.left) + 1;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Section)) {
            return false;
        }
        Section that = (Section)o;
        return left == that.left && right == that.right;
    }

    @Override
    public int hashCode() {
        return Objects.hash(left, right);
    }

    @Override
    public String toString() {
        return String.format(isHalfOpen ? "[%s, %s)" : "[%s, %s]", left, right);
    }
}

class In {
    private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 0x10000);
    private StringTokenizer tokenizer;

    String next() {
        try {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(reader.readLine());
            }
        } catch (IOException ignored) {
        }
        return tokenizer.nextToken();
    }

    int nextInt() {
        return Integer.parseInt(next());
    }

    long nextLong() {
        return Long.parseLong(next());
    }

    double nextDouble() {
        return Double.parseDouble(next());
    }

    char[] nextCharArray() {
        return next().toCharArray();
    }

    String[] nextStringArray(int n) {
        String[] s = new String[n];
        for (int i = 0; i < n; i++) {
            s[i] = next();
        }
        return s;
    }

    char[][] nextCharGrid(int n, int m) {
        char[][] a = new char[n][m];
        for (int i = 0; i < n; i++) {
            a[i] = next().toCharArray();
        }
        return a;
    }

    int[] nextIntArray(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = nextInt();
        }
        return a;
    }

    int[] nextIntArray(int n, IntUnaryOperator op) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = op.applyAsInt(nextInt());
        }
        return a;
    }

    int[][] nextIntMatrix(int h, int w) {
        int[][] a = new int[h][w];
        for (int i = 0; i < h; i++) {
            a[i] = nextIntArray(w);
        }
        return a;
    }

    long[] nextLongArray(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nextLong();
        }
        return a;
    }

    long[] nextLongArray(int n, LongUnaryOperator op) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = op.applyAsLong(nextLong());
        }
        return a;
    }

    long[][] nextLongMatrix(int h, int w) {
        long[][] a = new long[h][w];
        for (int i = 0; i < h; i++) {
            a[i] = nextLongArray(w);
        }
        return a;
    }

    List<List<Integer>> nextEdges(int n, int m, boolean directed) {
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            res.add(new ArrayList<>());
        }
        for (int i = 0; i < m; i++) {
            int u = nextInt() - 1;
            int v = nextInt() - 1;
            res.get(u).add(v);
            if (!directed) {
                res.get(v).add(u);
            }
        }
        return res;
    }
}

class Out {
    private final PrintWriter out = new PrintWriter(System.out);
    boolean autoFlush = false;

    void println(Object... args) {
        if (args == null || args.getClass() != Object[].class) {
            args = new Object[] {args};
        }
        out.println(Arrays.stream(args).map(obj -> {
            Class<?> clazz = obj == null ? null : obj.getClass();
            return clazz == Double.class ? String.format("%.10f", obj) :
                   clazz == byte[].class ? Arrays.toString((byte[])obj) :
                   clazz == short[].class ? Arrays.toString((short[])obj) :
                   clazz == int[].class ? Arrays.toString((int[])obj) :
                   clazz == long[].class ? Arrays.toString((long[])obj) :
                   clazz == char[].class ? Arrays.toString((char[])obj) :
                   clazz == float[].class ? Arrays.toString((float[])obj) :
                   clazz == double[].class ? Arrays.toString((double[])obj) :
                   clazz == boolean[].class ? Arrays.toString((boolean[])obj) :
                   obj instanceof Object[] ? Arrays.deepToString((Object[])obj) :
                   String.valueOf(obj);
        }).collect(Collectors.joining(" ")));
        if (autoFlush) {
            out.flush();
        }
    }

    void println(char[] s) {
        out.println(String.valueOf(s));
        if (autoFlush) {
            out.flush();
        }
    }

    void println(int[] a) {
        StringJoiner joiner = new StringJoiner(" ");
        for (int i : a) {
            joiner.add(Integer.toString(i));
        }
        out.println(joiner);
        if (autoFlush) {
            out.flush();
        }
    }

    void println(long[] a) {
        StringJoiner joiner = new StringJoiner(" ");
        for (long i : a) {
            joiner.add(Long.toString(i));
        }
        out.println(joiner);
        if (autoFlush) {
            out.flush();
        }
    }

    void flush() {
        out.flush();
    }
}

