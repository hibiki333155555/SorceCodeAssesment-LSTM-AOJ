#include<iostream>
#include<algorithm>
using namespace std;
const int NIL = -1;
struct Node
{
    int parent, left, right;
    Node() : parent(NIL), left(NIL), right(NIL){}
};
using Node = struct Node;

inline int getDegree(Node *Tree, int n);
inline int getDepth(Node *Tree, int n);
inline int getHeight(Node *Tree, int n);

int main()
{
    int n = 0;
    cin >> n;
    Node *Tree = new Node[n];

    int _id, _left, _right;
    for (int i = 0; i < n; ++i)
    {
        cin >> _id >> _left >> _right;
        Tree[_id].left = _left;
        Tree[_id].right = _right;
        if(_left != NIL)
            Tree[_left].parent = _id;
        if(_right != NIL)
            Tree[_right].parent = _id;
    }

    for (int i = 0; i < n; ++i)
    {
        cout << "node " << i << ": parent = " << Tree[i].parent << ", sibling = ";
        if(Tree[i].parent == NIL)
            cout << NIL;
        else if(i == Tree[Tree[i].parent].left)
            cout << Tree[Tree[i].parent].right;
        else
            cout << Tree[Tree[i].parent].left;
        cout << ", degree = " << getDegree(Tree, i) << ", depth = " << getDepth(Tree, i)
             << ", height = " << getHeight(Tree, i) << ", ";
        if(Tree[i].parent == NIL)
            cout << "root";
        else if(Tree[i].left == NIL && Tree[i].right == NIL)
            cout << "leaf";
        else
            cout << "internal node";
        cout << endl;
    }

    delete[] Tree;
    return 0;
}
int getDegree(Node *Tree, int n)
{
    return ((Tree[n].left == NIL && Tree[n].right == NIL) ?
         0 : (Tree[n].left != NIL && Tree[n].right != NIL) ? 2  : 1);
}
int getDepth(Node *Tree, int n)
{
    int d = 0;
    while (Tree[n].parent != NIL)
    {
        ++d;
        n = Tree[n].parent;
    }
    return d;
}
int getHeight(Node *Tree, int n)
{
    int h1 = 0, h2 = 0;
    if(Tree[n].left != NIL)
        h1 = getHeight(Tree, Tree[n].left) + 1;
    if(Tree[n].right != NIL)
        h2 = getHeight(Tree, Tree[n].right) + 1;
    return max(h1, h2);
}
