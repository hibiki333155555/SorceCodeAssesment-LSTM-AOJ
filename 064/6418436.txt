#include<bits/stdc++.h>
#define rep(i,n) for(ll i= 0; i < n ; i++)
#define rep2(i,m,n) for(ll i= (m); i <= (n) ; i++)
static const int WH = 0;
static const int GR = 1;
static const int BL = 2;
using namespace std;
using ll = long long;
using ull = unsigned long long;
static const int INF = numeric_limits<int>::max();//最大値
static const int MIN = numeric_limits<int>::min();//最小値
static const ll mod = 1000000007;

int V,E;
struct edge{
    int from;
    int to;
    int amount;
    int initial_amount;
    edge* complement_edge;

    edge(int arg_from, int arg_to, int arg_amount){
        from = arg_from;
        to = arg_to;
        amount = arg_amount;
        initial_amount = arg_amount;
    }

    void set_value(int arg_from, int arg_to, int arg_amount, edge* arg_comp){
        from = arg_from;
        to = arg_to;
        amount = arg_amount;
        complement_edge = arg_comp;
    }
};
vector<vector<edge*>> edges_from_node;
vector<edge*> edge_collection;

bool unit_flow(int start_node, int end_node){
    int is_visited[V];
    stack<edge*> st;
    bool is_reached_end_node = false;

    for(int i = 0; i < V; i++) is_visited[i] = WH;

    for(edge* init_edge_candidate:edges_from_node[start_node]){
        if(init_edge_candidate->amount > 0) st.push(init_edge_candidate);
    }
    is_visited[start_node] = GR;

    while(st.size() > 0){
        edge* current_edge = st.top();
        if(is_visited[current_edge->to] == WH){
            int current_node = current_edge->to;
            is_visited[current_node] = GR;
            current_edge->amount -= 1;
            current_edge->complement_edge->amount += 1;

            if(current_node == end_node){
                is_reached_end_node = true;
                break;
            }
            
            for(edge* edge_candidate: edges_from_node[current_node]){
                if((is_visited[edge_candidate->to] == WH) && (edge_candidate->amount > 0)) st.push(edge_candidate);
            }
        } else if(is_visited[current_edge->to] == GR){
            is_visited[current_edge->to] = BL;
            current_edge->amount += 1;
            current_edge->complement_edge->amount -= 1;
            st.pop();
        } else if(is_visited[current_edge -> to] == BL){
            st.pop();
        }
    }
    return is_reached_end_node;
}

void init(){
    cin >> V >> E;
    edges_from_node.resize(V);

    for(int i = 0; i < E; i++){
        int u,v,c; cin >> u >> v >> c;
        edge *input_edge = new edge(u,v,c);
        edge *input_complement_edge = new edge(v,u,0);
        /*
        (*input_edge).set_value(u,v,c,input_complement_edge);
        (*input_complement_edge).set_value(v,u,0,input_edge);
        */
        input_edge->complement_edge = input_complement_edge;
        input_complement_edge->complement_edge = input_edge;

        edges_from_node[u].emplace_back(input_edge);
        edges_from_node[v].emplace_back(input_complement_edge);

        edge_collection.emplace_back(input_edge);
    }
}

int main(){
    init();

    int num_flow = 0;
    while(1){
        if(unit_flow(0,V-1) == false) break;
        num_flow++;
    }
    cout << num_flow << endl;

    
    return 0;
}
