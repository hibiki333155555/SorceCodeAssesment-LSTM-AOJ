#include<stdio.h>
#include<stdbool.h>
#define MAX 100

int top_p = 0;
int to[MAX][MAX];
int S[MAX];
int visited[MAX], d[MAX], f[MAX];
int time = 1;
int n;

//kをstackに追加
void push(int k){
  S[top_p++] = k;
}

void pop(){
  top_p--;
}

//stackの一番上を返す
int top(){
  return S[top_p - 1];
}

//stackが空ならtrue、そうでないならfalseを返す
bool empty(){
  return top_p == 0;
}

//uに隣接してまだ訪れたことがない頂点のうち、番号が一番小さいものを返す
int next(int u){
  for(int v = 0; v < n; v++ ){
    if(to[u][v] == 1 && visited[v] == 0) return v;
  }
  return -1;
}

//uを始点としてDFSをする
//dに発見時刻、fに完了時刻を入れる（timeは1スタート）
void dfs_visit(int u){

  int v;
  push(u);
  visited[u] = 1;
  d[u] = time++;

  while(!empty()){
    u = top();
    v = next(u);
    if(v != -1){
      d[v] = time++;
      //二行の処理を追加
      push(v);
      visited[v] = 1;
    }else{
       f[u] = time++;
       //一行の処理を追加
      pop();
    }
  }
}

//与えられたグラフに対してDFSをする
void dfs(){

  for(int i = 0; i < n; i++ ){
    //visitedの初期化
    //一行の処理を追加
    visited[i] = 0;
  }

  for(int u = 0; u < n; u++ ){
    if(visited[u] == 0) dfs_visit(u);
  }

}


int main()
{
  int k, u, v;
  scanf("%d", &n);

  for(int i = 0; i < n; i++ ){
    for(int j = 0; j < n; j++ ){
      to[i][j] = 0;
    }
    d[i] = f[i] = 0;
  }

  for(int i = 0; i < n; i++ ){
    scanf("%d", &u);
    scanf("%d", &k);
    for(int j = 0; j < k; j++ ){
      scanf("%d", &v);
      to[u - 1][v - 1] = 1;
    }
  }

  dfs();

  for(int i = 0; i < n; i++ ){
    printf("%d %d %d \n", i + 1, d[i], f[i]);
  }

  return 0;
}
