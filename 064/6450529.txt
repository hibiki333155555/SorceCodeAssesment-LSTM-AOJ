#line 2 "/mnt/c/Users/Cyanmond/ProCon/Library/utilitys.hpp"
#include <algorithm>
#include <array>
#include <cstdint>
#include <cassert>
#include <iterator>
#include <limits>
#include <numeric>
#include <queue>
#include <tuple>
#include <type_traits>
#include <utility>

using i8 = std::int8_t;
using u8 = std::uint8_t;
using i16 = std::int16_t;
using i32 = std::int32_t;
using i64 = std::int64_t;
using u16 = std::uint16_t;
using u32 = std::uint32_t;
using u64 = std::uint64_t;

constexpr i8 operator""_i8(unsigned long long n) noexcept { return static_cast<i8>(n); }
constexpr i16 operator""_i16(unsigned long long n) noexcept {
    return static_cast<i16>(n);
}
constexpr i32 operator""_i32(unsigned long long n) noexcept {
    return static_cast<i32>(n);
}
constexpr i64 operator""_i64(unsigned long long n) noexcept {
    return static_cast<i64>(n);
}
constexpr u8 operator""_u8(unsigned long long n) noexcept { return static_cast<u8>(n); }
constexpr u16 operator""_u16(unsigned long long n) noexcept {
    return static_cast<u16>(n);
}
constexpr u32 operator""_u32(unsigned long long n) noexcept {
    return static_cast<u32>(n);
}
constexpr u64 operator""_u64(unsigned long long n) noexcept {
    return static_cast<u64>(n);
}

constexpr char eoln = '\n';

template <typename T, T Div = 2> constexpr T infty = std::numeric_limits<T>::max() / Div;
template <class T>
using RevPriorityQueue = std::priority_queue<T, std::vector<T>, std::greater<T>>;

constexpr std::array<std::pair<int, int>, 4> dxy4 = {{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}};

class Range {
    struct Iterator {
        int itr;
        constexpr Iterator(const int pos) noexcept : itr(pos) {}
        constexpr void operator++() noexcept { ++itr; }
        constexpr bool operator!=(const Iterator &other) const noexcept {
            return itr != other.itr;
        }
        constexpr int operator*() const noexcept { return itr; }
    };
    const Iterator first, last;

  public:
    explicit constexpr Range(const int f, const int l) noexcept
        : first(f), last(std::max(f, l)) {}
    constexpr Iterator begin() const noexcept { return first; }
    constexpr Iterator end() const noexcept { return last; }
};

class ReversedRange {
    struct Iterator {
        int itr;
        constexpr Iterator(const int pos) noexcept : itr(pos) {}
        constexpr void operator++() noexcept { --itr; }
        constexpr bool operator!=(const Iterator &other) const noexcept {
            return itr != other.itr;
        }
        constexpr int operator*() const noexcept { return itr; }
    };
    const Iterator first, last;

  public:
    explicit constexpr ReversedRange(const int f, const int l) noexcept
        : first(l - 1), last(std::min(f, l) - 1) {}
    constexpr Iterator begin() const noexcept { return first; }
    constexpr Iterator end() const noexcept { return last; }
};

#define SIKICM_REP1(i, r) for (const int i : Range(0, r))
#define SIKICM_REP2(i, l, r) for (int i : Range(l, r))
#define SIKICM_RVP1(i, r) for (const int i : ReversedRange(0, r))
#define SIKICM_RVP2(i, l, r) for (int i : ReversedRange(l, r))
#define SIKICM_SELECT2(a, b, c, name, ...) name
#define REP(...) SIKICM_SELECT2(__VA_ARGS__, SIKICM_REP2, SIKICM_REP1)(__VA_ARGS__)
#define RVP(...) SIKICM_SELECT2(__VA_ARGS__, SIKICM_RVP2, SIKICM_RVP1)(__VA_ARGS__)
#define HRL(n) for ([[maybe_unused]] const int loop_counter : Range(0, n))

template <class Container> constexpr int len(const Container &c) {
    return static_cast<int>(std::size(c));
}

template <typename T> constexpr bool chmin(T &v, const T a) {
    if (v > a) {
        v = a;
        return true;
    }
    return false;
}

template <typename T> constexpr bool chmax(T &v, const T a) {
    if (v < a) {
        v = a;
        return true;
    }
    return false;
}

template <typename T> constexpr T ceil_div(const T x, const T y) {
    assert(y != 0);
    assert(x > 0 and y > 0);
    return (x + y - 1) / y;
}

template <class Container, class T> constexpr int lwb(const Container &c, const T &val) {
    return static_cast<int>(
        std::distance(c.cbegin(), std::lower_bound(c.cbegin(), c.cend(), val)));
}

template <class Container, class T> constexpr int upb(const Container &c, const T &val) {
    return static_cast<int>(
        std::distance(c.cbegin(), std::upper_bound(c.cbegin(), c.cend(), val)));
}

template <class Container, class F> constexpr int lmp(const Container &c, const F &f) {
    return static_cast<int>(
        std::distance(c.cbegin(), std::partition_point(c.cbegin(), c.cend(), f)));
}

template <class F> class RecursiveLambda {
    F f;

  public:
    explicit constexpr RecursiveLambda(F &&f_) : f(std::forward<F>(f_)) {}
    template <class... Args> constexpr auto operator()(Args &&... args) const {
        return f(*this, std::forward<Args>(args)...);
    }
};

template <class F> constexpr decltype(auto) rec_lambda(F &&f) {
    return RecursiveLambda<F>(std::forward<F>(f));
}

template <class T, class... Tail>
void renumber(const std::vector<int> &order, std::vector<T> &head, Tail &... tail) {
    const int n = len(order);
    std::vector<T> sorted_head(n);
    REP(i, n) sorted_head[i] = head[order[i]];

    head = std::move(sorted_head);
    if constexpr (sizeof...(Tail) != 0) {
        renumber(order, tail...);
    }
}

template <class Head, class... Tail>
std::vector<int> priority_sort(std::vector<Head> &head, std::vector<Tail> &... tail) {
    const int n = len(head);
    std::vector<std::tuple<Head, Tail..., int>> res(n);
    REP(i, n) res[i] = std::make_tuple(head[i], tail[i]..., i);
    std::sort(res.begin(), res.end());

    std::vector<int> order(n);
    REP(i, 0, n)
    order[i] = std::get<std::tuple_size_v<std::tuple<Head, Tail...>>>(res[i]);
    renumber(order, head, tail...);
    return order;
}

template <class T> auto make_vec(const int n, const T &value) {
    return std::vector<T>(n, value);
}
template <class... Args> auto make_vec(const int n, Args... args) {
    return std::vector<decltype(make_vec(args...))>(n, make_vec(args...));
}

std::vector<int> iotav(const int n) {
    std::vector<int> ret(n);
    std::iota(ret.begin(), ret.end(), 0);
    return ret;
}

template <class T> std::vector<T> make_prefix_sum(const std::vector<T> &vec) {
    const int n = len(vec);
    std::vector<T> res(n + 1);
    REP(i, n) res[i + 1] = res[i] + vec[i];
    return res;
}

template <class Container> auto calc_sum(const Container &c) {
    return std::accumulate(c.cbegin(), c.cend(),
                           static_cast<typename Container::value_type>(0));
}

template <class T, class F, class... Args>
int apply_id(T first, T last, F &&func, Args &&... args) {
    return std::distance(first, func(first, last, std::forward<Args>(args)...));
}
#line 2 "main.cpp"
#include <bits/stdc++.h>

using namespace std;

#define ALL(x) (x).begin(), (x).end()
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#line 1 "/mnt/c/Users/Cyanmond/ProCon/atcoder/scc.hpp"



#line 7 "/mnt/c/Users/Cyanmond/ProCon/atcoder/scc.hpp"

#line 1 "/mnt/c/Users/Cyanmond/ProCon/atcoder/internal_scc.hpp"



#line 7 "/mnt/c/Users/Cyanmond/ProCon/atcoder/internal_scc.hpp"

#line 1 "/mnt/c/Users/Cyanmond/ProCon/atcoder/internal_csr.hpp"



#line 7 "/mnt/c/Users/Cyanmond/ProCon/atcoder/internal_csr.hpp"

namespace atcoder {
namespace internal {

template <class E> struct csr {
    std::vector<int> start;
    std::vector<E> elist;
    explicit csr(int n, const std::vector<std::pair<int, E>>& edges)
        : start(n + 1), elist(edges.size()) {
        for (auto e : edges) {
            start[e.first + 1]++;
        }
        for (int i = 1; i <= n; i++) {
            start[i] += start[i - 1];
        }
        auto counter = start;
        for (auto e : edges) {
            elist[counter[e.first]++] = e.second;
        }
    }
};

}  // namespace internal

}  // namespace atcoder


#line 9 "/mnt/c/Users/Cyanmond/ProCon/atcoder/internal_scc.hpp"

namespace atcoder {
namespace internal {

// Reference:
// R. Tarjan,
// Depth-First Search and Linear Graph Algorithms
struct scc_graph {
  public:
    explicit scc_graph(int n) : _n(n) {}

    int num_vertices() { return _n; }

    void add_edge(int from, int to) { edges.push_back({from, {to}}); }

    // @return pair of (# of scc, scc id)
    std::pair<int, std::vector<int>> scc_ids() {
        auto g = csr<edge>(_n, edges);
        int now_ord = 0, group_num = 0;
        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);
        visited.reserve(_n);
        auto dfs = [&](auto self, int v) -> void {
            low[v] = ord[v] = now_ord++;
            visited.push_back(v);
            for (int i = g.start[v]; i < g.start[v + 1]; i++) {
                auto to = g.elist[i].to;
                if (ord[to] == -1) {
                    self(self, to);
                    low[v] = std::min(low[v], low[to]);
                } else {
                    low[v] = std::min(low[v], ord[to]);
                }
            }
            if (low[v] == ord[v]) {
                while (true) {
                    int u = visited.back();
                    visited.pop_back();
                    ord[u] = _n;
                    ids[u] = group_num;
                    if (u == v) break;
                }
                group_num++;
            }
        };
        for (int i = 0; i < _n; i++) {
            if (ord[i] == -1) dfs(dfs, i);
        }
        for (auto& x : ids) {
            x = group_num - 1 - x;
        }
        return {group_num, ids};
    }

    std::vector<std::vector<int>> scc() {
        auto ids = scc_ids();
        int group_num = ids.first;
        std::vector<int> counts(group_num);
        for (auto x : ids.second) counts[x]++;
        std::vector<std::vector<int>> groups(ids.first);
        for (int i = 0; i < group_num; i++) {
            groups[i].reserve(counts[i]);
        }
        for (int i = 0; i < _n; i++) {
            groups[ids.second[i]].push_back(i);
        }
        return groups;
    }

  private:
    int _n;
    struct edge {
        int to;
    };
    std::vector<std::pair<int, edge>> edges;
};

}  // namespace internal

}  // namespace atcoder


#line 9 "/mnt/c/Users/Cyanmond/ProCon/atcoder/scc.hpp"

namespace atcoder {

struct scc_graph {
  public:
    scc_graph() : internal(0) {}
    explicit scc_graph(int n) : internal(n) {}

    void add_edge(int from, int to) {
        int n = internal.num_vertices();
        assert(0 <= from && from < n);
        assert(0 <= to && to < n);
        internal.add_edge(from, to);
    }

    std::vector<std::vector<int>> scc() { return internal.scc(); }

  private:
    internal::scc_graph internal;
};

}  // namespace atcoder


#line 13 "main.cpp"

int main() {
    int N, M;
    cin >> N >> M;
    vector<int> A(M), B(M);
    vector<i64> C(M);
    REP(i, M) {
        cin >> A[i] >> B[i] >> C[i];
        --A[i], --B[i];
    }

    auto calc_min = [&]() -> i64 {
        auto judge_connect = [&](i64 lmt) {
            vector<vector<int>> graph(N);
            REP(i, M) if (lmt % C[i] == 0) { graph[A[i]].pb(B[i]); }
            vector<char> visited(N);
            auto dfs = rec_lambda([&](auto &&self, const int v) -> void {
                visited[v] = true;
                for (const int t : graph[v]) {
                    if (not visited[t]) {
                        self(t);
                    }
                }
            });
            dfs(0);
            return visited[N - 1];
        };

        set<int> s;
        i64 ans = infty<i64>;
        REP(bit, 1 << 20) {
            i64 v = 1;
            REP(i, 20) if (bit & (1 << i)) { v = lcm(v, i + 1); }
            if (s.find(v) == s.end()) {
                s.insert(v);
                if (judge_connect(v)) chmin(ans, v);
            }
        }
        if (ans == infty<i64>) ans = -1;
        return ans;
    };

    auto calc_max = [&]() -> i64 {
        atcoder::scc_graph scc(N);
        REP(i, M) scc.add_edge(A[i], B[i]);
        const auto groups = scc.scc();
        vector<int> parent(N);
        vector<i64> lcm_data(N, 1);
        for (const auto &vec : groups) {
            const int leader = vec[0];
            for (const int e : vec) {
                parent[e] = leader;
            }
        }

        vector<vector<pair<int, i64>>> graph(N);
        REP(i, M) {
            if (parent[A[i]] == parent[B[i]]) {
                lcm_data[parent[A[i]]] = lcm(lcm_data[parent[A[i]]], C[i]);
            } else {
                graph[parent[A[i]]].pb({parent[B[i]], C[i]});
            }
        }

        vector<set<i64>> dp(N);
        REP(i, N) dp[i].insert(1);
        dp[parent[0]].insert(lcm_data[parent[0]]);
        vector<bool> visited(N);
        auto dfs = rec_lambda([&](auto &&self, const int v) -> void {
            visited[v] = true;
            for (const auto &[t, c] : graph[v]) {
                if (not visited[t]) {
                    self(t);
                }
            }
        });
        dfs(parent[0]);

        for (const auto &vec : groups) {
            const int leader = vec[0];
            if (not visited[leader]) continue;
            for (const auto &[t, c] : graph[leader]) {
                for (const i64 e : dp[leader]) {
                    dp[t].insert(lcm(lcm_data[t], lcm(e, c)));
                }
            }
        }

        const int lst = parent[N - 1];
        if (dp[lst].empty())
            return -1;
        else
            return *dp[lst].rbegin();
    };

    const i64 mi = calc_min();
    if (mi == -1) {
        cout << "IMPOSSIBLE" << eoln;
    } else {
        cout << mi << ' ' << calc_max() << eoln;
    }
}

