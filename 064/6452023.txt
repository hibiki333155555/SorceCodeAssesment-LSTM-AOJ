#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

template<typename T>
struct Dijkstra{
    const T inf=numeric_limits<T>::max();
    using P=pair<T,int>;
    int n;
    vector<vector<pair<int,T>>> g;
    vector<T> d;
    Dijkstra(int n):n(n),g(n),d(n){}
    void add_edge(int u,int v,T w){
        g[u].emplace_back(v,w);
        g[v].emplace_back(u,w);
    }
    vector<T> build(int s){
        for(int i=0;i<n;i++){
            d[i]=inf;
        }
        d[s]=0;
        priority_queue<P,vector<P>,greater<P>> pq;
        pq.emplace(d[s],s);
        while(pq.size()){
            P p=pq.top(); pq.pop();
            int v=p.second;
            if(d[v]<p.first)continue;
            for(auto &e:g[v]){
                int u=e.first; T c=e.second;
                if(d[u]>d[v]+c){
                    d[u]=d[v]+c;
                    pq.emplace(d[u],u);
                }
            }
        }
        return d;
    }
};

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n; cin >> n;
    Dijkstra<ll> g(n);
    vector<pair<int,int>> a(n),b(n);
    for(int i=0;i<n;i++){
        cin >> a[i].first;
        a[i].second = i;
    }
    for(int i=0;i<n;i++){
        cin >> b[i].first;
        b[i].second = i;
    }
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    for(int i=0;i+1<n;i++){
        g.add_edge(a[i].second, a[i+1].second, a[i+1].first-a[i].first);
    }
    swap(a,b);
    for(int i=0;i+1<n;i++){
        g.add_edge(a[i].second, a[i+1].second, a[i+1].first-a[i].first);
    }
    auto r = g.build(0);
    for(int i=0;i<n;i++){
        cout << r[i] << "\n";
    }
}


