#ifdef SUMMARY

#library <mint>

#library <graph_template>

#library <bfs>

mint dp[4040][4040];

int solve(){
	lin(n, k);
	vin(lint, a, n);
	vin(lint, p, n-1);
	i0(p);
	Graph g(n);
	rep(n-1)g.add_edge(p[i], i+1, 0, 1);

	dp[0][a[0]] = 1;
	bfs(n, 0, [&](int c)->Edges{return g[c]; }, [&](edge e)->void{
		rep(j, k){
			dp[e.to][j+a[e.to]] += dp[e.src][j];
		}
	});
	mint ans = 0;
	rep(n)ans += dp[i][k];
	out(ans);
	return 0;
}

#endif // SUMMARY

//sub-BOF

// author: Tqk
// pc: desktop
// template version: D20220314

#define _AOJ_
#define _C_INPUT_

//#pragma region template

//#pragma region basic
#define IN_FILE "./in.txt"
//#pragma GCC optimize ("O3")
#pragma warning(disable: 4455 4244 4067 4068 4996)
#pragma GCC target ("avx")
#pragma GCC diagnostic ignored "-Wliteral-suffix"
#define NOMINMAX
#ifdef _ENV_TQK_
#include <Windows.h>
#endif
#include "bits/stdc++.h"
using namespace std;
#ifndef _AOJ_
#include <atcoder/all>
#endif
#define ac atcoder
using lint = int64_t;
using ll = int64_t;
using ld = long double;
using cs = string;
using vl = vector<ll>;
#define _getname1(_0, name, ...) name
#define _getname2(_0, _1, name, ...) name
#define _getname3(_0, _1, _2, name, ...) name
#define _getname4(_0, _1, _2, _3, name, ...) name
#define _tgetname1(ex) _getname1 ex
#define _tgetname2(ex) _getname2 ex
#define _tgetname3(ex) _getname3 ex
#define _tgetname4(ex) _getname4 ex
#define _vec2(ty, h, ...) h, vector<ty>(__VA_ARGS__)
#define _vec3(ty, x, y, ...) x, vector(y, vector<ty>(__VA_ARGS__))
#define _vec4(ty, x, y, z, ...) x, vector(y, vector(z, vector<ty>(__VA_ARGS__)))
#define _vec5(ty, x, y, z, t, ...) x, vector(y, vector(z, vector(t, vector<ty>(__VA_ARGS__))))
#define _tvec2(ex) _vec2 ex
#define _tvec3(ex) _vec3 ex
#define _tvec4(ex) _vec4 ex
#define _tvec5(ex) _vec5 ex
#define vec(d, ...) _tvec##d((__VA_ARGS__))
#define ve(ty) vector<ty>
#define linf 1152921504606846976
#ifndef _AOJ_
inline ll operator""z(const unsigned long long n){ return ll(n); }
#endif
//#pragma endregion

//#pragma region rep
#define _rep1(n) for(ll i=0;i<n;++i)
#define _rep2(i,n) for(ll i=0;i<n;++i)
#define _rep3(i,a,b) for(ll i=a;i<b;++i)
#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)
#define _trep2(ex) _rep2 ex
#define _trep3(ex) _rep3 ex
#define _trep4(ex) _rep4 ex
#define rep(...) _tgetname4((__VA_ARGS__,_trep4,_trep3,_trep2,_rep1))((__VA_ARGS__))
#define _per1(n) for(ll i=n-1;i>=0;--i)
#define _per2(i,n) for(ll i=n-1;i>=0;--i)
#define _per3(i,a,b) for(ll i=b-1;i>=a;--i)
#define _per4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)
#define _tper2(ex) _per2 ex
#define _tper3(ex) _per3 ex
#define _tper4(ex) _per4 ex
#define per(...) _tgetname4((__VA_ARGS__,_tper4,_tper3,_tper2,_per1))((__VA_ARGS__))
#define _all1(v) v.begin(),v.end()
#define _all2(v,a) v.begin(),v.begin()+a
#define _all3(v,a,b) v.begin()+a,v.begin+b
#define _tall2(ex) _all2 ex
#define _tall3(ex) _all3 ex
#define all(...) _tgetname3((__VA_ARGS__,_tall3,_tall2,_all1))((__VA_ARGS__))
#define _each1(c) for(auto &e:c)
#define _each2(e, c) for(auto &e:c)
#define _teach2(ex) _each2 ex
#define each(...) _tgetname2((__VA_ARGS__,_teach2,_each1))((__VA_ARGS__))
//#pragma endregion

//#pragma region io
template<class T> istream& operator>>(istream& is, vector<T>& vec){ for(T& x: vec) is>>x; return is; }
template<class T, class U> istream& operator>>(istream& is, pair<T, U>& p){ is>>p.first; is>>p.second; return is; }
template<class T> ostream& operator<<(ostream& os, vector<T>& vec){ if(vec.size())os<<vec[0]; rep(i, 1, vec.size())os<<' '<<vec[i]; return os; }
template<class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p){ os<<p.first<<" "<<p.second; return os; }
template<class T> ostream& operator<<(ostream& os, set<T>& s){ each(s)os<<e<<" "; return os; }

#ifdef _ENV_TQK_
/*
ifstream infile(IN_FILE);
template<class T>
ifstream& operator>>(ifstream& is,vector<T>& vec);
template<class T,size_t size>
ifstream& operator>>(ifstream& is,array<T,size>& vec);
template<class T,class L>
ifstream& operator>>(ifstream& is,pair<T,L>& p);
template<class T>
ifstream& operator>>(ifstream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }
template<class T,class L>
ifstream& operator>>(ifstream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }
inline void fin(){}
template <class Head,class... Tail>
inline void fin(Head&& head,Tail&&... tail){ infile>>head;fin(move(tail)...); }
*/
HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
inline void in(){ SetConsoleTextAttribute(hConsole,10); }
template <class Head,class... Tail>
inline void in(Head&& head,Tail&&... tail){
	SetConsoleTextAttribute(hConsole,15);
	cin>>head;in(move(tail)...);
}
#else
inline void in(){}
template <class Head,class... Tail>
inline void in(Head&& head,Tail&&... tail){ cin>>head;in(move(tail)...); }
#endif

inline bool out(){ return(cout<<'\n',0); }
template <class T>
inline bool out(T t){ return(cout<<t<<'\n',0); }
template <class Head,class... Tail>
inline bool out(Head head,Tail... tail){ cout<<head<<' ';out(move(tail)...);return 0; }
#define o(p) cout<<(p)<<endl, 0
#define sp(p) cout<<(p)<<" ", 0
#define no(p) cout<<(p), 0
#ifdef _ENV_TQK_
inline bool deb(){ SetConsoleTextAttribute(hConsole,10); return(cout<<'\n',0); }
template <class T>
inline bool deb(T t){ return(SetConsoleTextAttribute(hConsole,12),cout<<t<<'\n',SetConsoleTextAttribute(hConsole,10),0); }
template <class Head,class... Tail>
inline bool deb(Head head,Tail... tail){
	SetConsoleTextAttribute(hConsole,12);
	cout<<head<<' ';deb(move(tail)...);return 0;
}
#define dsp(ex) SetConsoleTextAttribute(hConsole,12), sp(ex)
#define dno(ex) SetConsoleTextAttribute(hConsole,12), no(ex)
#define look(v) SetConsoleTextAttribute(hConsole,12),cout<<#v<<": ",deb(v);
#else
#define deb(...) 0
#define dsp(ex) 0
#define dno(ex) 0
#define look(v) 0
#endif

//#pragma endregion

//#pragma region TA
#define lin(...) ll __VA_ARGS__;in(__VA_ARGS__)
#define stin(...) string __VA_ARGS__;in(__VA_ARGS__)
#define vin(type,name,size) vector<type> name(size);in(name)
#define pb push_back
#define fi e.first
#define se e.second
#define YES(c) cout<<((c)?"YES\n":"NO\n"),0
#define Yes(c) cout<<((c)?"Yes\n":"No\n"),0
#define POSSIBLE(c) cout<<((c)?"POSSIBLE\n":"IMPOSSIBLE\n"),0
#define Possible(c) cout<<((c)?"Possible\n":"Impossible\n"),0
#define st(v) sort(all(v))
#define psort(l,r) if(l>r)swap(l,r);
#define fn(ty1,ty2,ex) [&](ty1 l,ty2 r){ return(ex); }
#define lfn(ex) [&](ll l,ll r){ return(ex); }

//#pragma endregion

//#pragma region func
vector<ll>& iota(ll n){
	vector<ll>ret(n);
	iota(all(ret), 0);
	return ret;
}
inline constexpr ll gcd(ll a,ll b){ while(b){ ll c=b;b=a%b;a=c; }return a; }
inline constexpr ll lcm(ll a,ll b){ return a/gcd(a,b)*b; }
template<typename T>
inline constexpr bool chmin(T &mn,const T &cnt){ if(mn>cnt){ mn=cnt;return 1; } else return 0; }
template<typename T>
inline constexpr bool chmax(T &mx,const T &cnt){ if(mx<cnt){ mx=cnt;return 1; } else return 0; }
template <class F>
inline void srt(F f){  }
template <class F, class Head, class... Tail>
inline void srt(F f, Head&& head, Tail&&... tail){
	vector<int>a(head.size());
	iota(all(a), 0);
	sort(all(a), f);
	auto res = head;
	rep(head.size())res[i] = head[a[i]];
	head = res;
	srt(f, move(tail)...);
}
template <class T>
auto smaller(vector<T>&a){
	return [&](int i,int j){return a[i]<a[j];};
}
template <class T>
auto larger(vector<T>&a){
	return [&](int i,int j){return a[i]>a[j];};
}
inline void i0(){  }
template<class Head, class... Tail>
inline void i0(Head&& head,Tail&&... tail){
	each(head)--e;
	i0(move(tail)...);
}
//#pragma endregion

//#pragma region P

class P{
public:
	ll f, s;
	P():f(0), s(0){};
	P(ll a, ll b):f(a), s(b){};
};
istream& operator>>(istream& os, P& p){ os>>p.f>>p.s; return os; }
inline constexpr bool operator<(const P& l, const P& r){ return(l.f-r.f?l.f<r.f:l.s<r.s); }
inline constexpr bool operator>(const P& l, const P& r){ return(l.f-r.f?l.f>r.f:l.s>r.s); }
inline constexpr bool operator==(const P& l, const P& r){ return(l.f==r.f&&l.s==r.s); }
inline constexpr bool operator!=(const P& l, const P& r){ return(l.f!=r.f||l.s!=r.s); }
inline P operator+(const P& l, const P& r){ return P(l.f+r.f, l.s+r.s); }
inline P operator-(const P& l, const P& r){ return P(l.f-r.f, l.s-r.s); }
inline P operator-(const P& r){ return P(-r.f, -r.s); }
inline P operator*(const ll& l, const P& r){ return P(l*r.f, l*r.s); }
inline P operator/(const P& l, const ll& r){ return P(l.f/r, l.s/r); }
inline ld abs(P p){ return sqrtl(p.f*p.f+p.s*p.s); }
inline ll mabs(P p){ return abs(p.f)+abs(p.s); }
inline ll mht(P x, P y){ return mabs(x-y); }

//#pragma endregion

//#pragma region start
struct Start{
	Start(){
#ifndef _C_INPUT_
		cin.tie(0),cout.tie(0);
		ios::sync_with_stdio(0);
#endif
		cout<<fixed<<setprecision(16);
	}
} __start;
//#pragma endregion

//#pragma endregion

//#pragma region const
#define mod 998244353
const ld pi=acosl(-1);
const ld tau=(1.+sqrtl(5))/2.;
P d4[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};
P d8[8]={P(1,0),P(1,1),P(0,1),P(-1,1),P(-1,0),P(-1,-1),P(0,-1),P(1,-1)};
const cs AUTO_YES = "Yes";
const cs AUTO_NO = "No";
int cho(bool c,cs yes=AUTO_YES,cs no=AUTO_NO){
	return out((c?yes:no));
}
//#pragma endregion

//#pragma region solve

//#pragma region lib_mint
//, url:"https://tqkoh.github.io/library/lib/util/mint.hpp", version:"2020-08-11"

#define md_tmp template<uint_fast64_t md=mod>
md_tmp class modint{
	using u64 = uint_fast64_t;

public:
	u64 a;

	constexpr modint(const lint x = 0) noexcept: a((x+md)%md){}
	constexpr u64 &value() noexcept{ return a; }
	constexpr const u64 &value() const noexcept{ return a; }
	constexpr modint operator+(const modint rhs) const noexcept{
		return modint(*this) += rhs;
	}
	constexpr modint operator-(const modint rhs) const noexcept{
		return modint(*this) -= rhs;
	}
	constexpr modint operator*(const modint rhs) const noexcept{
		return modint(*this) *= rhs;
	}
	constexpr modint operator^(const lint rhs) const noexcept{
		return modint(*this) ^= rhs;
	}
	constexpr modint operator/(const modint rhs) const noexcept{
		return modint(*this) /= rhs;
	}
	constexpr modint &operator+=(const modint rhs) noexcept{
		a += rhs.a;
		if(a>=md)a -= md;
		return *this;
	}
	constexpr modint &operator-=(const modint rhs) noexcept{
		if(a<rhs.a)a += md;
		a -= rhs.a;
		return *this;
	}
	constexpr modint &operator*=(const modint rhs) noexcept{
		a = a*rhs.a%md;
		return *this;
	}
	constexpr modint &operator^=(const lint rhs) noexcept{
		if(!rhs)return *this = 1;
		u64 exp = rhs-1;
		modint base = a;
		while(exp){
			if(exp&1)*this *= base;
			base *= base;
			exp >>= 1;
		}
		return *this;
	}
	constexpr modint &operator/=(const modint rhs) noexcept{
		a = (*this*(rhs^(md-2))).a;
		return *this;
	}
};
md_tmp istream& operator>>(istream& os, modint<md>& m){
	os>>m.a, m.a %= md;
	return os;
}
md_tmp ostream& operator<<(ostream& os, const modint<md>& m){
	return os<<m.a;
}
using mint = modint<>;
//#ifndef _AOJ_
//mint operator""m(unsigned long long n){ return mint(n); }
//#endif

/*
* @title Mint
* @see https://noshi91.hatenablog.com/entry/2019/03/31/174006
*/


//#pragma endregion

//#pragma region lib_graph_template
//, url:"https://tqkoh.github.io/library/lib/graph/graph-template.hpp", version:"2021-11-09"

using length = lint;
struct edge{
	int src, to, id;
	edge() = default;
	edge(int src, int to, int id = 0): src(src), to(to), id(id){}
};

using Edges = vector<edge>;
class Graph: public vector<Edges>{
public:
	Graph(int n){
		this->resize(n);
	}
	void add_edge(edge e, bool directed = 0){
		(*this)[e.src].push_back(e);
		if(!directed)(*this)[e.to].push_back(edge(e.to, e.src, e.id));
	}
	void add_edge(int src, int to, int id = 0, bool directed = 0){
		(*this)[src].push_back(edge(src, to, id));
		if(!directed)(*this)[to].push_back(edge(to, src, id));
	}
};
class Matrix: public vector<vector<length>>{
public:
	Matrix(int n, length inf = 2*linf){
		this->resize(n, vector<length>(n, inf));
		for(int i = 0; i<n; ++i)(*this)[i][i] = 0;
	}
	void add_edge(edge e, length cost, bool directed = 0){
		if((*this)[e.src][e.to]>cost)(*this)[e.src][e.to] = cost;
		if(!directed)if((*this)[e.to][e.src]>cost)(*this)[e.to][e.src] = cost;
	}
	void add_edge(int src, int to, length cost, bool directed = 0){
		if((*this)[src][to]>cost)(*this)[src][to] = cost;
		if(!directed)if((*this)[to][src]>cost)(*this)[to][src] = cost;
	}
};


/*
* @title Graph Template
*/


//#pragma endregion

//#pragma region lib_bfs
//, url:"https://tqkoh.github.io/library/lib/graph/bfs.hpp", version:"2022-03-11"

template<class veFi, class vFe >
void bfs(int n, int s, veFi g, vFe dtmn){
	vector<int>vis(n); vis[s] = 1;
	queue<int>q({ s });
	while(q.size()){
		int c = q.front(); q.pop();
		for(auto e: g(c))if(!vis[e.to])vis[e.to] = 1, dtmn(e), q.push(e.to);
	}
}

/*
* @title BFS
*/


//#pragma endregion

mint dp[4040][4040];

int solve(){
	lin(n, k);
	vin(lint, a, n);
	vin(lint, p, n-1);
	i0(p);
	Graph g(n);
	rep(n-1)g.add_edge(p[i], i+1, 0, 1);

	dp[0][a[0]] = 1;
	bfs(n, 0, [&](int c)->Edges{return g[c]; }, [&](edge e)->void{
		rep(j, k){
			dp[e.to][j+a[e.to]] += dp[e.src][j];
		}
	});
	mint ans = 0;
	rep(n)ans += dp[i][k];
	out(ans);
	return 0;
}

//#pragma endregion

//#pragma region main

int main(){
	solve();
}

//#pragma endregion

//sub-EOF
