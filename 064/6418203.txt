#pragma GCC optimize("O3")
#include<bits/stdc++.h> 
using namespace std;
using ll=long long;
using P=pair<ll,ll>;
template<class T> using V=vector<T>; 
#define fi first
#define se second
#define all(v) (v).begin(),(v).end()
const ll inf=(1e18);
const ll mod=998244353;
// const ll mod=1000000007;
const vector<int> dy={-1,0,1,0},dx={0,-1,0,1};
struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;
template<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }
template<class T>void debag(const vector<T> &a){cerr<<"debag :";for(auto v:a)cerr<<v<<" ";cerr<<"\n";}
template<class T>void print(const vector<T> &a){for(auto v:a)cout<<v<<" ";cout<<"\n";}
struct mint{
    using ull=unsigned long long int;
    ull v;
    mint(ll vv=0){s(vv%mod+mod);}
    mint& s(ull vv){
        v=vv<mod?vv:vv-mod;
        return *this;
    }
    //オーバーロード
    mint operator-()const{return mint()-*this;}//mint型にキャスト
    mint&operator+=(const mint&val){return s(v+val.v);}
    mint&operator-=(const mint&val){return s(v+mod-val.v);}
    mint&operator*=(const mint&val){
        v=ull(v)*val.v%mod;
        return *this;
    }
    mint&operator/=(const mint&val){return *this*=val.inv();}
    mint operator+(const mint&val){return mint(*this)+=val;}
    mint operator-(const mint&val){return mint(*this)-=val;}
    mint operator*(const mint&val){return mint(*this)*=val;}
    mint operator/(const mint&val){return mint(*this)/=val;}
    mint pow(ll n)const{
        mint res(1),x(*this);
        while(n){
            if(n&1)res*=x;
            x*=x;
            n>>=1ll;
        }
        return res;
    }
    mint inv()const{return pow(mod-2);}
    //拡張ユークリッドの互除法
    /* mint inv()const{
        int x,y;
        int g=extgcd(v,mod,x,y);
        assert(g==1);
        if(x<0)x+=mod;
        return mint(x);
    }*/
    friend ostream& operator<<(ostream&os,const mint&val){
        return os<<val.v;
    }//出力
    bool operator<(const mint&val)const{return v<val.v;}
    bool operator==(const mint&val)const{return v==val.v;}
    bool operator>(const mint&val)const{return v>val.v;}
};
template<class T> struct Matrix{
    vector<vector<T>> A;

    Matrix() {}
    Matrix(int n,int m):A(n,vector<T>(m,0)) {}
    Matrix(int n):A(n,vector<T>(n,0)) {}

    int height() const{return (A.size());}
    int width() const{return (A[0].size());}
    inline const vector<T> &operator[](int k)const{return (A.at(k));}
    inline vector<T> &operator[](int k){return (A.at(k));}

   //単位行列
    static Matrix I(int n){
        Matrix mat(n);
        for(int i=0;i<n;i++)mat[i][i]=(T)(1);
        return mat;
    }

    Matrix &operator+=(const Matrix &B){
        int n=height(),m=width();
        assert(n==B.height()&&m==B.width());
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                (*this)[i][j]+=B[i][j];
            }
        }
        return (*this);
    }
    Matrix &operator-=(const Matrix &B){
        int n=height(),m=width();
        assert(n==B.height()&&m==B.width());
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                (*this)[i][j]-=B[i][j];
            }
        }
        return (*this);
    }
    Matrix &operator*=(const Matrix &B){
        int n=height(),m=B.width(),w=height();
        assert(w==B.height());
        vector<vector<T>> C(n,vector<T>(m,0));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                for(int k=0;k<w;k++){
                    C[i][j]+=(*this)[i][k]*B[k][j];
                }
            }
        }
        A.swap(C);
        return (*this);
    }

    //累乗計算
    Matrix &operator^=(long long k){
        Matrix B=Matrix::I(height());
        while(k>0){
            if(k&1){
                B*=(*this);
            }
            (*this)*=(*this);
            k>>=1ll;
        }
        A.swap(B.A);
        return (*this);
    }

    Matrix operator+(const Matrix &B)const{return (Matrix(*this)+=B);}
    Matrix operator-(const Matrix &B)const{return (Matrix(*this)-=B);}
    Matrix operator*(const Matrix &B)const{return (Matrix(*this)*=B);}
    Matrix operator^(const long long k)const{return (Matrix(*this)^=k);}

    friend ostream &operator<<(ostream &os,Matrix &mat){
        int n=mat.height(),m=mat.width();
        for(int i=0;i<n;i++){
            os<<"[";
            for(int j=0;j<m;j++){
                os<<mat[i][j]<<(j+1==m?"]\n":",");
            }
        }
        return (os);
    }

    //行列式
    T det(){
        Matrix B(*this);
        assert(height()==width());
        T ret=(T)(1);
        for(int i=0;i<width();i++){
            int idx=-1;
            for(int j=i;j<width();j++){
                if(!(B[j][i]==(T)(0)))idx=j;
            }
            if(idx==-1)return (T)(0);
            if(i!=idx){
                ret*=(T)(-1);
                swap(B[i],B[idx]);
            }
            ret*=B[i][i];
            T v=B[i][i];
            for(int j=0;j<width();j++){
                B[i][j]/=v;
            }
            for(int j=i+1;j<width();j++){
                T a=B[j][i];
                for(int k=0;k<width();k++){
                    B[j][k]-=B[i][k]*a;
                }
            }
        }
        return (ret);
    }
};
ll to_num(string &s){
   ll res=0;int sz=s.size();
    for(int i=0;i<sz;i++){
        res*=10;
        res+=s[i]-'0';
    }
    return res;
}
string chstring(ll num){
  string res="";
  if(num<0){
    res.push_back('-');
    num=-num;
  }
  res+=to_string(num);
  return res;
}
void compress(V<string> &a){
    int sz=a.size();
    V<P> tmp;
    for(int i=0;i<sz;i++){
          P p;
          string s=a[i];
            string t="";int m=s.size();
            for(int j=0;j<m;j++){
                if(s[j]=='*'){
                  p.fi=to_num(t);
                  t.clear();
                }
                t.push_back(s[j]);
            }
            p.se=to_num(t);
            if(tmp.size()&&tmp.back().se==p.se)tmp.back().fi+=p.fi;
            else tmp.emplace_back(p);
    }
    V<string> res;
    for(auto p:tmp){
      string t="";
        t+=chstring(p.fi);
        t.push_back('*');
        t+=chstring(p.se);
        res.emplace_back(t);
    }
    swap(a,res);
}
map<char,mint> mp;
ll get_num(string s){
  if(s.back()==')')s.pop_back();
  int sz=s.size();
  mint res=mint(0);
  ll c=1;
  for(int i=0;i<sz;i++){
      if(s[i]=='-'){
        c*=-1;
        continue;
      }
      if(isdigit(s[i])){
          mint v=mint(0);
          while(i<sz&&isdigit(s[i])){
            v*=mint(10);v+=mint((ll)(s[i]-'0'));
            i++;
          }
          i--;
          if(c==-1)res-=v;
          else res+=v;
          c=1;
      }else if(s[i]=='+'){
        continue;
      }else if(mp.count(s[i])){
          if(c==-1)res-=mint(mp[s[i]]);
          else res+=mint(mp[s[i]]);
          c=1;
      }
  }
  return (ll)res.v;
}
pair<ll,mint> get_line(char ch,string s){
  int sz=s.size();
  mint res=mint(0);
  ll cnt=0,c=1;
  for(int i=0;i<sz;i++){
      if(s[i]=='-'){
        c*=-1;
        continue;
      }
      if(isdigit(s[i])){
          mint v=mint(0);
          while(i<sz&&isdigit(s[i])){
            v*=mint(10);v+=mint((ll)(s[i]-'0'));
            i++;
          }
          i--;
          if(c==-1)res-=v;
          else res+=v;
          c=1;
      }else if(s[i]=='+'){
        continue;
      }else if(s[i]!=ch&&mp.count(s[i])){
          if(c==-1)res-=mp[s[i]];
          else res+=mp[s[i]];
          c=1;
      }else if(s[i]==ch){
        cnt+=c;
        c=1;
      }
  }
  return  make_pair(cnt,res);
}
V<string> a[2];
V<string> res[2];
void calc(int c,int id){
    if(id==(int)(a[c].size()))return;
    string s=a[c][id];
    int sz=s.size();
    if(sz==1){
      mp[s[0]]=0;
      calc(c,id+1);
      return;
    }
    ll bfor=1;
    string ans="";
    for(int i=0;i<sz;i++){
        if(i+5<sz&&s.substr(i,5)=="print"){
          if(bfor>0){
            ans+=chstring(bfor);
            ans.push_back('*');
            ans+=chstring(get_num(s.substr(i+6,sz)));
          }
          break;
        }
        if(i+3<sz&&s.substr(i,3)=="for"){
              i+=4;
              int l=i;
              string tmp="";
              while(l<sz&&s[l]!=')'){
                  tmp.push_back(s[l]);
                  l++;
              }
              bfor*=get_num(tmp);
              i=l;
              continue;
        }
        else if(mp.count(s[i])){
          //更新パートやばすぎ
          auto[x,b]=get_line(s[i],s.substr(i+3,sz));
          Matrix<mint> mat(2,2),num(2,1);
          mat[0][0]=mint(x+mod);
          mat[0][1]=mint(1);
          mat[1][1]=mint(1);
          num[0][0]=mp[s[i]];
          num[1][0]=b;
          mat^=bfor;
          mat*=num;
          mp[s[i]]=mat[0][0];
          break;
        }
    }
    if(ans.size())res[c].emplace_back(ans);
    calc(c,id+1);
}
int n,m;
void solve(){
  cin>>n>>m;
  if(max(n,m)==0)exit(0);
  a[0]=V<string>(n);a[1]=V<string>(m);
  res[0].clear();res[1].clear();
  for(int i=0;i<n;i++)cin>>a[0][i];
  for(int i=0;i<m;i++)cin>>a[1][i];
  mp.clear();
  calc(0,0);
  mp.clear();
  calc(1,0);
  compress(res[0]);
  compress(res[1]);
  cout<<(res[0]==res[1]?"Yes":"No")<<"\n";
}
int main(){
  while(1)solve();
}
