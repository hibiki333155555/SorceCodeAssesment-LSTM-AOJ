import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
const long mod = 1_000_000_000 + 7;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

void main () {
  int N, M;
  readf("%s %s\n", &N, &M);

  auto g = new long[][](N, N);
  foreach (u; 0 .. N)
    foreach (v; 0 .. N)
      g[u][v] = INF;
  foreach (j; 0 .. M) {
    int s, t;
    long d;
    readf("%s %s %s\n", &s, &t, &d);
    g[s][t] = d;
  }

  auto dp = new long[][](1L << N, N);
  foreach (s; 0 .. (1L << N))
    foreach (u; 0 .. N)
      dp[s][u] = INF;
  dp[0][0] = 0L;
  foreach (s; 0 .. (1L << N)) {
    foreach (u; 0 .. N) {
      if (dp[s][u] == INF)
        continue;

      foreach (v; 0 .. N) {
        if (g[u][v] == INF)
          continue;
        if (s & (1L << v))
          continue;

        chmin(dp[s | (1L << v)][v], dp[s][u] + g[u][v]);
      }
    }
  }

  long ret = dp[(1L << N) - 1][0];
  if (ret == INF)
    writeln ("-1");
  else
    writeln(ret);
}

