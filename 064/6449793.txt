#include <bits/stdc++.h>
using namespace std;

#define all(a) begin(a), end(a)
#define rall(a) rbegin(a), rend(a)
#define uniq(a) (a).erase(unique(all(a)), (a).end())
using ll = long long;
using ull = unsigned long long;
using pll = pair<ll, ll>;
using vll = vector<ll>;
constexpr double PI = 3.14159265358979323846;
constexpr ll dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};
constexpr ll dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};
constexpr ll sign(ll a) { return (a > 0) - (a < 0); }
constexpr ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }
constexpr ll cdiv(ll a, ll b) { return -fdiv(-a, b); }
constexpr ull bit(int n) { return 1ull << n; }
template <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &a) {
    os << "(" << a.first << ", " << a.second << ")";
    return os;
}
template <typename T, typename U, typename V> ostream &operator<<(ostream &os, const tuple<T, U, V> &a) {
    os << "(" << get<0>(a) << ", " << get<1>(a) << ", " << get<2>(a) << ")";
    return os;
}
template <typename T> ostream &operator<<(ostream &os, const vector<T> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
template <typename T> ostream &operator<<(ostream &os, const set<T> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
template <typename T> ostream &operator<<(ostream &os, const multiset<T> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
template <typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
#ifdef ONLINE_JUDGE
#define dump(...) (void(0))
#else
void debug() { cerr << endl; }
template <typename Head, typename... Tail> void debug(Head &&head, Tail &&... tail) {
    cerr << head;
    if (sizeof...(Tail)) cerr << ", ";
    debug(tail...);
}
#define dump(...) cerr << __LINE__ << ": " << #__VA_ARGS__ << " = ", debug(__VA_ARGS__)
#endif
template <typename T> constexpr T mypow(T x, ll n) {
    T ret = 1;
    while (n) {
        if (n & 1) ret *= x;
        x *= x;
        n >>= 1;
    }
    return ret;
}
constexpr ll modpow(ll x, ll n, ll mod) {
    x %= mod;
    ll ret = 1;
    while (n) {
        if (n & 1) ret *= x;
        x *= x;
        n >>= 1;
        x %= mod;
        ret %= mod;
    }
    return ret;
}
template <typename T> T xor64(T lb, T ub) {
    static ull x = 88172645463325252ull;
    x ^= x << 7;
    return lb + (x ^= x >> 9) % (ub - lb);
}
constexpr ll safemod(ll x, ll mod) { return (x % mod + mod) % mod; }
template <typename T> constexpr T sq(const T &a) { return a * a; }
template <typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
template <typename T, typename U> bool chmax(T &a, const U &b) { return a < b ? a = b, true : false; }
template <typename T, typename U> bool chmin(T &a, const U &b) { return a > b ? a = b, true : false; }
template <typename T> T make_vector(T &&a) { return a; }
template <typename... Ts> auto make_vector(int h, Ts &&... ts) { return vector(h, make_vector(ts...)); }
struct rep {
    struct itr {
        ll v;
        itr(ll v) : v(v) {}
        void operator++() { ++v; }
        ll operator*() const { return v; }
        bool operator!=(itr i) const { return v < *i; }
    };
    ll l, r;
    rep(ll l, ll r) : l(l), r(r) {}
    rep(ll r) : rep(0, r) {}
    itr begin() const { return l; };
    itr end() const { return r; };
};
struct per {
    struct itr {
        ll v;
        itr(ll v) : v(v) {}
        void operator++() { --v; }
        ll operator*() const { return v; }
        bool operator!=(itr i) const { return v > *i; }
    };
    ll l, r;
    per(ll l, ll r) : l(l), r(r) {}
    per(ll r) : per(0, r) {}
    itr begin() const { return r - 1; };
    itr end() const { return l - 1; };
};
struct io_setup {
    static constexpr int PREC = 20;
    io_setup() {
        cout << fixed << setprecision(PREC);
        cerr << fixed << setprecision(PREC);
    };
} iOS;
template <ll MOD = 1000000007> struct modint {
    ll val;
    modint(ll val = 0) : val(val >= 0 ? val % MOD : (MOD - (-val) % MOD) % MOD) {}
    static ll mod() { return MOD; }
    modint inv() const {
        ll a = val, b = MOD, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            swap(a -= t * b, b);
            swap(u -= t * v, v);
        }
        return modint(u);
    }
    modint pow(ll k) const {
        modint ret = 1, mul = val;
        while (k) {
            if (k & 1) ret *= mul;
            mul *= mul;
            k >>= 1;
        }
        return ret;
    }
    modint &operator+=(const modint &a) {
        if ((val += a.val) >= MOD) val -= MOD;
        return *this;
    }
    modint &operator-=(const modint &a) {
        if ((val += MOD - a.val) >= MOD) val -= MOD;
        return *this;
    }
    modint &operator*=(const modint &a) {
        (val *= a.val) %= MOD;
        return *this;
    }
    modint &operator/=(const modint &a) { return *this *= a.inv(); }
    modint operator+() const { return *this; }
    modint operator-() const { return modint(-val); }
    friend bool operator==(const modint &a, const modint &b) { return a.val == b.val; }
    friend bool operator!=(const modint &a, const modint &b) { return rel_ops::operator!=(a, b); }
    friend modint operator+(const modint &a, const modint &b) { return modint(a) += b; }
    friend modint operator-(const modint &a, const modint &b) { return modint(a) -= b; }
    friend modint operator*(const modint &a, const modint &b) { return modint(a) *= b; }
    friend modint operator/(const modint &a, const modint &b) { return modint(a) /= b; }
    friend istream &operator>>(istream &is, modint &a) {
        ll val;
        is >> val;
        a = modint(val);
        return is;
    }
    friend ostream &operator<<(ostream &os, const modint &a) { return os << a.val; }
};
template <typename F> ll bisect(ll ok, ll ng, F f) {
    while (abs(ok - ng) > 1) {
        ll mid = (ok + ng) / 2;
        (f(mid) ? ok : ng) = mid;
    }
    return ok;
}
template <typename mint> struct combination {
    vector<mint> fact, finv, inv;
    combination(int n) : fact(n + 1), finv(n + 1), inv(n + 1) {
        fact[0] = fact[1] = finv[0] = finv[1] = inv[1] = 1;
        for (int i : rep(2, n + 1)) {
            fact[i] = fact[i - 1] * i;
            inv[i] = -inv[mint::mod() % i] * (mint::mod() / i);
            finv[i] = finv[i - 1] * inv[i];
        }
    }
    mint P(int n, int r) { return r < 0 || n < r ? 0 : (fact[n] * finv[n - r]); }
    mint C(int n, int r) { return P(n, r) * finv[r]; }
    mint H(int n, int r) { return C(n + r - 1, r); }
    mint catalan(int n) { return C(2 * n, n) / (n + 1); }
};

template <typename S> struct segtree {
    using V = typename S::val_t;
    int n, size;
    vector<V> val;
    segtree(int n) : segtree(vector(n, S::e())) {}
    segtree(const vector<V> &src) : n(src.size()) {
        for (size = 1; size < n; size <<= 1) {}
        val.resize(size << 1);
        copy(all(src), val.begin() + size);
        for (int i : per(1, size)) val[i] = S::op(val[i << 1 | 0], val[i << 1 | 1]);
    }
    void set(int i, const V &a) {
        val[i += size] = a;
        while (i >>= 1) val[i] = S::op(val[i << 1 | 0], val[i << 1 | 1]);
    }
    V get(int i) const { return val[i + size]; }
    V prod(int l, int r) const {
        V a = S::e(), b = S::e();
        for (l += size, r += size; l < r; l >>= 1, r >>= 1) {
            if (l & 1) a = S::op(a, val[l++]);
            if (r & 1) b = S::op(val[--r], b);
        }
        return S::op(a, b);
    }
    template <typename F> int max_right(int l, F f) const {
        if (l == n) return n;
        V a = S::e();
        l += size;
        do {
            while (~l & 1) l >>= 1;
            if (!f(S::op(a, val[l]))) {
                while (l < size) {
                    l = l << 1;
                    if (f(S::op(a, val[l]))) a = S::op(a, val[l++]);
                }
                return l - size;
            }
            a = S::op(a, val[l++]);
        } while ((l & -l) != l);
        return n;
    }
    template <typename F> int min_left(int r, F f) const {
        if (r == 0) return 0;
        V a = S::e();
        r += size;
        do {
            r--;
            while (r > 1 && r & 1) r >>= 1;
            if (!f(S::op(val[r], a))) {
                while (r < size) {
                    r = r << 1 | 1;
                    if (f(S::op(val[r], a))) a = S::op(val[r--], a);
                }
                return r + 1 - size;
            }
            a = S::op(val[r], a);
        } while ((r & -r) != r);
        return 0;
    }
};

struct max_monoid {
    using val_t = ll;
    static val_t op(val_t a, val_t b) { return max(a, b); }
    static val_t e() { return LLONG_MIN; }
};

template <typename T> struct fenwick_tree {
    vector<T> data;
    fenwick_tree(int n) : data(n + 1, T()) {}
    void add(int i, const T &x) {
        for (++i; i < (int)data.size(); i += i & -i) data[i] += x;
    }
    T sum(int i) const {
        T ret = T();
        for (; i > 0; i -= i & -i) ret += data[i];
        return ret;
    }
    T sum(int l, int r) const { return sum(r) - sum(l); }
};

template <typename T> struct fenwick_tree_range {
    fenwick_tree<T> ft;
    fenwick_tree_range(int n) : ft(n) {}
    void add(int l, int r, const T &x) { ft.add(l, x), ft.add(r, -x); }
    T get(int i) const { return ft.sum(i + 1); }
};

int main() {
    ll n, m;
    cin >> n >> m;
    vll a(n), b(n), c(n);
    segtree<max_monoid> right(m);
    fenwick_tree_range<ll> def(m);
    for (ll i : rep(n)) {
        cin >> a[i] >> b[i] >> c[i], --b[i];
        right.set(b[i], max(right.get(b[i]), c[i]));
        def.add(b[i], c[i], a[i]);
    }
    vll atk(m);
    ll q;
    cin >> q;
    vll d(q), e(q);
    for (ll i : rep(q)) {
        cin >> d[i] >> e[i], --e[i];
        atk[e[i]] += d[i];
    }
    ll ans = 0;
    for (ll i : rep(m)) {
        ll add = max(0ll, atk[i] - def.get(i));
        ll r = right.prod(0, i + 1);
        if (add > 0 && r <= i) {
            cout << -1 << endl;
            return 0;
        }
        ans += add;
        def.add(i, r, add);
    }
    cout << ans << endl;
}
