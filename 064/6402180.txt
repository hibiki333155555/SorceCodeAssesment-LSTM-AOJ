#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define all(A) A.begin(),A.end()
using vll = vector<ll>;
#define rep(i, n) for (long long i = 0; i < (long long)(n); i++)

struct Point {
    ll x, y;
    ll A;
    bool operator <(const Point& p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
};

double cross(const Point& O, const Point& A, const Point& B)
{
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

vector<Point> convex_hull(vector<Point> P)
{
    size_t n = P.size(), k = 0;
    if (n <= 3) return P;
    vector<Point> H(2 * n);

    // Sort points lexicographically
    sort(P.begin(), P.end());

    // Build lower hull
    for (size_t i = 0; i < n; ++i) {
        while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) <= 0) k--;
        H[k++] = P[i];
    }

    // Build upper hull
    for (size_t i = n - 1, t = k + 1; i > 0; --i) {
        while (k >= t && cross(H[k - 2], H[k - 1], P[i - 1]) <= 0) k--;
        H[k++] = P[i - 1];
    }

    H.resize(k - 1);
    return H;

}




int main() {
    ll N;
    cin >> N;
    vll A(N);
    rep(i, N)cin >> A[i];
    long double pi = atan2(0, -1);
    vector<Point> P(N);
    rep(i, N) {
        ll X, Y;
        cin >> X >> Y;
        P[i].x = X;
        P[i].y = Y;
        P[i].A = A[i];
    }

    rep(i, N) {
        ll an = 0;
        vector<tuple<long double, ll, ll>> Q;
        vector<Point> CP(N);
        rep(j, N) {
            CP[j].x = (P[j].x - P[i].x) * P[j].A;
            CP[j].y = (P[j].y - P[i].y) * P[j].A;
        }

        auto H = convex_hull(CP);
        ll HN = H.size();
        rep(j, HN) {
            if (H[j].x == H[j].y && H[j].y == 0)continue;
            long double th = atan2(H[j].y, H[j].x);
            Q.push_back(make_tuple(th, H[j].x, H[j].y));

        }
        sort(all(Q));
        ll QN = Q.size();
        rep(i, QN) {
            Q.push_back(make_tuple(get<0>(Q[i]) + 2.0 * pi, get<1>(Q[i]), get<2>(Q[i])));
        }
        
        ll L = 1;
        rep(R, QN) {
            L = max(L, R + 1);
            //ll S = -1e18;
            ll S = abs(get<1>(Q[R]) * get<2>(Q[L]) - get<2>(Q[R]) * get<1>(Q[L]));
            ll NS = abs(get<1>(Q[R]) * get<2>(Q[L + 1]) - get<2>(Q[R]) * get<1>(Q[L + 1]));
            if (get<0>(Q[L + 1]) - get<0>(Q[R]) > pi) {
                an = max(an, S);
                continue;
            }

            while (S < NS) {
                L++;
                //if (L == HN - 1)L++;
                S = abs(get<1>(Q[R]) * get<2>(Q[L]) - get<2>(Q[R]) * get<1>(Q[L]));
                NS = abs(get<1>(Q[R]) * get<2>(Q[L + 1]) - get<2>(Q[R]) * get<1>(Q[L + 1]));
                if (get<0>(Q[L+1]) - get<0>(Q[R]) > pi)break;
            }
            an = max(an, S);
        }
        cout << an * A[i] << endl;


    }
}

