import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
// const long mod = 1_000_000_000 + 7;
const long mod = 998_244_353L;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

int N;
int[][] dp;
int[] ws;

void update (int l, int r) {
  if (dp[l][r] >= 0)
    return;
  if (r <= l + 1) {
    dp[l][r] = 0;
    return;
  }
  if (r == l + 2) {
    if (abs(ws[l] - ws[l + 1]) <= 1)
      dp[l][r] = 2;
    else
      dp[l][r] = 0;
    return;
  }

  update(l + 1, r - 1);
  if (dp[l + 1][r - 1] == (r - l - 2) && abs(ws[l] - ws[r - 1]) <= 1) {
    chmax(dp[l][r], dp[l + 1][r - 1] + 2);
  }
  foreach (i; l + 1 .. r) {
    update(l, i);
    update(i, r);
    chmax(dp[l][r], dp[l][i] + dp[i][r]);
  }

  return;
}

void main () {
  while (true) {
    N = readln.chomp.to!int;
    if (N == 0)
      break;
    ws = readln.chomp.split.map!(to!int).array;

    dp = new int[][](N + 1, N + 1);
    foreach (i; 0 .. N + 1)
      foreach (j; 0 .. N + 1)
        dp[i][j] = -1;

    update(0, N);
    int ret = dp[0][N];
    writeln(ret);

  }
}

