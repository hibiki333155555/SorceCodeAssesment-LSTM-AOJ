#ifdef LOGX
#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
using namespace std;
//#include <atcoder/all>
//using namespace atcoder;

/*---------macro---------*/
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rep2(i, s, n) for (int i = s; i < (int)(n); i++)
#define unless(x) if(!(x))
#define until(x) while(!(x))
#define ALL(a) a.begin(),a.end()
#define RALL(a) a.rbegin(),a.rend()
#define mybit(i,j) (((i)>>(j))&1)

/*---------type/const---------*/
constexpr int big=1000000007;
//constexpr int big=998244353;
constexpr double EPS=1e-8; //適宜変える
typedef long long ll;
typedef unsigned long long ull;
typedef std::string::const_iterator state; //構文解析
constexpr int dx[4]={1,0,-1,0};
constexpr int dy[4]={0,1,0,-1};
constexpr char newl='\n';
struct{
    constexpr operator int(){return -int(1e9)-10;}
    constexpr operator ll(){return -ll(1e18)-10;}
}neginf;
struct{
    constexpr operator int(){return int(1e9)+10;}
    constexpr operator ll(){return ll(1e18)+10;}
    constexpr auto operator -(){return neginf;}
}inf;

/*---------debug---------*/
#ifdef LOGX
#include <template/debug.hpp>
#else
#define dbg(...) ;
#define dbgnewl ;
#define prt(x) ;
#define _prt(x) ;
#endif

/*---------function---------*/
template<typename T> T max(const std::vector<T> &a){T ans=a[0];for(T elem:a){ans=max(ans,elem);}return ans;}
template<typename T> T min(const std::vector<T> &a){T ans=a[0];for(T elem:a){ans=min(ans,elem);}return ans;}
template<typename T,typename U> bool chmin(T &a,const U b){if(a>b){a=b;return true;}return false;}
template<typename T,typename U> bool chmax(T &a,const U b){if(a<b){a=b;return true;}return false;}
bool valid(int i,int j,int h,int w){return (i>=0 && j>=0 && i<h && j<w);}
template<class T,class U>T expm(T x,U y,const ll mod=big){T res=1;while(y){if(y&1)(res*=x)%=mod;(x*=x)%=mod;y>>=1;}return res;}
template<class T,class U>T exp(T x,U y){T res=1;while(y){if(y&1)res*=x;x*=x;y>>=1;}return res;}


template<int mod>
struct Fp{
    long long x;
    constexpr Fp(const long long _x=0)noexcept:x((_x%mod+mod)%mod){}
    constexpr Fp operator-()const noexcept{
        return x ? mod-x:0;
    }
    friend constexpr Fp<mod>& operator+=(Fp<mod> &l,const Fp<mod> r)noexcept{
        l.x+=r.x;
        if(l.x>=mod)l.x-=mod;
        return l;
    }
    friend constexpr Fp<mod>& operator-=(Fp<mod> &l,const Fp<mod> r)noexcept{
        l.x-=r.x;
        if(l.x<0)l.x+=mod;
        return l;
    }
    //modが十分小さい場合
    friend constexpr Fp<mod>& operator*=(Fp<mod> &l,const Fp<mod> r)noexcept{
        l.x=l.x*r.x %mod;
        return l;
    }
    //modが巨大な場合
    /*
    friend constexpr Fp<mod> prod(Fp<mod> l,long long r)noexcept{
        if(r==0)return 0;
        Fp<mod> res=prod(l+=l,r>>1);
        if(r&1)res+=l;
        return res;
    }
    friend constexpr Fp<mod>& operator*=(Fp<mod> &l,const Fp<mod> r)noexcept{
        return l=prod(l,r.x);
    }
    */
    
    friend constexpr Fp<mod>& operator/=(Fp<mod> &l,const Fp<mod> r)noexcept{
        long long a=r.x,b=mod,u=1,v=0;
        while(b){
            long long t=a/b;
            a-=t*b;std::swap(a,b);
            u-=t*v;std::swap(u,v);
        }
        l.x=l.x*u%mod;
        if(l.x<0)l.x+=mod;
        return l;
    }
    friend constexpr Fp<mod> operator+(Fp<mod> l,const Fp<mod> r){
        return l+=r;
    }
    friend constexpr Fp<mod> operator-(Fp<mod> l,const Fp<mod> r){
        return l-=r;
    }
    friend constexpr Fp<mod> operator*(Fp<mod> l,const Fp<mod> r){
        return l*=r;
    }
    friend constexpr Fp<mod> operator/(Fp <mod> l,const Fp<mod> r){
        return l/=r;
    }
    #ifdef LOGX
    friend constexpr bool operator==(const Fp<mod> l,const Fp<mod> r){
        return l.x==r.x;
    }
    friend constexpr bool operator!=(const Fp<mod> l,const Fp<mod> r){
        return l.x!=r.x;
    }
    #endif
    friend constexpr std::ostream& operator<<(std::ostream &os,const Fp<mod> &r)noexcept{
        return os << r.x;
    }
    friend constexpr std::istream& operator>>(std::istream &is,Fp<mod> &r)noexcept{
        long long t=0;is >> t;
        r.x=(Fp<mod>(t)).x;
        return is;
    }
};
 
namespace mint_ch{
    //const int mod=1000000007;
    const int mod=998244353;
    using mint=Fp<mod>;
 
    //#include<atcoder/modint>;
    //using mint=atcoder::modint1000000007;
    //using mint=atcoder::modint998244353;
    
    int sz=1;
    std::vector<mint> fac={1},facinv={1};
}
mint_ch::mint com(int a,int b){
    if(a<b || b<0 || a<0)return 0;
    if(mint_ch::sz<=a){
        mint_ch::fac.resize(a+1);
        mint_ch::facinv.resize(a+1);
        for(int i=mint_ch::sz;i<=a;i++){
            mint_ch::fac[i]=mint_ch::fac[i-1]*i;
            mint_ch::facinv[i]=mint_ch::facinv[i-1]/i;
        }
        mint_ch::sz=a+1;
    }
    return mint_ch::fac[a]*mint_ch::facinv[b]*mint_ch::facinv[a-b];
}
using namespace mint_ch;
//fac[i]=i!
//facinv[i]*fac[i]=1 (modP)
//fac[n]*facinv[n-r]*facinv[r]

template<typename T>
struct BIT_1pt{
    int n;
    std::vector<T> v;
    constexpr BIT_1pt(const int _):n(_),v(_+1,0){}
private:
    //[0,i].
    constexpr T sum_sub(int i){
        T res=0;
        i++;
        for(;i>0;i-=(i&-i))res+=v[i];
        return res;
    }
public:
    //iに加算.
    constexpr void add(int i,const T x){
        i++;
        for(;i<=n;i+=(i&-i))v[i]+=x;
    }
    //[l,r).
    constexpr T sum(const int l,const int r){
        return sum_sub(r-1)-sum_sub(l-1);
    }
    //sum>=wなるindex.条件:a[i]>=0.
    constexpr int lower_bound(T w){
        if(w<=0)return 0;
        int x=0,r=1;//x:1_idxで今見てる箇所の一つ左
        while(r<n)r<<=1;
        for(int len=r;len>0;len>>=1){
            if(x+len<=n && v[x+len]<w){
                w-=v[x+len];
                x+=len;
            }
        }
        return x;
    }
};


template<typename T>
struct BIT{
    int n;
    std::vector<T> v[2];
    constexpr BIT(const int _):n(_){
        v[0].assign(n+1,T(0));
        v[1].assign(n+1,T(0));
    }
private:
    //[0,i].
    constexpr T sum_sub(int i,const int p){
        T res=0;
        i++;
        for(;i>0;i-=(i&-i))res+=v[p][i];
        return res;
    }
    constexpr void add_sub(int i,const int p,const T x){
        i++;
        for(;i<=n;i+=(i&-i))v[p][i]+=x;
    }
public:
    constexpr void add(const int l,const int r,const T x){
        add_sub(l,0,x);
        add_sub(r,0,-x);
        add_sub(l,1,-l*x);
        add_sub(r,1,r*x);
    }
    //[l,r).
    constexpr T sum(const int l,const int r){
        return (sum_sub(r-1,0)*r+sum_sub(r-1,1))-(sum_sub(l-1,0)*l+sum_sub(l-1,1));
    }
};


int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout << std::fixed << std::setprecision(10);
/*------------------------------------*/
    
    com(2000,2000);
    int n,m;
    cin >> n >> m;
    vector<int> a(m);
    rep(i,m)cin >> a[i];
    vector<BIT<mint>> dp(m+1,BIT<mint>(n+1));
    dp[0].add(0,1,1);
    rep(j,m)rep(i,n+1){
        //dp[i][j]から
        dp[j+1].add(i,min(i+a[j]+1,n+1),dp[j].sum(i,i+1));
    }
    cout << dp.back().sum(n,n+1)*fac[n] << newl;
}
