#include <bitset>
#include <iostream>

// #include "library/util/static_bitset.hpp"

#include <vector>

namespace suisen {
    template <typename T>
    struct XorBase {
        XorBase() = default;
        XorBase(const std::vector<T> &a) : XorBase() {
            for (const auto &v : a) add(v);
        }

        bool add(T v) {
            for (const auto &e : _basis) if (T w = e ^ v; w < v) v = std::move(w);
            return v ? (_basis.push_back(v), true) : false;
        }

        XorBase<T> intersection(const XorBase<T> &rhs) const {
            std::vector<std::pair<T, T>> basis;
            for (const T &e : _basis) basis.emplace_back(e, e);
            XorBase res;
            for (T e : rhs._basis) {
                T s;
                if constexpr (std::is_integral_v<T>) s = 0;
                
                for (const auto &[v, t] : basis) if (T w = e ^ v; w < e) e = std::move(w), s ^= t;
                if (e) {
                    basis.emplace_back(e, s);
                } else {
                    res._basis.push_back(s);
                }
            }
            return res;
        }

        int dim() const {
            return _basis.size();
        }

        const std::vector<T>& get_basis() const {
            return _basis;
        }
    private:
        std::vector<T> _basis;
    };
} // namespace suisen

using suisen::XorBase;
// using suisen::static_bitset;

// constexpr int L = 60;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<int> len(n);
    for (auto &l : len) std::cin >> l;

    std::vector<std::vector<uint64_t>> dp(1 << n);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < len[i]; ++j) {
            uint64_t v;
            std::cin >> v;
            for (uint64_t e : dp[1 << i]) {
                if (uint64_t w = e ^ v; w < v) v = w;
            }
            if (v) dp[1 << i].push_back(v);
        }
    }

    auto intersection = [](std::vector<uint64_t> x, std::vector<uint64_t> y) {
        std::vector<std::pair<uint64_t, uint64_t>> basis;
        for (uint64_t e : x) basis.emplace_back(e, e);
        std::vector<uint64_t> res;
        for (uint64_t e : y) {
            uint64_t s = 0;
            for (const auto &[v, t] : basis) if (uint64_t w = e ^ v; w < e) e = std::move(w), s ^= t;
            if (e) {
                basis.emplace_back(e, s);
            } else {
                res.push_back(s);
            }
        }
        return res;
    };

    __uint128_t ans = 0;

    for (int s = 1; s < 1 << n; ++s) {
        int c = __builtin_popcount(s);
        if (c > 1) {
            int t = s & -s;
            dp[s] = intersection(dp[s ^ t], dp[t]);
        } 
        if (c & 1) {
            ans += uint64_t(1) << dp[s].size();
        } else {
            ans -= uint64_t(1) << dp[s].size();
        }
    }

    std::cout << uint64_t(ans) << std::endl;

    return 0;
}


