#pragma region Template
#pragma region Basic
// 設定
#include <bits/stdc++.h>
using namespace std;
#ifdef _DEBUG
#define PRE_COMMAND          \
    cin.rdbuf(in.rdbuf());   \
    cout.rdbuf(out.rdbuf()); \
    cout << fixed << setprecision(15);
#else
#define PRE_COMMAND                    \
    cout << fixed << setprecision(15); \
    ios::sync_with_stdio(false);       \
    cin.tie(0);
#endif
// よく使う型
using ll = long long;
using vi = vector<int>;
using vl = vector<ll>;
using vvi = vector<vector<int>>;
using vvl = vector<vector<ll>>;
// 多重vector用
template <typename T> struct arg_type;
template <typename T, typename U> struct arg_type<T(U)> { typedef U type; };
#define VTYPE(T) vector<arg_type<void(T)>::type>
#define VEC1(T, v, ...) VTYPE(T) v(__VA_ARGS__)
#define VEC2(T, v, s, ...) vector<VTYPE(T)> v(s, VTYPE(T)(__VA_ARGS__))
#define VEC3(T, v, s, t, ...) \
    vector<vector<VTYPE(T)>> v(s, vector<VTYPE(T)>(t, VTYPE(T)(__VA_ARGS__)))
// priority_queue用
template <class T> using PRIQ = priority_queue<T, vector<T>, greater<T>>;
template <class T> using PRIQR = priority_queue<T>;
// マクロ
#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)
#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; ++i)
#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; --i)
#define FORR(t, a) for (auto t : a)
#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい
#define MT(...) make_tuple(__VA_ARGS__)
#define MP(x, y) make_pair(x, y)
#define SZ(x) ((int)(x).size())
#define UNUSED_VARIABLE(x) ((void)(&x))  // 使わない引数の警告を消す
// 定数
const double EPS = 1e-10, PI = acos(-1.0);
const int IINF = 1010101010;
const long long LINF = 1010101010101010101;
// 関数
template <class T> auto MAX(T& seq) { return *max_element(ALL(seq)); }
template <class T> auto MIN(T& seq) { return *min_element(ALL(seq)); }
template <class T> auto SUM(T& seq) {
    return accumulate(++ALL(seq), *seq.begin());
}
template <class T> void REV(T& seq) { reverse(ALL(seq)); }
template <class T> void SORT(T& seq) { sort(ALL(seq)); }
template <class T, class S> void SORT(T& seq, S ordr) { sort(ALL(seq), ordr); }
template <class T> void SORTR(vector<T>& seq) { sort(ALL(seq), greater<T>()); }
template <class T, class S> void MMINS(multimap<T, S>& a, T b, S c) {
    a.insert(make_pair(b, c));
}
template <class T> inline bool CHMAX(T& l, T r) {
    return ((l < r) ? (l = r, true) : (false));
}
template <class T> inline bool CHMIN(T& l, T r) {
    return ((l > r) ? (l = r, true) : (false));
}
template <class T> ll pow(ll n, T k) {
    ll now = 1;
    while (k) {
        if (k & 1) now *= n;
        n *= n;
        k >>= 1;
    }
    return now;
}
template <class T> ll pow(int n, T k) { return pow((ll)n, k); }
template <class T> int pow(int n_0, T k, int mod) {
    if (n_0 >= mod) n_0 %= mod;
    if (n_0 < 0) n_0 += mod;
    unsigned long long n = (unsigned long long)n_0, now = 1;
    while (k) {
        if (k & 1) now = (now * n) % mod;
        n = (n * n) % mod;
        k >>= 1;
    }
    return (int)now;
}
void yn(bool flag) { cout << (flag ? "YES" : "NO") << '\n'; }
// 数値の文字列を数値の配列に変換
vector<int> STR_2_VI(string& s) {
    vector<int> ret(ALL(s));
    for_each(ALL(ret), [](int& i) { return i -= 48; });
    return ret;
}
#pragma endregion Basic
#pragma region overload
// 演算子のオーバーロード
// 要素の追加
template <class T> void operator+=(vector<T>& l, T r) { l.push_back(r); }
template <class T> void operator+=(set<T>& l, T r) { l.insert(r); }
template <class T> void operator+=(multiset<T>& l, T r) { l.insert(r); }
template <class T> void operator>>=(deque<T>& l, T r) { l.push_back(r); }
template <class T> void operator<<=(deque<T>& l, T r) { l.push_front(r); }
template <class T, class V, class C>
void operator+=(priority_queue<T, V, C>& l, T r) {
    l.push(r);
}
// 配列の追加
template <class T, class S> void operator+=(vector<T>& l, S& r) {
    copy(ALL(r), back_inserter(l));
}
template <class T, class S> void operator+=(set<T>& l, S& r) {
    copy(ALL(r), inserter(l, l.end()));
}
template <class T, class S> void operator+=(multiset<T>& l, S& r) {
    copy(ALL(r), inserter(l, l.end()));
}
// 配列の結合
template <class T, class S> vector<T> operator+(vector<T> l, S& r) {
    return copy(ALL(r), back_inserter(l));
}
template <class T, class S> set<T> operator+(set<T> l, S& r) {
    return copy(ALL(r), inserter(l, l.end()));
}
template <class T, class S> multiset<T> operator+(multiset<T> l, S& r) {
    return copy(ALL(r), inserter(l, l.end()));
}
// 要素の削除
template <class T> void operator-=(set<T>& l, T r) { l.erase(r); }
template <class T> void operator-=(multiset<T>& l, T r) {
    auto it = l.find(r);
    if (it != l.end()) l.erase(it);
}
template <class T, class S> void operator-=(map<T, S>& l, T r) { l.erase(r); }
// 要素のpop
template <class T> T operator--(vector<T>& l) {
    T ret = l.back();
    l.pop_back();
    return ret;
}
template <class T> T operator--(deque<T>& l) {
    T ret = l.front();
    l.pop_front();
    return ret;
}
template <class T> T operator--(deque<T>& l, int r) {
    T ret = l.back();
    l.pop_back();
    return ret;
}
template <class T, class V, class C> T operator--(priority_queue<T, V, C>& l) {
    T ret = l.top();
    l.pop();
    return ret;
}
// 文字列の繰り返し
string operator*(string& l, size_t r) {
    string ret = l;
    for (size_t i = 1; i < r; i++) { ret += l; }
    return ret;
}
#pragma endregion overload
#pragma region Input
// INPUT関数
template <class T1, class T2>
istream& operator>>(istream& is, pair<T1, T2>& t) {
    return cin >> get<0>(t) >> get<1>(t);
}
template <class T1> istream& operator>>(istream& is, tuple<T1>& t) {
    return cin >> get<0>(t);
}
template <class T1, class T2>
istream& operator>>(istream& is, tuple<T1, T2>& t) {
    return cin >> get<0>(t) >> get<1>(t);
}
template <class T1, class T2, class T3>
istream& operator>>(istream& is, tuple<T1, T2, T3>& t) {
    return cin >> get<0>(t) >> get<1>(t) >> get<2>(t);
}
template <class T1, class T2, class T3, class T4>
istream& operator>>(istream& is, tuple<T1, T2, T3, T4>& t) {
    return cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);
}
template <class T1, class T2, class T3, class T4, class T5>
istream& operator>>(istream& is, tuple<T1, T2, T3, T4, T5>& t) {
    return cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);
}
template <class T> istream& operator>>(istream& is, vector<T>& vec) {
    for (T& x : vec) is >> x;
    return is;
}
template <class Head> void INPUT(Head& head) { cin >> head; }
template <class Head, class... Tail> void INPUT(Head& head, Tail&... tail) {
    INPUT(head);
    INPUT((tail)...);
}
#pragma endregion Input
#pragma region Print
// PRINT関数
template <class T1, class T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& t) {
    return cout << get<0>(t) << " " << get<1>(t);
}
template <class T1> ostream& operator<<(ostream& os, const tuple<T1>& t) {
    return cout << get<0>(t);
}
template <class T1, class T2>
ostream& operator<<(ostream& os, const tuple<T1, T2>& t) {
    return cout << get<0>(t) << " " << get<1>(t);
}
template <class T1, class T2, class T3>
ostream& operator<<(ostream& os, const tuple<T1, T2, T3>& t) {
    return cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t);
}
template <class T1, class T2, class T3, class T4>
ostream& operator<<(ostream& os, const tuple<T1, T2, T3, T4>& t) {
    return cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << " "
                << get<3>(t);
}
template <class T1, class T2, class T3, class T4, class T5>
ostream& operator<<(ostream& os, const tuple<T1, T2, T3, T4, T5>& t) {
    return cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << " "
                << get<3>(t) << " " << get<4>(t);
}
template <class T> ostream& COUT_MAIN(ostream& os, const T& v) {
    if (v.empty()) return os;
    typename T::const_iterator ii = v.begin();
    os << *ii++;
    for (; ii != v.end(); ++ii) os << " " << *ii;
    return os;
}
template <class T> ostream& operator<<(ostream& os, const vector<T>& v) {
    return COUT_MAIN(os, v);
}
template <class T> ostream& operator<<(ostream& os, const set<T>& v) {
    return COUT_MAIN(os, v);
}
template <class T> ostream& operator<<(ostream& os, const multiset<T>& v) {
    return COUT_MAIN(os, v);
}
template <class T> ostream& operator<<(ostream& os, const deque<T>& v) {
    return COUT_MAIN(os, v);
}
template <class T, class S>
ostream& operator<<(ostream& os, const map<T, S>& m) {
    for (typename map<T, S>::const_iterator ii = m.begin(); ii != m.end();) {
        os << tuple<T, S>(*(ii++));
        if (ii != m.end()) os << '\n';
    }
    return os;
}
template <class T, class S>
ostream& operator<<(ostream& os, const multimap<T, S>& m) {
    for (typename multimap<T, S>::const_iterator ii = m.begin();
         ii != m.end();) {
        os << tuple<T, S>(*(ii++));
        if (ii != m.end()) os << '\n';
    }
    return os;
}
template <class T, class V, class C>
ostream& operator<<(ostream& os, priority_queue<T, V, C> v) {
    if (v.empty()) return os;
    os << v.top();
    v.pop();
    while (!v.empty()) {
        os << " " << v.top();
        v.pop();
    }
    return os;
}
void PRINT() {}
template <class Head> void PRINT(Head&& head) { cout << head << '\n'; }
template <class Head, class... Tail> void PRINT(Head&& head, Tail&&... tail) {
    cout << head << ' ';
    PRINT(forward<Tail>(tail)...);
}
#pragma endregion Print
#pragma endregion Template

// 無向グラフの場合はコメントアウトを解除する
vector<int> closed_parts(int& start, vector<set<int>>& g_set,
                         set<int>& visited) {
    vector<int> root(1, start);
    set<int> root_set({start});
    int r = 1, j, now, past;
    while (r) {
        now = root[r - 1];
        if (r == 1) {
            past = -1;
        } else {
            past = root[r - 2];
        }
        if (g_set[now].size()) {
            j = *g_set[now].begin();
            g_set[now].erase(j);
            // if (j == past) { continue; } // 無向グラフの場合は入れる
            if (root_set.count(j)) { return root; }
            now = j;
            root.push_back(j);
            root_set.insert(j);
            visited.insert(j);
            r++;
        } else {
            root_set.erase(now);
            now = past;
            root.pop_back();
            r--;
        }
    }
    return {};
}
vector<int> closed(vector<set<int>> g) {
    int n = (int)g.size();
    set<int> visited;
    for (int i = 0; i < n; i++) {
        if (visited.count(i)) { continue; }
        visited.insert(i);
        vector<int> ret = closed_parts(i, g, visited);
        if (ret.size() > 0) { return ret; }
    }
    return {};
}

// 入力：頂点数、根、グラフ
// 出力：最小コスト
template <class T> T ChuLiu(int n, int root, vector<vector<tuple<int, T>>> g) {
    int v;
    T w, ans = 0, ans2;
    while (true) {
        // 前処理
        ans2 = 0;
        vector<tuple<int, T>> g_rev(n, make_tuple(-1, 0));
        vector<set<int>> subgraph(n);
        map<tuple<int, int>, T> subgraph_map;
        // 逆辺グラフの準備
        for (int i = 0; i < n; i++) {
            if (g[i].size() == 0) { continue; }
            for (auto temp : g[i]) {
                tie(v, w) = temp;
                if (get<0>(g_rev[v]) == -1) {
                    g_rev[v] = make_tuple(i, w);
                } else {
                    if (w < get<1>(g_rev[v])) { g_rev[v] = make_tuple(i, w); }
                }
            }
        }
        // 部分グラフを作る
        for (int i = 0; i < n; i++) {
            tie(v, w) = g_rev[i];
            if (i == root) { continue; }
            if (v == -1) { continue; }
            subgraph[v].insert(i);
            subgraph_map[make_tuple(v, i)] = w;
            ans2 += w;
        }
        // 閉路があるかどうか、なかったら終了
        vector<int> loop = closed(subgraph);
        int loop_size = (int)loop.size();
        if (loop_size == 0) { return ans + ans2; }
        // loopの辺の重みを記録
        map<int, T> loop_weight;
        loop_weight[loop[0]] =
            subgraph_map[make_tuple(loop[loop_size - 1], loop[0])];
        ans += loop_weight[loop[0]];
        for (int i = 0; i < loop_size - 1; i++) {
            loop_weight[loop[i + 1]] =
                subgraph_map[make_tuple(loop[i], loop[i + 1])];
            ans += loop_weight[loop[i + 1]];
        }
        // 縮約する
        g.push_back({});
        for (int i = 0; i < n; i++) {
            if (loop_weight.count(i)) {
                for (auto temp : g[i]) {
                    tie(v, w) = temp;
                    if (loop_weight.count(v)) { continue; }
                    g[n].push_back(make_tuple(v, w));
                }
                g[i] = {};
            } else {
                vector<tuple<int, T>> temp_v;
                for (auto temp : g[i]) {
                    tie(v, w) = temp;
                    if (loop_weight.count(v)) {
                        temp_v.push_back(make_tuple(n, w - loop_weight[v]));
                        continue;
                    }
                    temp_v.push_back(make_tuple(v, w));
                }
                g[i] = temp_v;
            }
        }
        n++;
    }
    return 0;
}

int main() {
    PRE_COMMAND
    int n, m, r;
    INPUT(n, m, r);
    vector<vector<tuple<int, ll>>> g(n);
    REP(i, m) {
        int a, b;
        ll c;
        INPUT(a, b, c);
        g[a].push_back(make_tuple(b, c));
    }
    PRINT(ChuLiu(n, r, g));
}

