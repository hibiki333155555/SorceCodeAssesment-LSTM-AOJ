#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

class SCC{
private:
    vector<vector<int>> G;
    vector<vector<int>> rG;
    vector<bool> visited;
    vector<int> vs;
    vector<int> cmp;

    void dfs1(int v){
        visited[v] = true;
        for(auto &nex: G[v]){
            if(visited[nex]) continue;
            dfs1(nex);
        }
        vs.emplace_back(v);
    }

    void dfs2(int v, int k){
        visited[v] = true;
        cmp[v] = k;
        for(auto &nex: rG[v]){
            if(visited[nex]) continue;
            dfs2(nex, k);
        }
    }
public:
    SCC(int n):
    G(vector<vector<int>>(n)), rG(vector<vector<int>>(n)),
    visited(vector<bool>(n, false)), cmp(vector<int>(n)) {}

    void add_edge(int from, int to){
        G[from].emplace_back(to);
        rG[to].emplace_back(from);
    }

    vector<vector<int>> scc(){
        for(int i = 0; i < G.size(); i++){
            if(!visited[i]) dfs1(i);
        }

        fill(visited.begin(), visited.end(), false);
        reverse(vs.begin(), vs.end());
        int k = 0;
        for(auto &it: vs){
            if(visited[it]) continue;
            dfs2(it, k);
            k++;
        }

        vector<vector<int>> res(k);
        for(int i = 0; i < G.size(); i++) res[cmp[i]].emplace_back(i);
        return res;
    }
};

struct Solver{
    const int n;
    vector<double> p;
    SCC G;
    vector<vector<int>> G0;
    Solver(int n): n(n), p(vector<double>(n)), G(SCC(n)),
    G0(vector<vector<int>>(n)) {
        for(int i = 0; i < n; i++){
            cin >> p[i];
            int m; cin >> m;
            for(int j = 0; j < m; j++){
                int a; cin >> a;
                G.add_edge(i, a-1);
                G0[i].emplace_back(a-1);
            }
        }
    }

    void solve(){
        auto scc = G.scc();
        vector<vector<int>> G2(scc.size());
        vector<int> in(scc.size(), 0);
        vector<double> p2(scc.size());
        for(int i = 0; i < scc.size(); i++){
            p2[i] = 1.0;
            for(auto &it: scc[i]) p2[i] *= p[it];
            p2[i] = 1.0-p2[i];

            for(auto &it: scc[i]){
                for(auto &nex: G0[it]){
                    for(int j = 0; j < scc.size(); j++){
                        if(i == j) continue;
                        for(int k = 0; k < scc[j].size(); k++){
                            if(nex == scc[j][k]){
                                in[j]++;
                            }
                        }
                    }
                }
            }
        }

        double ans = 1.0;
        for(int i = 0; i < scc.size(); i++){
            if(in[i] == 0) ans *= p2[i];
        }
        cout << fixed << setprecision(10) << ans << '\n';
    }
};

int main(){
    while(true){
        int n; cin >> n;
        if(!n) break;
        Solver sol(n);
        sol.solve();
    }
    return 0;
}
