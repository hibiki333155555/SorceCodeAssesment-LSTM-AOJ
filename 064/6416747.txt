# /usr/bin/python3
# -*- coding: utf-8 -*-
from bisect import bisect_left, bisect_right
from queue import LifoQueue as Stack
from math import sqrt, floor, ceil, log2, log10, pi, sin, cos, atan
from fractions import gcd
from itertools import permutations, combinations
from collections import Counter, deque
from operator import itemgetter
from functools import cmp_to_key, reduce
from bisect import bisect_left
import sys
sys.setrecursionlimit(10**7) #再帰関数の呼び出し制限

# INF=1001001001
# INF = 100010001000100010001
INF = float('INF')
__MOD__=(10**9)+7
yn = 'YNeos'
judge = False
cnt = 0
ans = None


def lcm(a, b):
    return (a*b) // gcd(a,b)

def intinput():
    return int(input())

def mulinputs():
    return map(int,input().split())

def lineinputs(func=intinput):
    datas = []
    while True:
        try:
            datas.append(func())
        except EOFError:
            break
    return datas

def bindex(a,x):
    i = bisect_left(a,x)
    if i != len(a) and a[i] == x:
        return i
    return None


class UnionFind:
    def __init__(self, n):
        self.r = [-1]*(n+1)

    def root(self, x):
        if self.r[x] < 0:
            return x
        self.r[x] = self.root(self.r[x])
        return self.r[x]

    def unite(self, x, y):
        x = self.root(x)
        y = self.root(y)
        if x == y:
            return False
        if self.r[x] > self.r[y]:
            x,y = y,x
        self.r[x] += self.r[y]
        self.r[y] = x
        return True

    def size(self, x):
        return -1 * self.r[self.root(x)]


class ModInt():
    def __init__(self, x):
        self.__x = (x % __MOD__)
    def __add__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x + other.__x)%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x + other.__x)%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")
    def __radd__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x + self.__x)%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x + self.__x)%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __sub__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x - other.__x)%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x - other.__x)%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")
    def __rsub__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x - self.__x)%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x - self.__x)%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __mul__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x * other.__x)%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x * other.__x)%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")
    def __rmul__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x * self.__x)%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x * self.__x)%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __truediv__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((self.__x * other.__modinv())%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((self.__x * other.__modinv())%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")
    def __rtruediv__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__((other.__x * self.__modinv())%__MOD__))
        elif type(other) == ModInt:
            return self.__class__((other.__x * self.__modinv())%__MOD__)
        else:
            raise Exception("Not Int or Not ModInt")

    def __pow__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__(pow(self.__x, other.__x, __MOD__)))
        elif type(other) == ModInt:
            return self.__class__(pow(self.__x, other.__x, __MOD__))
        else:
            raise Exception("Not Int or Not ModInt")
    def __rpow__(self, other):
        if type(other) == int:
            other = self.__class__(other)
            return int(self.__class__(pow(other.__x, self.__x, __MOD__)))
        elif type(other) == ModInt:
            return self.__class__(pow(other.__x, self.__x, __MOD__))
        else:
            raise Exception("Not Int or Not ModInt")

    def __modinv(self, m=__MOD__):
        a = self.__x
        if a == 0:
            raise ZeroDivisionError()
        if gcd(a, m) != 1:
            raise Exception("%sの逆数は求まりません。" % a)
        b, u, v = m, 1, 0
        while b != 0:
            t = a//b;
            a -= t*b
            a, b = b, a
            u -= t * v
            u, v = v, u
        u %= m
        if u < 0:
            u += m
        return u
    def __int__(self):
        return self.__x
    def __str__(self):
        return str(self.__x)


# https://qiita.com/drken/items/3beb679e54266f20ab63#4-2-%E9%AB%98%E9%80%9F%E7%B4%84%E6%95%B0%E5%88%97%E6%8C%99
class Eratosthenes:
    def __init__(self, n):
        is_prime = [True] * (n + 1)
        minfactor = [-1] * (n + 1)

        is_prime[1] = False
        minfactor[1] = 1

        for p in range(2, n + 1):

            if not is_prime[p]:
                continue;

            minfactor[p] = p

            for q in range(p * 2, n + 1, p):
                is_prime[q] = False

                if minfactor[q] == -1:
                    minfactor[q] = p

        self.is_prime = is_prime
        self.minfactor = minfactor
        self.max = n

    # 素因数を返却
    def factorize(self, n):
        res = []
        while n > 1:
            p = self.minfactor[n]
            exp = 0

            while self.minfactor[n] == p:
                n = int(n / p)
                exp += 1
            res.append((p, exp))
        return res

    # 約数を返却
    def divisors(self, n):
        res = [1]

        pf = self.factorize(n)

        for p in pf:
            s = len(res)

            for i in range(s):
                v = 1
                for j in range(p[1]):
                    v *= p[0]
                    res.append(res[i] * v)
        return res




if __name__ == '__main__':
    Vn, En, r = mulinputs()
    # indatas = []
    # adjancency list
    adj_list = [None] * Vn
    for _ in range(En):
        vs, ve, d = mulinputs()
        # indatas.append((vs, ve, d))
        if not adj_list[vs]:
            adj_list[vs] = []
        adj_list[vs].append((ve, d))
    v_cost_map = [INF] * Vn
    v_cost_map[r] = 0

    q = deque()
    q.append(r)
    visited = [False] * Vn
    while q:
        current = q.popleft()
        if visited[current]:
            continue
        visited[current] = True
        if not adj_list[current]:
            continue
        for v, e in adj_list[current]:
            if v_cost_map[current] + e >= v_cost_map[v]:
                continue
            v_cost_map[v] = v_cost_map[current] + e

        min_cost = INF
        next_v = None
        for v in range(Vn):
            if visited[v]:
                continue
            if min_cost > v_cost_map[v]:
                min_cost = v_cost_map[v]
                next_v = v
        if next_v:
            q.append(next_v)

    for cost in v_cost_map:
        if cost < INF:
            print(cost)
        else:
            print('INF')


                

