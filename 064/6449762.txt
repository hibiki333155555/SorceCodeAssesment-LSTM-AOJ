#include "bits/stdc++.h"
#include <random>
#include <chrono>
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define SZ(x) ((lint)(x).size())
#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;++i)
#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;--i)
#define REP(i, n) FOR(i,0,n)
#define IREP(i, n) IFOR(i,0,n)
#define endk '\n'
using namespace std; typedef unsigned long long _ulong; typedef long long int lint; typedef long double ld; typedef pair<lint, lint> plint; typedef pair<ld, ld> pld;
struct fast_ios { fast_ios() { cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10); }; } fast_ios_;
template<class T> auto add = [](T a, T b) -> T { return a + b; };
template<class T> auto mul = [](T a, T b) -> T { return a * b; };
template<class T> auto f_max = [](T a, T b) -> T { return max(a, b); };
template<class T> auto f_min = [](T a, T b) -> T { return min(a, b); };
template<class T> using V = vector<T>;
using Vl = V<lint>; using VVl = V<Vl>; using VVVl = V<V<Vl>>;
template< typename T > ostream& operator<<(ostream& os, const vector< T >& v) {
	for (int i = 0; i < (int)v.size(); i++) os << v[i] << (i + 1 != v.size() ? " " : "");
	return os;
}
template< typename T >istream& operator>>(istream& is, vector< T >& v) {
	for (T& in : v) is >> in;
	return is;
}
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
template <class T>
T div_floor(T a, T b) {
	if (b < 0) a *= -1, b *= -1;
	return a >= 0 ? a / b : (a + 1) / b - 1;
}
template <class T>
T div_ceil(T a, T b) {
	if (b < 0) a *= -1, b *= -1;
	return a > 0 ? (a - 1) / b + 1 : a / b;
}
template <class F> struct rec {
	F f;
	rec(F&& f_) : f(std::forward<F>(f_)) {}
	template <class... Args> auto operator()(Args &&... args) const {
		return f(*this, std::forward<Args>(args)...);
	}
};
lint gcd(lint a, lint b) { if (b == 0) return a; else return gcd(b, a % b); }
lint digit(lint a) { return (lint)log10(a); }
lint e_dist(plint a, plint b) { return abs(a.first - b.first) * abs(a.first - b.first) + abs(a.second - b.second) * abs(a.second - b.second); }
lint m_dist(plint a, plint b) { return abs(a.first - b.first) + abs(a.second - b.second); }
bool check_overflow(lint a, lint b, lint limit) { if (b == 0) return false; return a >= limit / b; } // a * b > c => true
void Worshall_Floyd(VVl& g) { REP(k, SZ(g)) REP(i, SZ(g)) REP(j, SZ(g)) chmin(g[i][j], g[i][k] + g[k][j]); }
const lint MOD1000000007 = 1000000007, MOD998244353 = 998244353, INF = 2e18;
lint dx[8] = { 0, -1, 0, 1, 1, -1, 1, -1 }, dy[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };
bool YN(bool flag) { cout << (flag ? "YES" : "NO") << endk; return flag; } bool yn(bool flag) { cout << (flag ? "Yes" : "No") << endk; return flag; }
struct Edge {
	lint from, to;
	lint cost, t;
	Edge() {

	}
	Edge(lint u, lint v, lint c, lint _t) {
		cost = c;
		from = u;
		to = v;
		t = _t;
	}
	bool operator<(const Edge& e) const {
		return cost < e.cost;
	}
};
struct WeightedEdge {
	lint to;
	lint cost;
	WeightedEdge(lint v, lint c) {
		to = v;
		cost = c;
	}
	bool operator<(const WeightedEdge& e) const {
		return cost < e.cost;
	}
};
using WeightedGraph = V<V<WeightedEdge>>;
typedef pair<lint, plint> tlint;
typedef pair<ld, ld> pld;
typedef pair<plint, plint> qlint;
typedef pair<lint, string> valstr;
typedef pair<Vl, lint> valv;

struct ExtendBinaryIndexedTree {
public:
    ExtendBinaryIndexedTree(int _n) { init(_n); }
    //半開区間[l, r)
    void add(int l, int r, lint x) {
        add_sub(0, l, -x * (l - 1));
        add_sub(0, r, x * (r - 1));
        add_sub(1, l, x);
        add_sub(1, r, -x);
    }
    //区間[0, i)
    lint sum(int i) {
        return sum_sub(0, i) + sum_sub(1, i) * i;
    }

    void show() {
        for (int i = 0; i < n - 1; i++) {
            cout << sum(i + 1) - sum(i) << " ";
        }
        cout << endk;
    }
private:
    int n;
    vector<lint> bit[2];
    void init(int _n) {
        n = _n + 1;
        bit[0].assign(n, 0);
        bit[1].assign(n, 0);
    }
    void add_sub(int p, int i, lint x) {
        for (int idx = i; idx < n; idx += (idx & -idx)) {
            bit[p][idx] += x;
        }
    }
    lint sum_sub(int p, int i) {
        lint s = 0;
        for (int idx = i; idx > 0; idx -= (idx & -idx)) {
            s += bit[p][idx];
        }
        return s;
    }
};



int main() {
	lint N, M, Q;
	cin >> N >> M;

	ExtendBinaryIndexedTree bit(M + 2);

	VVl seg(M);
	REP(i, N) {
		lint A, B, C;
		cin >> A >> B >> C; B--;
		bit.add(B + 1, C + 1, -A);
		seg[B].push_back(C);
	}
	cin >> Q;
	REP(i, Q) {
		lint D, E;
		cin >> D >> E;
		bit.add(E, E + 1, D);
	}

	lint maxv = 0, ans = 0;
	REP(i, M) {
		for (lint v : seg[i]) chmax(maxv, v);
		lint b = bit.sum(i + 1) - bit.sum(i);
		if (b <= 0) continue;
		
		if (i >= maxv) {
			cout << -1 << endk;
			return 0;
		}
		ans += b;
		bit.add(i + 1, maxv + 1, -b);
	}
	cout << ans << endk;
}
