#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
namespace bigint {
    // Multiple-Precision Integer
    class MPI {
        private:
            std::vector<std::int32_t> integer;
            bool is_negative;

            void to_integer(const std::string& s) noexcept {
                std::string i = s;
                if(s.front() == '-') {
                    this->is_negative = true;
                    i = s.substr(1);
                }
                else {
                    this->is_negative = false;
                }
                std::reverse(i.begin(), i.end());
                for(const auto& c: i) this->integer.push_back(static_cast<std::int32_t>(c - '0'));
                return;
            }
        // Constructor
        public:
            MPI() noexcept : integer({0}), is_negative(false){}
            MPI(const std::string& v) noexcept { to_integer(v); }
            MPI(const char*&  v) noexcept { to_integer(v); }
            MPI(const char*&& v) noexcept { to_integer(v); }
            template <typename T> MPI(const T& v) noexcept { to_integer(std::to_string(v)); }
            MPI(const MPI& v) noexcept : integer(v.integer), is_negative(v.is_negative){}

        // Operator
        private:
        // Functions
            void fix(std::vector<std::int32_t>& integer) {
                if(integer.back() < 0) integer.back() *= -1;
                while(integer.back() >= 10) {
                    auto k = integer.back() / 10;
                    integer.back() -= k * 10;
                    integer.push_back(k);
                }
                while(integer.size() > 1 && integer.back() == 0)
                    integer.pop_back();
                return;
            }
            void carry(std::vector<std::int32_t>& integer) {
                while(integer.back() < 0 && integer.size() > 1) {
                    auto k = std::abs(integer.back());
                    integer.pop_back();
                    integer.back() -= k * 10;
                }
                for(std::size_t i = 0; i < integer.size() - 1; ++i) {
                    // [2, 22, 3, 4] -> [2, 22 - 20, 3 + 2, 4] -> [2, 2, 5, 4]
                    if(integer.at(i) >= 10) {
                        auto k = integer.at(i) / 10;
                        integer.at(i) -= k * 10;
                        integer.at(i + 1) += k;
                    }
                    // [2, -22, 5, 4] -> [2, -22 + 30, 5 - 3, 4] -> [2, 8, 2, 4]
                    // [2, -10, 5, 4] -> [2, -10 + 10, 5 - 1, 4] -> [2, 0, 4, 4]
                    if(integer.at(i) < 0) {
                        auto k = (-integer.at(i) - 1) / 10 + 1;
                        integer.at(i) += k * 10;
                        integer.at(i + 1) -= k;
                    }
                }
                return fix(integer);
            }
        public:
            static MPI abs(const MPI& r) noexcept { MPI tmp = r; tmp.is_negative = false; return tmp; }
            static std::string to_string(const MPI& r) noexcept {
                std::string tmp;
                for(std::size_t i = r.integer.size(); i > 0; --i) tmp += static_cast<char>(r.integer.at(i - 1) + '0');
                return tmp;
            }
            static std::int64_t to_ll(const MPI& r) noexcept { return std::stoll(MPI::to_string(r)); }
            static std::int32_t to_int(const MPI& r) noexcept { return std::stoi(MPI::to_string(r)); }


            MPI operator= (const MPI& r) noexcept { this->integer = r.integer, this->is_negative = r.is_negative; return (*this); }
            MPI operator+=(const MPI& r_) noexcept {
                MPI r = r_;
                bool sign = this->is_negative;
                if(this->is_negative != r.is_negative) {
                    if(this->is_negative) {
                        sign = MPI::abs(*this) > MPI::abs(r) ? true : false;
                        for(auto& i: this->integer) i *= -1;
                    }
                    else {
                        sign = MPI::abs(*this) > MPI::abs(r) ? false : true;
                        for(auto& i: r.integer) i *= -1;
                    }
                }
                std::vector<std::int32_t> new_integer(std::max(this->integer.size(), r.integer.size()));
                for(std::size_t i = 0; i < new_integer.size(); ++i)
                    new_integer.at(i) = (i < this->integer.size() ? this->integer.at(i) : 0) + (i < r.integer.size() ? r.integer.at(i) : 0);
                carry(new_integer);
                this->integer = new_integer;
                this->is_negative = ((this->integer.size() == 1) && (this->integer.front() == 0)) ? false : sign;
                return (*this);
            }
            MPI operator-=(const MPI& r) noexcept { (*this) += -r; return (*this); }
        
        private:
            // unary
            friend MPI operator-(const MPI&) noexcept;
            // I/O
            friend std::ostream& operator<<(std::ostream&, const MPI&) noexcept;
            friend std::istream& operator>>(std::istream&, MPI&) noexcept;
            // Comparison
            friend bool operator==(const MPI&, const MPI&) noexcept;
            friend bool operator> (const MPI&, const MPI&) noexcept;

    };
    MPI operator+(const MPI& r) noexcept { return r; }
    MPI operator-(const MPI& r) noexcept { MPI tmp = r; tmp.is_negative = !tmp.is_negative; return tmp; }
    MPI operator+(const MPI& lhs, const MPI& rhs) noexcept { MPI tmp = lhs; return tmp += rhs; }
    MPI operator-(const MPI& lhs, const MPI& rhs) noexcept { MPI tmp = lhs; return tmp -= rhs; }
    
    std::ostream& operator<<(std::ostream& out, const MPI& mpi) noexcept {
        if(mpi.is_negative) out << "-";
        for(std::size_t i = mpi.integer.size(); i > 0; --i)
            out << mpi.integer.at(i - 1);
        return out;
    }
    std::istream& operator>>(std::istream& cin, MPI& mpi) noexcept {
        std::string s; cin >> s;
        mpi = MPI(s);
        return cin;
    }
    bool operator==(const MPI& lhs, const MPI& rhs) noexcept {
        if(lhs.integer.size() != rhs.integer.size()) return false;
        for(std::size_t i = 0; i < lhs.integer.size(); ++i)
            if(lhs.integer.at(i) != rhs.integer.at(i)) return false;
        return (lhs.is_negative == rhs.is_negative);
    }
    bool operator!=(const MPI& lhs, const MPI& rhs) noexcept { return !(lhs == rhs); }
    bool operator> (const MPI& lhs, const MPI& rhs) noexcept {
        if(lhs.is_negative != rhs.is_negative) return !lhs.is_negative;
        if(lhs.integer.size() == rhs.integer.size()) {
            for(std::size_t i = lhs.integer.size(); i > 0; --i)
                if(lhs.integer.at(i - 1) != rhs.integer.at(i - 1)) return lhs.is_negative ? (lhs.integer.at(i - 1) < rhs.integer.at(i - 1)) : (lhs.integer.at(i - 1) > rhs.integer.at(i - 1));
        }
        else
            return lhs.is_negative ? (lhs.integer.size() < rhs.integer.size()) : (lhs.integer.size() > rhs.integer.size());
        return false;
    }
    bool operator>=(const MPI& lhs, const MPI& rhs) noexcept { return (lhs > rhs || lhs == rhs); }
    bool operator< (const MPI& lhs, const MPI& rhs) noexcept { return !(lhs >= rhs); }
    bool operator<=(const MPI& lhs, const MPI& rhs) noexcept { return !(lhs > rhs); }
}
int main() {
    bigint::MPI a, b;
    std::cin >> a >> b;
    std::cout << a + b << std::endl;
    return 0;
}
