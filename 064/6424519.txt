#include <bits/stdc++.h>
using namespace std;
const int maxN=10010;//点数
const int maxM=30010;//边数
struct Edge{
	int to,nxt;
}edge[maxM];
int head[maxN],tot;
int Low[maxN],DFN[maxN],Stack[maxN],Belong[maxN];
//Belong表示属于哪个连通分量
//Low表示u或u的子树能够追溯到的最早的栈中节点的次序号 
int Index,top;
int scc;//强连通分量个数
bool Instack[maxN]; 
void addedge(int u,int v){
	edge[tot].to=v;
	edge[tot].nxt=head[u];
	head[u]=tot++;
}
void init(){
	tot=0;
	memset(head,-1,sizeof(head));
}
void Tarjan(int u){
	int v;
	Low[u]=DFN[u]=++Index;
	Stack[top++]=u;
	Instack[u]=true;
	for(int i=head[u];i!=-1;i=edge[i].nxt){
		v=edge[i].to;
		if(!DFN[v]){
			Tarjan(v);
			if(Low[u]>Low[v]) Low[u]=Low[v];
		}
		else if(Instack[v]&&Low[u]>DFN[v]){
			Low[u]=DFN[v];
		}
	}
	if(Low[u]==DFN[u]){
		scc++;
		do{
			v=Stack[--top];
			Instack[v]=false;
			Belong[v]=scc;
		}while(v!=u);
	}
}

int main(){
	init();
	memset(DFN,0,sizeof(DFN));
	memset(Instack,false,sizeof(Instack));
	Index=scc=top=0;
	int V,E;
	scanf("%d %d",&V,&E);
	int u,v;
	for(int i=0;i<E;i++){
		scanf("%d %d",&u,&v);
		addedge(u,v);
	}
	for(int i=0;i<V;i++){
		if(!DFN[i]) Tarjan(i);
	}
	int Q;//Q个询问 
	scanf("%d",&Q);
	while(Q--){
		scanf("%d %d",&u,&v);
		if(Belong[u]==Belong[v]) printf("1\n");
		else printf("0\n");
	}
	return 0;
} 
