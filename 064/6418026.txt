#include <stdio.h>
#include <stdlib.h>

struct node {
    struct node * pre;
    struct node ** next;
    int value;
    int depth;
};

typedef struct node Node;

void construct(Node * now, int * A, int ele[], int n){
    int eleNew[n - now->depth];
    for (int i = 0, j = 0; i < n - now->depth + 1; i++){
        if (now->value != ele[i]){
            eleNew[j] = ele[i];
            j++;
        }
    }
    for (int i = 0; i < n - now->depth; i++){
        now->next[i] = (Node *)malloc(sizeof(Node));
        now->next[i]->pre = now;
        now->next[i]->depth = now->depth+1;
        now->next[i]->next = (Node **)malloc(sizeof(Node *) * (n - now->next[i]->depth));
        now->next[i]->value = eleNew[i];
        
        construct(now->next[i], A, eleNew, n);
    }
    
    return;
}

Node * Search(Node * now, int * A, int n){
    if (now->depth == n) return now;
    
    for (int i = 0; i < n - now->depth; i++){
        if (now->next[i]->value == A[now->depth]){
            return Search(now->next[i], A, n);
        }
    }
    
    return NULL;
}

Node * printPre(Node * target, int n){
    if (target->pre != NULL) {
        Node * nextPointer;
        int j = 0;
        for (int i = 0; i < n - target->pre->depth; i++){
            if (target->pre->next[i]->value == target->value) {
                if (i != 0){
                    j = i - 1;
                    break;
                } else {
                    return printPre(target->pre, n);
                }
            }
        }
        nextPointer = target->pre->next[j];
        while (nextPointer->depth != n) {
            nextPointer = nextPointer->next[n - nextPointer->depth - 1];
        }
        
        return nextPointer;
    }
    
    return NULL;
}

Node * printNext(Node * target, int n){
    if (target->pre != NULL) {
        Node * nextPointer;
        int j = 0;
        for (int i = 0; i < n - target->pre->depth; i++){
            if (target->pre->next[i]->value == target->value) {
                if (i != (n - target->pre->depth - 1)){
                    j = i + 1;
                    break;
                } else {
                    return printNext(target->pre, n);
                }
            }
        }
        nextPointer = target->pre->next[j];
        while(nextPointer->depth != n){
            nextPointer = nextPointer->next[0];
        }
        
        return nextPointer;
    }
    
    return NULL;
}

void printPreMax (int exeption, int ele[], int n){
    if (n == 1) return;
    int eleNew[n-1];
    for (int i = 0, j = 0; i < n; i++){
        if (exeption != ele[i]){
            eleNew[j] = ele[i];
            j++;
        }
    }
    printf(" %d", eleNew[0]);
    printPreMax (eleNew[0], eleNew, n-1);
    return;
}

void printNextMax (int exeption, int ele[], int n){
    if (n == 1) return;
    int eleNew[n-1];
    for (int i = 0, j = 0; i < n; i++){
        if (exeption != ele[i]){
            eleNew[j] = ele[i];
            j++;
        }
    }
    printf(" %d", eleNew[0]);
    printPreMax (eleNew[0], eleNew, n-1);
    return;
}

int main(void){
    // Your code here!
    int n, escape;
    scanf(" %d", &n);
    int * A = (int *)malloc(sizeof(int) * n);
    int * ele = (int *)malloc(sizeof(int) * n);
    int * tmp = (int *)malloc(sizeof(int) * n);
    int * swap = (int *)malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++){
        scanf(" %d", &A[i]);
        ele[i] = i+1;
        tmp[i] = n - i;
    }
    
    Node * root = (Node * )malloc(sizeof(Node)); // root is pointer
    root->pre = NULL;
    root->depth = 1;
    root->next = (Node **)malloc(sizeof(Node *) * (n - root->depth));
    root->value = A[0];
    
    construct(root, A, ele, n);
    
    Node * target = Search(root, A, n);
    
    Node * nextPointer = printPre(target, n);
    if (nextPointer == NULL){
        // ひとつ前の先頭の数字から始まる最大の順列を表示
        if (A[0] != 1) {
            printf("%d", A[0]-1);
            printPreMax(A[0]-1, tmp, n);
            printf("\n");
        }
        
    } else {
        int com_i = n-1;
        while(nextPointer != NULL){
            swap[com_i] = nextPointer->value;
            com_i--;
            nextPointer = nextPointer->pre;
        }
        for (int i = 0; i < n; i++){
            printf("%d", swap[i]);
            if (i != n-1) printf(" ");
        }
        printf("\n");
    }
    
    for (int i = 0; i < n; i++){ // print original
        printf("%d", A[i]);
        if (i != n-1) printf(" ");
    }
    printf("\n");
    
    nextPointer = printNext(target, n);
    if (nextPointer == NULL){
        // ひとつ後の先頭の数字から始まる最小の順列を表示
        if (A[0] == n) {
            printf("%d", A[0]+1);
            printNextMax(A[0]+1, ele, n);
            printf("\n");
        }
        
    } else {
        int com_i = n-1;
        while(nextPointer != NULL){
            swap[com_i] = nextPointer->value;
            com_i--;
            nextPointer = nextPointer->pre;
        }
        for (int i = 0; i < n; i++){
            printf("%d", swap[i]);
            if (i != n-1) printf(" ");
        }
        printf("\n");
        // サーチして、表示する
    }
    
    return 0;
}

// 愚直にやる方法だと、9桁の整数×8×2の計算量がかかる可能性
// 9+1層の木構造からたどるやり方だと、メモリはかかるが、成功しそう
// 9+1層の木構造の簡略化->与えられた先頭の数字から始まる9層の木構造+前後の最大・最小の順列

