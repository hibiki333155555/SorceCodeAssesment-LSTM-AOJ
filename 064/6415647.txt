#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <numeric>
#include <algorithm>
#include <queue>
#include <string>
#include <random>
#include <array>
#include <climits>
#include <map>
#include <cassert>
#include <stack>
#include <iomanip>
#include <cfloat>
#include <bitset>
#include <fstream>
#include <chrono>

constexpr int MOD = 1'000'000'007;

using Puppets = std::vector<std::pair<int, int>>;
long long int solve(const Puppets& puppets) {
	const int n = puppets.size(); 
	std::vector<std::vector<std::vector<int>>> memo(n, std::vector<std::vector<int>>(n + 1, std::vector<int>(n + 1, 0))), version(n, std::vector<std::vector<int>>(n + 1, std::vector<int>(n + 1, -1)));
	memo[0][0][0] = 1;
	std::vector<std::tuple<int, int, int>> prev, next; prev.emplace_back(0, 0, 0);
	int p = 0;
	auto update = [n, &p, &memo, &next, &version](const int edge_count, const int head, const int toe, long long int count) mutable {
		if (edge_count < 0 || n <= edge_count) return;
		if (head <= 0 || toe < 0 || n <= toe) return;
		count %= MOD;
		if (count == 0LL) return;
		memo[edge_count][head][toe] = (memo[edge_count][head][toe] + count) % MOD;
		if (version[edge_count][head][toe] != p) {
			next.emplace_back(edge_count, head, toe);
			version[edge_count][head][toe] = p;
		}
	};
	for (; p < n; ++p) {
		const auto [min, max] = puppets[p];
		next.clear();
		std::sort(prev.rbegin(), prev.rend(), [](const auto a, const auto b) {
			if (std::get<0>(a) != std::get<0>(b)) return std::get<0>(a) < std::get<0>(b);
			if (std::get<1>(a) != std::get<1>(b)) return std::get<1>(a) < std::get<1>(b);
			return std::get<2>(a) < std::get<2>(b);
			});
		prev.erase(std::unique(prev.begin(), prev.end()), prev.end());
		for (const auto [edge_count, head, toe] : prev) {
			const long long int count = memo[edge_count][head][toe];
			if (min <= 0 && 0 <= max) {
				update(edge_count, head + 1, toe, count);
				update(edge_count + 1, head, toe - 1, count * toe);
			}
			if (min <= 1 && 1 <= max) {
				update(edge_count, head + 1, toe + 1, count * 2);
				update(edge_count + 1, head, toe, count * 2 * toe);
			}
			if (min <= 2 && 2 <= max) {
				update(edge_count, head + 1, toe + 2, count);
				update(edge_count + 1, head, toe + 1, count * 2 * head);
				update(edge_count + 1, head, toe + 1, count * toe);
				update(edge_count + 2, head - 1, toe, count * 2 * (head - 1) * toe);
			}
			memo[edge_count][head][toe] = 0;
		}
		std::swap(next, prev);
	}
	const auto result = memo[n - 1][1][0];
	return result;
}

int main() {
	int n; std::cin >> n;
	Puppets puppets(n);
	for (auto& [min, max] : puppets) {
		std::cin >> min >> max;
	}
	const auto result = solve(puppets);
	std::cout << result << '\n';
}
