// #pragma GCC target("avx2")
#pragma GCC optimize("O3")
// #pragma GCC optimize("unroll-loops")
#include<bits/stdc++.h>
using namespace std;


using P = pair<int, int>;

int dd[] = { 0, 1, 0, -1 };

int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);
    int h, w, n, si, sj, gi, gj;
    cin >> h >> w >> n >> si >> sj >> gi >> gj;
    --si;
    --sj;
    --gi;
    --gj;
    vector<vector<int>> a(h, vector<int>(w));
    priority_queue<pair<int, P>> pq;
    for (int i = 0; i < n; ++i) {
        int pi, pj, k;
        cin >> pi >> pj >> k;
        --pi;
        --pj;
        a[pi][pj] = k + 1;
        pq.emplace(a[pi][pj], P(pi, pj));
    }
    while (!pq.empty()) {
        auto p = pq.top();
        pq.pop();
        int i = p.second.first;
        int j = p.second.second;
        if (p.first < a[i][j]) continue;
        for (int k = 0; k < 4; ++k) {
            int ti = i + dd[k];
            int tj = j + dd[k ^ 1];
            if (0 <= ti && ti < h && 0 <= tj && tj < w && a[ti][tj] < a[i][j] - 1) {
                a[ti][tj] = a[i][j] - 1;
                pq.emplace(a[ti][tj], P(ti, tj));
            }
        }
    }
    queue<P> q;
    vector<vector<bool>> vis(h, vector<bool>(w));
    assert(a[si][sj] == 0);
    vis[si][sj] = true;
    q.emplace(si, sj);
    while (!q.empty()) {
        auto p = q.front();
        q.pop();
        int i = p.first;
        int j = p.second;
        for (int k = 0; k < 4; ++k) {
            int ti = i + dd[k];
            int tj = j + dd[k ^ 1];
            if (0 <= ti && ti < h && 0 <= tj && tj < w && !vis[ti][tj] && a[ti][tj] == 0) {
                vis[ti][tj] = true;
                q.emplace(ti, tj);
            }
        }
    }
    cout << (vis[gi][gj] ? "Yes" : "No") << '\n';

    return 0;
}

