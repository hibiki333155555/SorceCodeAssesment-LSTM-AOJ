fn main() -> Result<(), Box<dyn std::error::Error>> {
    let sc = Scanner::new();
    let (v, e) = sc.read();
    let mut g = vec![vec![]; v];
    for _ in 0..e {
        let (s, t) = sc.read();
        g[s].push(t);
    }
    let scc = strong_connected_component(&g);
    let k = scc.len();
    let mut group = vec![0; v];
    for i in 0..k {
        for v in &scc[i] {
            group[*v] = i;
        }
    }
    let q = sc.read::<usize>();
    for _ in 0..q {
        let (u, v) = sc.read();
        if group[u] == group[v] {
            println!("{}", 1);
        } else {
            println!("{}", 0);
        }
    }
    Ok(())
}

fn strong_connected_component(g: &Vec<Vec<usize>>) -> Vec<Vec<usize>> {
    let n = g.len();
    let mut index_list: Vec<usize> = vec![0; n];
    let mut visited: Vec<bool> = vec![false; n];
    let mut id = 0;
    fn indexing(
        g: &Vec<Vec<usize>>,
        i: usize,
        visited: &mut Vec<bool>,
        id: &mut usize,
        index_list: &mut Vec<usize>,
    ) {
        visited[i] = true;
        for nex in &g[i] {
            if visited[*nex] {
                continue;
            }
            indexing(g, *nex, visited, id, index_list);
        }
        index_list[*id] = i;
        *id += 1;
    }
    fn generate_components(
        backward: &Vec<Vec<usize>>,
        i: usize,
        visited: &mut Vec<bool>,
        component: &mut Vec<usize>,
    ) {
        visited[i] = true;
        component.push(i);
        for nex in &backward[i] {
            if visited[*nex] {
                continue;
            }
            generate_components(backward, *nex, visited, component);
        }
    }
    for i in 0..n {
        if visited[i] {
            continue;
        }
        indexing(&g, i, &mut visited, &mut id, &mut index_list);
    }
    for i in 0..n {
        visited[i] = false;
    }
    let mut scc = vec![];
    let mut backward = vec![vec![]; n];
    for i in 0..n {
        for e in &g[i] {
            backward[*e].push(i);
        }
    }
    while let Some(i) = index_list.pop() {
        if visited[i] {
            continue;
        }
        let mut component = vec![];
        generate_components(&backward, i, &mut visited, &mut component);
        scc.push(component);
    }
    scc
}

type Chars = Vec<char>;

struct Scanner {
    handle: std::io::Stdin,
}

trait Scannable {
    fn from_scan(s: String) -> Self;
}

macro_rules! impl_Scannable_for_numeical {
    ($($t:ty)*) => {
        $(
            impl Scannable for $t  {
                fn from_scan(s: String) -> Self {
                    s.as_str().parse::<$t>().unwrap()
                }
            }
        )*
    };
}
impl_Scannable_for_numeical!(usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64);

macro_rules! impl_Scannable_for_numeical_vector {
    ($($t:ty)*) => {
        $(
            impl Scannable for Vec<$t> {
                fn from_scan(s: String) -> Self {
                    s.split_whitespace()
                        .map(|i| i.parse::<$t>().unwrap())
                        .collect()
                }
            }
        )*
    };
}
impl_Scannable_for_numeical_vector!(usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64);

impl Scannable for Chars {
    fn from_scan(s: String) -> Self {
        s.chars().collect()
    }
}

impl Scannable for Vec<String> {
    fn from_scan(s: String) -> Self {
        s.split_whitespace().map(|s| s.to_string()).collect()
    }
}

impl Scannable for (usize, usize) {
    fn from_scan(s: String) -> Self {
        let mut vals = s.split_whitespace().map(|s| s.parse::<usize>().unwrap());
        (vals.next().unwrap(), vals.next().unwrap())
    }
}

impl Scanner {
    fn new() -> Self {
        Scanner {
            handle: std::io::stdin(),
        }
    }
    fn read<T>(&self) -> T
    where
        T: Scannable,
    {
        let mut buf = String::new();
        self.handle.read_line(&mut buf).unwrap();
        <T as Scannable>::from_scan(
            buf.trim_end_matches('\n')
                .trim_end_matches('\r')
                .to_string(),
        )
    }
}

