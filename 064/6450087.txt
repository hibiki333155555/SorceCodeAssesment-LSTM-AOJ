#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define REPR(i, n) for (int i = n - 1; i >= 0; --i)
#define FOR(i, m, n) for (int i = m; i < n; ++i)
#define FORR(i, m, n) for (int i = m; i >= n; --i)
#define ALL(v) (v).begin(),(v).end()
#define ALLR(v) (v).rbegin(),(v).rend()
#define fi first
#define se second
#define PB push_back
#define EB emplace_back
using P = pair<ll, ll>;
template<typename T> using PQ = priority_queue<T>;
template<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;
template<typename T>void debug(const T &v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j]<<" \n"[j==w-1];}};
template<typename T>void debug(const T &v,ll n){for(ll i=0;i<n;i++)cout<<v[i]<<" \n"[i==n-1];};
template<typename T>void debug(const vector<T>&v){debug(v,v.size());}
template<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}
template<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<" ";st.pop();}cout<<endl;}
template<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<" ";st.pop();}cout<<endl;}
template<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<" ";st.pop_front();}cout<<endl;}
template<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<" ";st.pop();}cout<<endl;}
template<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<" ";st.pop();}cout<<endl;}
template<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<" ";cout<<endl;}
template<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<" ";cout<<endl;}
template<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<" ";cout<<endl;}
template<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<"["<<z.first<<"]="<<z.second<<",";cout<<endl;}
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
int popcount(ll x){return __builtin_popcountll(x);};
int poplow(ll x){return __builtin_ctzll(x);};
int pophigh(ll x){return 63 - __builtin_clzll(x);};
const ll INF=1LL<<60;
const int inf=(1<<30)-1;
// const int mod=1e9+7;
const int mod=998244353;
int dx[8]={1,0,-1,0,-1,-1,1,1};
int dy[8]={0,1,0,-1,-1,1,-1,1};

int main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    int n,m;cin >> n >> m;
    vector<vector<pair<ll,ll>>> e(n);
    REP(i,m){
        int a,b,c;cin >> a >> b >> c;
        a--,b--;
        e[a].PB({b,c});
    }
    vector<ll> mn(n,INF);
    QP<pair<ll,ll>> pq;
    mn[0]=1;
    pq.push({1,0});
    while(!pq.empty()){
        auto [u,v]=pq.top();pq.pop();
        if(u>mn[v]) continue;
        for(auto [x,y]:e[v]){
            if(chmin(mn[x],mn[v]/gcd(mn[v],y)*y)) pq.push({mn[x],x});
        }
    }
    if(mn[n-1]==INF){
        cout << "IMPOSSIBLE" << endl;
        return 0;
    }
    cout << mn[n-1] << " ";
    int d[]={2,4,8,3,9,5,7,11,13,17,19};
    vector<vector<bool>> mx(n,vector<bool>(1<<11));
    mx[0][0]=true;
    queue<pair<ll,ll>> q;
    q.push({0,0});
    while(!q.empty()){
        auto [u,v]=q.front();q.pop();
        // cerr << u << " " << v << endl;
        for(auto [x,y]:e[u]){
            int res=0;
            REP(i,11){
                if(y%d[i]==0) res+=1<<i;
            }
            if(!mx[x][v|res]){
                mx[x][v|res]=true;
                q.push({x,v|res});
            }
        }
    }
    ll ans=0;
    REP(i,1<<11){
        if(!mx[n-1][i]) continue;
        ll lc=1;
        REP(j,11) if(i&(1<<j)) lc=lc/gcd(lc,d[j])*d[j];
        // cerr << i << " " << lc << endl;
        chmax(ans,lc);
    }
    cout << ans << endl;
}
