#include "iostream"
using namespace std;
#define N 25
int n;
typedef struct node{
    int id;
    int parent,left,right;
    int degree;
    int sibling;
}node;
node T[N];
int H[N];
int D[N];
void setDepth(int i,int p_d){
    D[i] = p_d + 1;
    if (T[i].left!=-1&&T[i].left<n){
        setDepth(T[i].left,D[i]);
    }
    if (T[i].right!=-1&&T[i].right<n){
        setDepth(T[i].right,D[i]);
    }
}
int setHight(int i){
    if (i==-1)return -1;
    int l_h = setHight(T[i].left);
    int r_h = setHight(T[i].right);
    H[i] = l_h>r_h ? l_h+1:r_h+1;
    return H[i];
}
void print(){
    for (int i = 0; i < n; ++i) {
        cout<<"node "<<T[i].id<<": parent = "<<T[i].parent<<", sibling = "<<T[i].sibling<<", degree = "<<T[i].degree<<", depth = "<<D[i]<<", height = "<<H[i];
        if (T[i].parent == -1){
            cout<<", root";
        }else if (T[i].degree==0){
            cout<<", leaf";
        } else{
            cout<<", internal node";
        }
        cout<<endl;
    }
}
int main(){
    int id,l,r,root;
    cin>>n;
    for (int i = 0; i < n; ++i) {
        cin>>id>>l>>r;
        T[id].id = id;
        if (i==0){
            root = id;
            T[id].parent=-1,
            T[id].sibling=-1;
        }
        T[id].left = l;
        T[id].right = r;
        T[i].degree=0;
        if (l!=-1){
            T[id].degree++;
            T[l].parent = id;
            if (r!=-1){
                T[l].sibling = r;
            }
        }
        if (r!=-1){
            T[id].degree++;
            T[r].parent = id;
            if (l!=-1){
                T[r].sibling = l;
            }
        }
    }
    setDepth(root,-1);
    setHight(root);
    print();
    return 0;
}
