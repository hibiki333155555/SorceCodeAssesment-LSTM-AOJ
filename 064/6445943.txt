#include <iostream>
#include <complex>
#include <map>
#include <set>
#include <stack>
#include <vector>

using namespace std;

void f(vector<pair<int, int>>& R, const vector<pair<int, int>>& P)
{
	for (int i = 0, j = i + 1; j < (int) P.size(); i = j, j = i + 1) {
		double x = P[i].first, y = P[i].second, G = (P[j].second - y) / (P[j].first - x);
		for (int k = i + 2; k < (int) P.size(); ++k) {
			double g = (P[k].second - y) / (P[k].first - x);
			if (G <= g) continue;
			G = g;
			j = k;
		}
		R.push_back(P[j]);
	}
}

int main()
{
	int n, x, y;
	map<int, set<int>> XY;
	for (cin >> n >> x >> y; n > 0; --n, cin >> x >> y) XY[x].insert(y);
	vector<pair<int, int>> P, R;
	stack<pair<int, int>> S;
	for (const auto& [x, Y] : XY) {
		P.emplace_back(x, *Y.begin());
		S.emplace(x, *Y.rbegin());
	}
	R.push_back(P[0]);
	f(R, P);
	for (P.clear(); !S.empty(); S.pop()) P.push_back(S.top());
	if (R.back() != P[0]) {
		R.pop_back();
		auto x = P[0].first;
		for (auto y : XY[x]) R.emplace_back(x, y);
	}
	f(R, P);
	if (R.back() != R[0]) {
		R.pop_back();
		auto x = R[0].first;
		for (auto p = XY[x].crbegin(); p != XY[x].crend(); ++p) R.emplace_back(x, *p);
	}
	R.pop_back();
	cout << R.size() << endl;
	for (auto [x, y] : R) cout << x << ' ' << y << endl;
	return 0;
}

