import java.util.*;

public class Main{
    public static void main(String []args){
        Scanner in = new Scanner(System.in);

        int V = in.nextInt();
        int E = in.nextInt();
        int F = in.nextInt();

        MinCostFlow g = new MinCostFlow(V);

        for(int i = 0; i < E; i++){
            int u = in.nextInt();
            int v = in.nextInt();
            int c = in.nextInt();
            int d = in.nextInt();

            g.add(u, v, c, d);
        }

        System.out.println(g.minCostFlow(0, V - 1, F));

        in.close();
    }
}

class Edge{
    int to, cap, rev, cost;

    Edge(int to, int cap, int cost, int rev){
        this.to = to;
        this.cap = cap;
        this.rev = rev;
        this.cost = cost;
    }
}

class MinCostFlow{
    int n;
    ArrayList<ArrayList<Edge>> G = new ArrayList<ArrayList<Edge>>();

    int inf = (int)(1e9 + 7);

    MinCostFlow(int n){
        this.n = n;

        for(int i = 0; i < n; i++){
            G.add(new ArrayList<Edge>());
        }
    }

    public void add(int from, int to, int cap, int cost){
        G.get(from).add(new Edge(to, cap, cost, G.get(to).size()));
        G.get(to).add(new Edge(from, 0, -cost, G.get(from).size() - 1));
    }

    int minCostFlow(int s, int t, int f){
        int res = 0;
        int dist[] = new int[n];
        int prevv[] = new int[n];
        int preve[] = new int[n];

        while(f > 0){
            Arrays.fill(dist, inf);
            dist[s] = 0;

            PriorityQueue<int []> pq = new PriorityQueue<int []>((a, b) -> a[0] - b[0]);
            pq.add(new int[]{0, s});

            while(!pq.isEmpty()){
                int d = pq.peek()[0];
                int v = pq.poll()[1];

                if(dist[v] < d){
                    continue;
                }

                for(int i = 0; i < G.get(v).size(); i++){
                    Edge e = G.get(v).get(i);

                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){
                        dist[e.to] = dist[v] + e.cost;
                        prevv[e.to] = v;
                        preve[e.to] = i;

                        pq.add(new int[]{dist[e.to], e.to});
                    }
                }
            }

            if(dist[t] == inf){
                return -1;
            }

            int d = f;
            for(int v = t; v != s; v = prevv[v]){
                d = Math.min(d, G.get(prevv[v]).get(preve[v]).cap);
            }

            f -= d;
            res += d*dist[t];

            for(int v = t; v != s; v = prevv[v]){
                Edge e = G.get(prevv[v]).get(preve[v]);

                e.cap -= d;
                G.get(e.to).get(e.rev).cap += d;
            }
        }

        return res;
    }
}
