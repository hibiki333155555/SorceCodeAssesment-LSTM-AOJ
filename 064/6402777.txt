#![allow(unused_imports)]
use std::collections::HashMap;
use std::mem::swap;

// use im_rc::HashMap;
// use itertools::Itertools;
// use num_integer::Roots;
// use proconio::marker::{Chars, Usize1};
// use proconio::{fastout, input};

// fn osa_k(vl: &Vec<usize>) -> Vec<HashMap<usize, usize>> {
fn osa_k(vl: &Vec<usize>) -> Vec<Vec<(usize, usize)>> {
    if vl.is_empty() {
        return vec![];
    }
    let vmax = *vl.iter().max().unwrap();
    let mut min_primes = (0..vmax + 1).map(|i| i).collect::<Vec<_>>();
    for prime in 2..1000.min(vmax) {
        if min_primes[prime] != prime {
            continue; // not prime
        }
        let mut curr = prime;
        while curr <= vmax {
            min_primes[curr] = min_primes[curr].min(prime);
            curr += prime;
        }
    }
    vl.iter()
        .map(|&v| {
            let mut pf_cnt = HashMap::new();
            let mut curr = v;
            while curr > 1 {
                let min_p = min_primes[curr];
                *pf_cnt.entry(min_p).or_insert(0) += 1;
                curr /= min_p;
            }
            pf_cnt
                .iter()
                .map(|k| (*k.0 as usize, *k.1 as usize))
                .collect()
        })
        .collect()
}

struct Mo {
    cl: usize,
    cr: usize,
    cnts: Vec<usize>,
    vals: Vec<Vec<(usize, usize)>>,
    ng_cnt: usize,
}

impl Mo {
    // [0] change vals type (if necessary) !!!!!!
    pub fn new(vals: &Vec<Vec<(usize, usize)>>) -> Self {
        Mo {
            vals: vals.clone(),
            cl: 0,
            cr: 0,
            // [1] add info for ans !!!!!!!
            cnts: vec![0; 10e6 as usize - 10],
            ng_cnt: 0,
        }
    }

    // [2] impl this !!!!!!!
    // update info with self.vals[i]
    fn add(&mut self, i: usize) {
        for &(p, cnt) in &self.vals[i] {
            if self.cnts[p] % 3 == 0 {
                self.ng_cnt += 1;
            }
            self.cnts[p] += cnt;
            if self.cnts[p] % 3 == 0 {
                self.ng_cnt -= 1;
            }
        }
    }

    // [3] impl this !!!!!!!
    // update info without self.vals[i]
    fn delete(&mut self, i: usize) {
        for &(p, cnt) in &self.vals[i] {
            if self.cnts[p] % 3 == 0 {
                self.ng_cnt += 1;
            }
            self.cnts[p] -= cnt;
            if self.cnts[p] % 3 == 0 {
                self.ng_cnt -= 1;
            }
        }
    }

    fn process_query(&mut self, l: usize, r: usize) {
        while l < self.cl {
            self.cl -= 1;
            self.add(self.cl);
        }
        while self.cr < r {
            self.add(self.cr);
            self.cr += 1;
        }
        while self.cl < l {
            self.delete(self.cl);
            self.cl += 1;
        }
        while r < self.cr {
            self.cr -= 1;
            self.delete(self.cr);
        }
        self.cl = l;
        self.cr = r;
    }

    // [4] (if necessary) change ans vec type !!!!!!!!!!!!
    pub fn process_all(&mut self, queries: &Vec<(usize, usize)>) -> Vec<bool> {
        // let bucket_size = self.vals.len().sqrt() + 1;
        let bucket_size = 800;
        let mut buckets = vec![vec![]; bucket_size + 1];
        // let mut buckets_h = vec![];
        for (qi, &(l, r)) in queries.iter().enumerate() {
            buckets[l / bucket_size].push((l, r, qi));
            // buckets_h.push((l, r, qi));
        }
        //// for bucket in &mut buckets {
        for (i, bucket) in buckets.iter_mut().enumerate() {
            bucket.sort_by_key(|v| v.1);
            if i % 2 == 1 {
                bucket.reverse();
            }
        }

        // buckets_h.sort_by_key(|v| Mo::triangleorder(v.0, v.1));
        // dbg!(&buckets_h);

        // [5] init ans vec !!!!!!!!!!!!
        let mut ans = vec![false; queries.len()];

        // for &(l, r, qi) in &buckets_h {
        //     // dbg!(l, r);
        //     self.process_query(l, r);
        //     // [6] set ans !!!!!!!!!
        //     ans[qi] = self.ng_cnt == 0;
        // }

        for bucket in &buckets {
            for &(l, r, qi) in bucket {
                // if false {
                self.process_query(l, r);
                // }
                // [6] set ans !!!!!!!!!
                ans[qi] = self.ng_cnt == 0;
            }
        }
        // [7] return ans !!!!!!
        ans
        // vec![]
    }
}
macro_rules! input {
    (source = $s:expr, $($r:tt)*) => {
        let mut iter = $s.split_whitespace();
        let mut next = || { iter.next().unwrap() };
        input_inner!{next, $($r)*}
    };
    ($($r:tt)*) => {
        let stdin = std::io::stdin();
        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));
        let mut next = move || -> String{
            bytes
                .by_ref()
                .map(|r|r.unwrap() as char)
                .skip_while(|c|c.is_whitespace())
                .take_while(|c|!c.is_whitespace())
                .collect()
        };
        input_inner!{next, $($r)*}
    };
}

macro_rules! input_inner {
    ($next:expr) => {};
    ($next:expr, ) => {};

    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {
        let $var = read_value!($next, $t);
        input_inner!{$next $($r)*}
    };
}

macro_rules! read_value {
    ($next:expr, ( $($t:tt),* )) => {
        ( $(read_value!($next, $t)),* )
    };

    ($next:expr, [ $t:tt ; $len:expr ]) => {
        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()
    };

    ($next:expr, chars) => {
        read_value!($next, String).chars().collect::<Vec<char>>()
    };

    ($next:expr, usize1) => {
        read_value!($next, usize) - 1
    };

    ($next:expr, $t:ty) => {
        $next().parse::<$t>().expect("Parse error")
    };
}

// #[fastout]
fn main() {
    input! {
        n: usize, q: usize,
        al: [usize; n],
        ql: [(usize1,usize); q], // 0-indexed [left, right)
    }
    let pl = osa_k(&al);
    let mut mo = Mo::new(&pl);
    let ans = mo.process_all(&ql);
    // println!("{}", mo.move_cnt);
    // dbg!(mo.move_cnt);
    for &a in &ans {
        println!("{}", if a { "Yes" } else { "No" });
    }
}

