/*
考えたこと：
(1) 2の倍数同士はswapできない
(2) 3の倍数同士はswapできない
それ以外はswapできる。
(1) だけなら、偶数を赤、奇数を白としたときに、赤の相対順序が固定化されて、それ以外は自由。
(2) を入れるなら、2の倍数は赤、3の倍数は青、ただし6は紫で、それ以外は白とすると
・白はあとから自由に挿入できるので、以降 0 個として本質を失わない。
・(赤+青) 紫 (赤+青) の構造を考えると、左側と右側で独立に数えられる。
・赤+青の構造では、赤の相対順と青の相対順が固定化され、それ以外は自由なので、重複数え上げ。
計算量は O(N) になる。

考察上の見落とし：6が複数含まれるケース。それぞれ独立に計算が必要。
実装上の注意：AtCoder Libraryはそのままでは利用できない
*/

#include <iostream>
#include <vector>
#define rep(i, n) for(i = 0; i < n; i++)
#define int long long
using namespace std;

int mod = 998244353;
int n;
int a[100000];
int fact[100001];
int finv[100001];

int powmod(int a, int n, int mod) {
	if (n == 0) return 1;
	if (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);
	return a * powmod(a, n - 1, mod) % mod;
}

signed main() {
	int i, j;
	
	fact[0] = 1;
	finv[0] = 1;
	rep(i, 100000) {
		fact[i + 1] = (i + 1) * fact[i] % mod;
		finv[i + 1] = powmod(fact[i + 1], mod - 2, mod);
	}
	
	cin >> n;
	rep(i, n) cin >> a[i];
	
	vector<int> pos6;
	pos6.push_back(-1);
	rep(i, n) if (a[i] == 6) { pos6.push_back(i); }
	pos6.push_back(n);
	
	int ans = 1;
	
	rep(i, (int)pos6.size() - 1) {
		int red = 0, blue = 0;
		for (j = pos6[i] + 1; j < pos6[i + 1]; j++) {
			if (a[j] % 2 == 0) { red++; }
			if (a[j] % 3 == 0) { blue++; }
		}
		ans *= fact[red + blue];
		ans *= finv[red]; ans %= mod;
		ans *= finv[blue]; ans %= mod;
	}
	
	int white = 0;
	rep(i, n) {
		if (a[i] % 2 != 0 && a[i] % 3 != 0) { white++; }
	}
	for (i = n - white + 1; i <= n; i++) { ans *= i; ans %= mod; }
	
	cout << ans << endl;
	return 0;
}
