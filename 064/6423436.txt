#line 2 "lib/prelude.hpp"
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#endif
#include <bits/stdc++.h>
using namespace std;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
#define rep2(i, m, n) for (auto i = (m); i < (n); i++)
#define rep(i, n) rep2(i, 0, n)
#define repr2(i, m, n) for (auto i = (n); i-- > (m);)
#define repr(i, n) repr2(i, 0, n)
#define all(x) begin(x), end(x)
#line 3 "lib/graph.hpp"

struct unit_edge {
  int v;
  int to() const { return v; }
  operator int() const { return to(); }
  int w() const { return 1; }
};

template <class Weight>
struct weighted_edge {
  int v;
  Weight weight;
  int to() const { return v; }
  operator int() const { return to(); }
  Weight w() const { return weight; }
};

template <class Inner>
struct basic_graph {
  using weight_type = int;
  const Inner& inner;
  basic_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto u : inner[v]) f(unit_edge{u});
  }
};

template <class Inner, class Weight>
struct basic_weighted_graph {
  using weight_type = Weight;
  const Inner& inner;
  basic_weighted_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto [u, w] : inner[v]) f(weighted_edge<weight_type>{u, w});
  }
};

template <class T>
struct graph_trait : public T {
  graph_trait(T t) : T(move(t)) {}
};

template <class T>
using W = typename graph_trait<T>::weight_type;

template <size_t N>
struct graph_trait<vector<int>[N]> : basic_graph<vector<int>[N]> {
  using basic_graph<vector<int>[N]>::basic_graph;
  int size() const { return N; }
};

template <>
struct graph_trait<vector<vector<int>>> : basic_graph<vector<vector<int>>> {
  using basic_graph<vector<vector<int>>>::basic_graph;
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};

template <size_t N, class Weight>
struct graph_trait<vector<pair<int, Weight>>[N]>
    : basic_weighted_graph<vector<pair<int, Weight>>[N], Weight> {
  using basic_weighted_graph<vector<pair<int, Weight>>[N],
                             Weight>::basic_weighted_graph;
  int size() const { return N; }
};

template <class Weight>
struct graph_trait<vector<vector<pair<int, Weight>>>>
    : basic_weighted_graph<vector<vector<pair<int, Weight>>>, Weight> {
  using basic_weighted_graph<vector<vector<pair<int, Weight>>>,
                             Weight>::basic_weighted_graph;
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};
#line 3 "lib/ds/dsu.hpp"

class dsu {
 public:
  dsu(int n) : par(n, -1), count_(n) {}
  int size() const { return par.size(); }
  int count() const { return count_; }
  void clear() {
    fill(par.begin(), par.end(), -1);
    count_ = size();
  }
  int find(int x) { return par[x] < 0 ? x : par[x] = (int)find(par[x]); }
  bool same(int x, int y) { return find(x) == find(y); }
  bool unite(int x, int y) {
    x = find(x), y = find(y);
    if (x == y) return false;
    if (par[x] > par[y]) swap(x, y);
    par[x] += par[y], par[y] = (int)x;
    count_--;
    return true;
  }
  vector<vector<int>> groups() {
    vector<vector<int>> res(size());
    for (int x = 0; x < size(); x++) res[find(x)].push_back(x);
    res.erase(remove_if(all(res), [](const auto& v) { return v.empty(); }),
              res.end());
    return res;
  }

 private:
  vector<int> par;
  int count_;
};
#line 4 "lib/graph/mst.hpp"

// G: undirected
// forest if not connected
template <class G>
vector<tuple<int, int, W<G>>> minimum_spanning_tree(const G& graph) {
  graph_trait<G> g(graph);
  vector<tuple<W<G>, int, int>> edges;
  rep(v, g.size()) g.adj(v, [&](auto&& e) {
    if (e.to() > v) edges.emplace_back(e.w(), v, e.to());
  });
  minimum_spanning_tree(g.size(), move(edges));
}

template <class W>
vector<tuple<int, int, W>> minimum_spanning_tree(
    int n, vector<tuple<int, int, W>> edges) {
  sort(all(edges), [&](auto&& a, auto&& b) { return get<2>(a) < get<2>(b); });
  dsu dsu(n);
  vector<tuple<int, int, W>> res;
  for (auto [u, v, w] : edges)
    if (dsu.unite(u, v)) res.emplace_back(u, v, w);
  return res;
}
#line 2 "main.cpp"

int main() {
  int n, m; scanf("%d%d", &n, &m);
  vector<tuple<int, int, int>> edges(m);
  rep(i, m) {
    int s, t, w; scanf("%d%d%d", &s, &t, &w);
    edges[i] = {s, t, w};
  }
  ll tot = 0;
  for (auto [u, v, w] : minimum_spanning_tree(n, edges)) tot += w;
  printf("%lld\n", tot);
}

