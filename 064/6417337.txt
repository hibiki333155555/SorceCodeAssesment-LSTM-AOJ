#line 2 "lib/prelude.hpp"
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#endif
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep2(i, m, n) for (auto i = (m); i < (n); i++)
#define rep(i, n) rep2(i, 0, n)
#define repr2(i, m, n) for (auto i = (n); i-- > (m);)
#define repr(i, n) repr2(i, 0, n)
#define all(x) begin(x), end(x)
#line 3 "lib/graph2.hpp"

template <class Vertex = int>
struct unit_edge {
  Vertex v;
  Vertex to() const { return v; }
  operator Vertex() const { return to(); }
  int w() const { return 1; }
};

template <class Weight, class Vertex = int>
struct weighted_edge {
  Vertex v;
  Weight weight;
  Vertex to() const { return v; }
  operator Vertex() const { return to(); }
  Weight w() const { return weight; }
};

template <class Inner>
class basic_graph {
 public:
  using vertex_type = int;
  using weight_type = int;

  basic_graph(Inner& g) : inner(g) {}

  int id(vertex_type v) const { return v; }
  template <class F>
  void adj(vertex_type v, F&& f) const {
    for (auto u : inner[v]) f(unit_edge{u});
  }

 protected:
  Inner& inner;
};

template <class Inner, class Weight>
class basic_weighted_graph {
 public:
  using vertex_type = int;
  using weight_type = Weight;

  basic_weighted_graph(Inner& g) : inner(g) {}

  int id(vertex_type v) const { return v; }
  template <class F>
  void adj(vertex_type v, F&& f) const {
    for (auto [u, w] : inner[v]) f(weighted_edge<weight_type>{u, w});
  }

 protected:
  Inner& inner;
};

template <class T>
class graph_trait;

template <class T>
using V = typename graph_trait<T>::vertex_type;

template <class T>
using W = typename graph_trait<T>::weight_type;

template <size_t N>
class graph_trait<vector<int>[N]> : public basic_graph<vector<int>[N]> {
  using basic_graph<vector<int>[N]>::basic_graph;

 public:
  int size() const { return N; }
};

template <>
class graph_trait<vector<vector<int>>>
    : public basic_graph<vector<vector<int>>> {
  using basic_graph<vector<vector<int>>>::basic_graph;

 public:
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};

template <size_t N, class Weight>
class graph_trait<vector<pair<int, Weight>>[N]>
    : public basic_weighted_graph<vector<pair<int, Weight>>[N], Weight> {
  using basic_weighted_graph<vector<pair<int, Weight>>[N],
                             Weight>::basic_weighted_graph;

 public:
  int size() const { return N; }
};

template <class Weight>
class graph_trait<vector<vector<pair<int, Weight>>>>
    : public basic_weighted_graph<vector<vector<pair<int, Weight>>>, Weight> {
  using basic_weighted_graph<vector<vector<pair<int, Weight>>>,
                             Weight>::basic_weighted_graph;

 public:
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};
#line 3 "lib/graph2/dijkstra.hpp"

template <class G>
vector<W<G>> dijkstra(G& graph, V<G> s) {
  graph_trait<G> g(graph);
  vector<W<G>> dist(g.size(), numeric_limits<W<G>>::max());
  priority_queue<pair<W<G>, V<G>>, vector<pair<W<G>, V<G>>>, greater<>> hp;
  hp.emplace(W<G>(0), s);
  dist[g.id(s)] = W<G>(0);
  while (!hp.empty()) {
    auto [w, v] = move(hp.top());
    hp.pop();
    if (w != dist[v]) continue;
    g.adj(v, [&](auto&& e) {
      if (dist[g.id(e.to())] > dist[g.id(v)] + e.w())
        dist[g.id(e.to())] = dist[g.id(v)] + e.w(),
        hp.emplace(dist[g.id(e.to())], e.to());
    });
  }
  return dist;
}
#line 3 "main.cpp"

int n, m, r;
vector<pair<int, int>> G[100000];

int main() {
  scanf("%d%d%d", &n, &m, &r);
  rep(_, m) {
    int u, v; int w; scanf("%d%d%d", &u, &v, &w);
    G[u].emplace_back(v, w);
  }
  auto d = dijkstra(G, r);
  rep(i, n) if (d[i] == INT_MAX) printf("INF\n"); else printf("%d\n", d[i]);
}

