#include<iostream>
#include<vector>
#include<algorithm>
#include<map>
#include<set>
#include<queue>
#define rep(i,n) for (int i = 0; i < (n); i++)
#define all(v) v.begin(), v.end()
using namespace std;
using ll = long long;
template<typename T> bool chmax(T &a, const T b) {
    if (a < b) {a = b; return true;} else return false; }
template<typename T> bool chmin(T &a, const T b) {
    if (a > b) {a = b; return true;} else return false; }

template<typename T>
struct SparseTable {
    vector<vector<T>> st;
    vector<int> lb;

    SparseTable(){}
    SparseTable(const vector<T> &v){
        int b = 0;
        while((1<<b) <= (int)v.size()) ++b;
        st.assign(b, vector<T>(1<<b));
        for(int i=0; i<(int)v.size(); i++){
            st[0][i] = v[i];
        }
        for(int i=1; i<b; i++){
            for(int j=0; j+(1<<i)<=(1<<b); j++){
                st[i][j] = min(st[i-1][j], st[i-1][j + (1<<(i-1))]);
            }
        }
        lb.resize((int)v.size()+1);
        for(int i=2; i<(int)lb.size(); i++){
            lb[i] = lb[i >> 1] + 1;
        }
    }

    inline T rmq(int l, int r){
        assert(r>l);
        int b = lb[r-l];
        return min(st[b][l], st[b][r-(1<<b)]);
    }
};

//template<typename CostType>
struct EulerTour {
    vector<int> etour, depth, tin, tout, parent;

    EulerTour (const vector<vector<int>> &graph, const int root = 0):graph(graph){
        const int n = (int)graph.size();
        tin.resize(n);
        tout.resize(n);
        parent.resize(n);
        dfs(root, -1, 0);
    }

    SparseTable<pair<int,int>> st;
    void st_init(){
        vector<pair<int,int>> vec((int)depth.size());
        for(int i=0; i<(int)depth.size(); i++){
            vec[i].first = depth[i];
            vec[i].second = etour[i];
        }
        st = SparseTable<pair<int,int>> (vec);
    }

    inline int st_query(int u, int v){
        u = tin[u];
        v = tin[v];
        if(u>v) swap(u,v);
        int e = st.rmq(u,v+1).second;
        return e>0 ? e:parent[-e];
    }

    private:
    const vector<vector<int>> graph;
    int id = 0;

    void dfs(const int pos, const int pre, const int cur_depth){
        parent[pos] = pre;
        etour.emplace_back(pos);
        tin[pos] = (int)etour.size()-1;
        depth.emplace_back(cur_depth);
        for(int to: graph[pos]){
            if(to == pre)continue;
            dfs(to, pos, cur_depth+1);
            depth.emplace_back(cur_depth);
        }
        etour.emplace_back(-pos);
        tout[pos] = (int)etour.size()-1;
    }
};


int main(){
    int n;
    cin >> n;
    vector<vector<int>> G(n);
    rep(i,n){
        int k;
        cin >> k;
        rep(j,k){
            int c;
            cin >> c;
            G[i].push_back(c);
            G[c].push_back(i);
        }
    }
    EulerTour et(G);
    et.st_init();
    int q;
    cin >> q;
    rep(i,q){
        int u,v;
        cin >> u >> v;
        cout << et.st_query(u,v) << endl;
    }
    return 0;
}
