#line 1 "main.cpp"
#pragma region Macros
#include <bits/stdc++.h>
using namespace std;
template <class T> inline bool chmax(T &a, T b) {
    if(a < b) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T> inline bool chmin(T &a, T b) {
    if(a > b) {
        a = b;
        return 1;
    }
    return 0;
}
#ifdef DEBUG
template <class T, class U>
ostream &operator<<(ostream &os, const pair<T, U> &p) {
    os << '(' << p.first << ',' << p.second << ')';
    return os;
}
template <class T> ostream &operator<<(ostream &os, const vector<T> &v) {
    os << '{';
    for(int i = 0; i < (int)v.size(); i++) {
        if(i) { os << ','; }
        os << v[i];
    }
    os << '}';
    return os;
}
void debugg() { cerr << endl; }
template <class T, class... Args>
void debugg(const T &x, const Args &... args) {
    cerr << " " << x;
    debugg(args...);
}
#define debug(...)                                                             \
    cerr << __LINE__ << " [" << #__VA_ARGS__ << "]: ", debugg(__VA_ARGS__)
#define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
#else
#define debug(...) (void(0))
#define dump(x) (void(0))
#endif

struct Setup {
    Setup() {
        cin.tie(0);
        ios::sync_with_stdio(false);
        cout << fixed << setprecision(15);
    }
} __Setup;

using ll = long long;
#define OVERLOAD3(_1, _2, _3, name, ...) name
#define ALL(v) (v).begin(), (v).end()
#define RALL(v) (v).rbegin(), (v).rend()
#define REP1(i, n) for(int i = 0; i < int(n); i++)
#define REP2(i, a, b) for(int i = (a); i < int(b); i++)
#define REP(...) OVERLOAD3(__VA_ARGS__, REP2, REP1)(__VA_ARGS__)
#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())
#define SZ(v) ((int)(v).size())
const int INF = 1 << 30;
const ll LLINF = 1LL << 60;
constexpr int MOD = 1000000007;
constexpr int MOD2 = 998244353;
const int dx[4] = {1, 0, -1, 0};
const int dy[4] = {0, 1, 0, -1};

void Case(int i) { cout << "Case #" << i << ": "; }
int popcount(int x) { return __builtin_popcount(x); }
ll popcount(ll x) { return __builtin_popcountll(x); }
#pragma endregion Macros

#line 1 "/Users/siro53/kyo-pro/compro_library/string/rolling_hash.hpp"
// 最初にbaseをgenBase()でランダムに生成すること！！！！！！！！！
// RollingHash(s, base) := 文字列sのハッシュテーブルを計算する
// get(l, r) := [l, r)のハッシュ値を求める
// connect(h1, h2, h2len) := ハッシュ値h1と, 長さh2lenのハッシュ値h2を結合する。
// LCP(b, l1, r1, l2, r2) := 区間[l1, r1)と、ハッシュテーブルがbである区間[l2,
// r2)の文字列の 最長共通接頭辞の長さを求める。
struct RollingHash {
    using ull = unsigned long long;
    using ui128 = __uint128_t;
    static const ull mod = (1ULL << 61) - 1;
    const ull base;
    vector<ull> hashed, power;

    inline ull add(ull a, ull b) {
        if((a += b) >= mod) {
            a -= mod;
        }
        return a;
    }
    inline ull mul(ull a, ull b) {
        ui128 t = (ui128)a * b;
        ull na = t >> 61;
        ull nb = t & mod;
        if((na += nb) >= mod) {
            na -= mod;
        }
        return na;
    }
    static inline ull genBase() {
        random_device seed_gen;
        mt19937_64 engine(seed_gen());
        uniform_int_distribution<ull> rand(2, mod - 2);
        return rand(engine);
    }
    RollingHash() = default;
    RollingHash(const string &s, ull base) : base(base) {
        int n = (int)s.size();
        hashed.assign(n + 1, 0);
        power.assign(n + 1, 0);
        power[0] = 1;
        for(int i = 0; i < n; i++) {
            power[i + 1] = mul(power[i], base);
            hashed[i + 1] = add(mul(hashed[i], base), s[i]);
        }
    }
    ull get(int l, int r) {
        return add(hashed[r], mod - mul(hashed[l], power[r - l]));
    }
    ull connect(ull h1, ull h2, int h2len) {
        return add(mul(h1, power[h2len]), h2);
    }
    int LCP(RollingHash &b, int l1, int r1, int l2, int r2) {
        assert(mod == b.mod);
        int len = min(r1 - l1, r2 - l2);
        int low = -1, high = len + 1;
        while(high - low > 1) {
            int mid = (low + high) >> 1;
            if(get(l1, l1 + mid) == b.get(l2, l2 + mid)) {
                low = mid;
            } else {
                high = mid;
            }
        }
        return low;
    }
};
#line 77 "main.cpp"

int main() {
    int N;
    string s;
    cin >> N >> s;
    string rs = s;
    reverse(ALL(rs));
    debug(s, rs);
    auto BASE = RollingHash::genBase();
    RollingHash rhs(s, BASE), rhrs(rs, BASE);

    int ans = 0;
    REP(r, N-1) { // [0, r+1)までと[r+1, N)を比較
        if(r + 1 <= N - r - 1) {
            debug(r, r+1, N-2*(r+1));
            int st = N - 2*(r+1);
            if(rhs.get(0, r+1) == rhrs.get(st, st+r+1)) {
                debug(1, r);
                ans++;
            }
        } else {
            int st = N - 2*(N-r-1);
            if(rhs.get(st, st+N-r-1) == rhrs.get(0, N-r-1)) {
                debug(2, r);
                ans++;
            }
        }
    }
    cout << ans << endl;
}

