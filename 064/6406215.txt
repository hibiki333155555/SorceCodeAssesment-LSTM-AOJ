#!/usr/bin/python3

import sys
import resource

MOD = 998244353
sys.setrecursionlimit(10**6)

n = int(input())
g = [[] for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)
m = 20
dp = [[-1] * n for _ in range(m)]
lower = [0] * n
depth = [0] * n
def make_lower(f, par):
    lower[f] = 1
    for to in g[f]:
        if to == par:
            continue
        depth[to] = depth[f] + 1
        dp[0][to] = f
        make_lower(to, f)
        lower[f] += lower[to] * 2
        lower[f] %= MOD
make_lower(0, -1)
all = lower.copy()
def make_all(f, par):
    for to in g[f]:
        if to == par:
            continue
        all[to] += (all[f] - 2 * lower[to]) * 2
        all[to] %= MOD
        if all[to] < 0:
            all[to] += MOD
        make_all(to, f)
make_all(0, -1)
for i in range(m - 1):
    for j in range(n):
        if dp[i][j] == -1:
            dp[i + 1][j] = -1
        else:
            dp[i + 1][j] = dp[i][dp[i][j]]
def climb(f, x):
    for i in range(m):
        if x >> i & 1:
            f = dp[i][f]
        if f == -1:
            return -1
    return f
two_pow = [1] * (n + 1)
for i in range(n):
    two_pow[i + 1] = two_pow[i] * 2 % MOD
q = int(input())
for _ in range(q):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    if depth[x] > depth[y]:
        x, y = (y, x)
    d = depth[y] - depth[x]
    if x == climb(y, d):
        z = climb(y, d - 1)
        ans = (all[x] - 2 * lower[z]) % MOD * lower[y] % MOD
        ans *= two_pow[d]
        ans %= MOD
        if ans < 0:
            ans += MOD
        print(ans)
    else:
        d2 = (1 << m) - 1
        for i in range(m - 1, -1, -1):
            nd = d2 & ~(1 << i)
            if climb(x, nd) == climb(y, d + nd):
                d2 = nd
        ans = lower[x] * lower[y] % MOD
        ans *= two_pow[d + d2 * 2]
        ans %= MOD
        print(ans)

