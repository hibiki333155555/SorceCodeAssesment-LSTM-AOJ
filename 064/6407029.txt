#include <bits/stdc++.h>

using namespace std;
#define all(a) a.begin(), a.end()
#define int long long
#define over_load_(_1, _2, _3, _4, NAME, ...) NAME
#define rep(...) over_load_(__VA_ARGS__, rep4, rep3, rep2)(__VA_ARGS__)
#define rep2(i, r) for (int i = 0; i < static_cast<int>(r); (i) += 1)
#define rep3(i, l, r) for (int i = static_cast<int>(l); i < static_cast<int>(r); (i) += 1)
#define rep4(i, l, r, stride) for (int i = static_cast<int>(l); i < static_cast<int>(r); (i) += (stride))
#define rrep(...) over_load_(__VA_ARGS__, rrep4, rrep3, rrep2)(__VA_ARGS__)
#define rrep2(i, r) for (int i = static_cast<int>(r) - 1; i >= 0; (i) -= 1)
#define rrep3(i, l, r) for (int i = static_cast<int>(r) - 1; i >= static_cast<int>(l); (i) -= 1)
#define rrep4(i, l, r, stride) for (int i = static_cast<int>(r) - 1; i >= static_cast<int>(l); (i) -= (stride))
#define fore(i, a) for (auto &i: a)
template <typename T1, typename T2>
inline bool chmax(T1 &a, T2 b) {
  return a < b && (a = b, true);
}
template <typename T1, typename T2>
inline bool chmin(T1 &a, T2 b) {
  return a > b and (a = b, true);
}
constexpr char newl = '\n';

using ll = long long;
using vi = vector<int>;
using vll = vector<ll>;
using vvi = vector<vi>;
using vvll = vector<vll>;
using vp = vector<pair<int, int>>;
using vs = vector<string>;

class UF {
private:
  vector<long long> parent;
  vector<long long> rank;

public:
  UF(int n) {
    parent.resize(n);
    rank.resize(n);
    for (int i = 0; i < n; i++) {
      parent[i] = i;
      rank[i] = 0;
    }
  }

  int find(int x) {
    if (x != parent[x]) parent[x] = find(parent[x]);
    return parent[x];
  }

  bool same(int x, int y) { return find(x) == find(y); }

  void link(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) return;

    if (rank[x] > rank[y])
      parent[y] = x;
    else {
      parent[x] = y;
      if (rank[x] == rank[y]) rank[y]++;
    }
  }
};

struct edge {
  int from;
  int to;
  int weight;
};

vector<vector<struct edge>> Graph;
vector<vector<struct edge>> MST;

signed main() {
  int v, e;
  cin >> v >> e;
  Graph.resize(v);
  MST.resize(v);
  vector<struct edge> edges;
  rep(_, e) {
    int s, t, w;
    cin >> s >> t >> w;
    struct edge add1 = { s, t, w }, add2 = { t, s, w };
    Graph[s].push_back(add1);
    edges.push_back(add1);
    Graph[t].push_back(add2);
  }

  UF unionfind(v);

  sort(edges.begin(), edges.end(), [&](edge i, edge j) {
    return i.weight < j.weight;
  });

  int ans = 0;

  fore(x, edges) {
    if (!unionfind.same(x.from, x.to)) {
      ans += x.weight;
      MST[x.from].push_back(x);
      unionfind.link(x.from, x.to);
    }
  }
  cout << ans << newl;
}
