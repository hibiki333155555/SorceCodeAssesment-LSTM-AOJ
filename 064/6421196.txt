#include <iostream>
#include <vector>
#include <queue>
#include <string>

using namespace std;
typedef long long ll;
typedef pair<ll,int> pll;
vector<pll> G[4000100]; //weight,vertex
priority_queue<pll,vector<pll>,greater<pll>> que;
ll d[4000100],INF = 100000000000000000;
ll lim[4000010];
void add_edge(int from,int to,ll weight){ G[from].push_back({weight,to}); }
void dijkstra(ll now,int s){
    que.push({now,s});
    while(que.size()){
        pll p = que.top(); que.pop();
        ll dis = p.first,pos = p.second;
        if(d[pos]!=INF || dis>=lim[pos]) continue;
        d[pos] = dis;
        for(auto e:G[pos]){
            if(d[e.second]==INF) que.push({dis + e.first,e.second});
        }
    }
}

int dx[4] = {-1,0,1,0};
int dy[4] = {0,1,0,-1};
string s[1010];
int a[100010],b[100010],t[100010];
int main(){
    int i,j,k,h,w; cin >> h >> w;
    for(i=0;i<h;i++) cin >> s[i];
    int m; cin >> m;
    for(i=0;i<m;i++) cin >> a[i] >> b[i] >> t[i];
    int st = -1,go = -1;
    for(i=0;i<h;i++){
        for(j=0;j<w;j++){
            if(s[i][j]=='#') continue;
            int now = i*w + j;
            if(s[i][j]=='S') st = now;
            if(s[i][j]=='V') go = now;
            for(k=0;k<4;k++){
                int nx = i + dx[k],ny = j + dy[k];
                if(nx<0 || nx>=h || ny<0 || ny>=w || s[nx][ny]=='#') continue;
                add_edge(now,nx*w + ny,1);
            }
        }
    }
    for(i=0;i<h*w;i++) lim[i] = INF;
    for(i=0;i<m;i++){
        a[i]--; b[i]--;
        lim[a[i]*w + b[i]] = t[i];
    }
    for(i=0;i<h;i++){
        for(j=0;j<w;j++) d[i*w + j] = INF;
    }
    dijkstra(0,st);
    int ti = -1;
    if(d[go]==INF){
        cout << "No\n";
        return 0;
    }else{
        ti = d[go];
    }
    for(i=0;i<h*w;i++) d[i] = INF;
    dijkstra(ti,go);
    if(d[st]==INF){
        cout << "No\n";
        return 0;
    }
    cout << "Yes\n";
}
