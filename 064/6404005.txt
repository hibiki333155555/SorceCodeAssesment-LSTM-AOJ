// Problem: Parallel/Orthogonal
// Contest: Virtual Judge - Aizu
// URL: https://vjudge.net/problem/Aizu-CGL_2_A
// Memory Limit: 1024 MB
// Time Limit: 1000 ms
// Author: ZCETHAN
// Time: 2022-03-14 20:00:08

#include<bits/stdc++.h>
#define ll long long
#define inf (1<<30)
#define INF (1ll<<60)
#define pii pair<int,int>
#define pll pair<ll,ll>
#define mkp make_pair
#define fi first
#define se second
#define pb push_back
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define pt(a) cerr<<#a<<'='<<a<<' '
#define pts(a) cerr<<#a<<'='<<a<<'\n'

using namespace std;
const double eps=1e-8;
const double PI=acos(-1);
int sgn(double x){
    if(fabs(x)<eps) return 0;
    if(x<0) return -1;else return 1;
}//判断 x 的正负
struct Node{
    double x,y;Node(){}
    Node(double _x,double _y){x=_x;y=_y;}
    void input(){cin>>x>>y;}
    Node friend operator+(Node a,Node b){return Node(a.x+b.x,a.y+b.y);}
    Node friend operator-(Node a,Node b){return Node(a.x-b.x,a.y-b.y);}
    Node friend operator*(Node a,double b){return Node(a.x*b,a.y*b);}
    double friend operator*(Node a,Node b){return a.x*b.x+a.y*b.y;}
    double friend operator^(Node a,Node b){return a.x*b.y-b.x*a.y;}
    void rot(double a){
        double x1=x*cos(a)-y*sin(a);
        double y1=y*cos(a)+x*sin(a);
        x=x1;y=y1;
    }
};
struct Line{
    Node s,e;Line(){}
    Line(Node _s,Node _e){s=_s;e=_e;}
    void input(){s.input();e.input();}
    pair<int,Node> friend operator&(Line a,Line b){
        Node res=a.s;
        if(sgn((a.e-a.s)^(b.e-b.s))==0){
            if(sgn((b.e-a.s)^(b.e-b.s))==0) return mkp(0,res);
            else return mkp(1,res);
        }
        double tmp=((a.s-b.s)^(b.e-b.s))/((a.e-a.s)^(b.s-b.e));
        res.x+=(a.e.x-a.s.x)*tmp;res.y+=(a.e.y-a.s.y)*tmp;return mkp(2,res);
    }
};
double dist(Node a,Node b){return sqrt((a-b)*(a-b));}
double PTS(Node P,Line L){//Point To Segment
    Node res=L.s;double tmp=((P-L.s)*(L.e-L.s))/((L.e-L.s)*(L.e-L.s));
    if(tmp<0||tmp>1) return min(dist(P,L.s),dist(P,L.e));
    res.x+=(L.e.x-L.s.x)*tmp;res.y+=(L.e.y-L.s.y)*tmp;return dist(res,P);
}
bool IPOS(Node P,Line L){return sgn((L.s-P)^(L.e-P))==0&&sgn((L.s-P)*(L.e-P))<0;}
//Is Point On Segment
double CPA(vector<Node> poly){//Calculate Polygon Area
    double ret=0;int n=poly.size();
    rep(i,0,n-1) ret+=(poly[i]^poly[(i+1)%n])/2;
    return ret;
}
bool ISI(Line l1,Line l2){//Is Segment Intersection
    if(max(l1.s.x,l1.e.x)<min(l2.s.x,l2.e.x)) return 0;
    if(max(l2.s.x,l2.e.x)<min(l1.s.x,l1.e.x)) return 0;
    if(max(l1.s.y,l1.e.y)<min(l2.s.y,l2.e.y)) return 0;
    if(max(l2.s.y,l2.e.y)<min(l1.s.y,l1.e.y)) return 0;
    //上面是快速排斥实验
    if(sgn((l2.s-l1.s)^(l1.e-l1.s))*sgn((l2.e-l1.s)^(l1.e-l1.s))>0) return 0;
    if(sgn((l1.s-l2.s)^(l2.e-l2.s))*sgn((l1.e-l2.s)^(l2.e-l2.s))>0) return 0;
    return 1;//上面是跨立实验
}
int IPIP(Node P,vector<Node> poly){//Is Point In Polygon
    int cnt=0,n=poly.size();
    rep(i,0,n-1){
        Node p1=poly[i],p2=poly[(i+1)%n];
        if(IPOS(P,Line(p1,p2))) return -1;//在多边形上
        int k=sgn((p2-p1)^(P-p1)),d1=sgn(p1.y-P.y),d2=sgn(p2.y-P.y);
        if(k>0&&d1<=0&&d2>0) cnt++;
        if(k<0&&d1<=0&&d2>0) cnt--;
    }return cnt!=0?1:0;
}
vector<Node> PST(vector<Node> poly){//Polar SorTing
    Node p0=poly[0];
    sort(poly.begin()+1,poly.end(),[&](Node p1,Node p2){
        double crs=(p1-p0)^(p2-p0);
        if(sgn(crs)>0) return 1;
        else if(sgn(crs)==0&&sgn(dist(p1,p0)-dist(p2,p0))<=0) return 1;
        else return 0;
    });return poly;
}
vector<Node> Graham(vector<Node> poly){
    poly=PST(poly);
    Node p0=poly[0];int n=poly.size(),id=0;
    rep(i,1,n-1)
        if(p0.y>poly[i].y||(p0.y==poly[i].y&&p0.x>poly[i].x))
            p0=poly[i],id=i;
    swap(poly[id],poly[0]);
    poly=PST(poly);
    vector<Node> ret;
    if(n<=2) return poly;
    ret.pb(poly[0]);ret.pb(poly[1]);
    rep(i,2,n-1){
        while(ret.size()>1&&sgn(((*ret.rbegin())-(*--ret.rbegin()))^
        (poly[i]-(*--ret.rbegin())))<=0) ret.pop_back();
        ret.pb(poly[i]);
    }return ret;
}
void solve(){
	Line l1,l2;
	l1.input();l2.input();
	if(ISI(l1,l2)) cout<<"0.0000000000\n";
	else{
		double ans1=min(PTS(l1.s,l2),PTS(l1.e,l2));
		double ans2=min(PTS(l2.s,l1),PTS(l2.e,l1));
		cout<<fixed<<setprecision(10)<<min(ans1,ans2)<<'\n';
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int T;for(cin>>T;T--;)solve();
	return 0;
}
