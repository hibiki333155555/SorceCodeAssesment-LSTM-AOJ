import sys
input = lambda : sys.stdin.readline().rstrip()

write = lambda x: sys.stdout.write(x+"\n"); writef = lambda x: print("{:.12f}".format(x))
debug = lambda x: sys.stderr.write(x+"\n")
YES="Yes"; NO="No"; pans = lambda v: print(YES if v else NO)
LI = lambda : list(map(int, input().split()))
def dlist(*l, fill=0):
    if len(l)==1:
        return [fill]*l[0]
    ll = l[1:]
    return [dlist(*ll, fill=fill) for _ in range(l[0])]
sys.setrecursionlimit(3*10**5+10)

class BIT:
    ### BIT binary
    def __init__(self, n, values=None):
        self.bit = [0]*(n+1)
        self.n = n
        self.total = 0
        if values is not None:
            for i,v in enumerate(values):
                self.add(i,v)
                self.total += v
    def check(self):
        l = []
        prv = 0
        for i in range(1,self.n+1):
            val = self.query(i)
            l.append(val-prv)
            prv = val
        print(" ".join(map(str, l)))
    #a1 ~ aiまでの和 O(logn)
    def query(self,i):
        res = 0
        while i > 0:
            res += self.bit[i]
            # res %= M
            i -= i&(-i)
        return res
    def get(self,i):
        return self.query(i+1) - self.query(i)
    #ai += x(logN)
    def add(self,i,x):
        i += 1
        if i==0:
            raise RuntimeError
        self.total += x
        while i <= self.n:
            self.bit[i] += x
            # self.bit[i] %= M
            i += i&(-i)
    def index(self, v):
        """a0,...,aiの和がv以上になる最小のindexを求める
        存在しないとき配列サイズを返す
        """
        if v <= 0:
            return 0
        if self.total<v:
            return self.n
        x = 0
        r = 1
        while r < self.n:
            r = r << 1;
        ll = r
        while ll>0:
            if x+ll<self.n and self.bit[x+ll]<v:
                v -= self.bit[x+ll]
                x += ll
            ll = ll>>1
        return x

### 遅延評価セグメント木(はやい)
class LSG:
    def __init__(self,n, a=None):
        self._n = n
        self._ninf = ninf
        self._op = op
        self._mapping = mapping
        self._composition = composition
        self._f0 = f0
        x = 0
        while (1 << x) < self._n:
            x += 1
        self._log = x
        self._size = 1 << self._log
        self._d = [self._ninf] * (2 * self._size)
        self._lz = [self._f0] * self._size
        if a is not None:
            for i in range(self._n):
                self._d[self._size + i] = a[i]
            for i in range(self._size - 1, 0, -1):
                self._update(i)
    def check(self):
        return [self.query_point(p) for p in range(self._n)]
    def update_point(self, p, x):
        p += self._size
        for i in range(self._log, 0, -1):
            self._push(p >> i)
        self._d[p] = x
        for i in range(1, self._log + 1):
            self._update(p >> i)
    def query_point(self, p):
        p += self._size
        for i in range(self._log, 0, -1):
            self._push(p >> i)
        return self._d[p]
    def query(self, left, right):
        if left == right:
            return self._ninf
        left += self._size
        right += self._size
        for i in range(self._log, 0, -1):
            if ((left >> i) << i) != left:
                self._push(left >> i)
            if ((right >> i) << i) != right:
                self._push(right >> i)
        sml = self._ninf
        smr = self._ninf
        while left < right:
            if left & 1:
                sml = self._op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = self._op(self._d[right], smr)
            left >>= 1
            right >>= 1
        return self._op(sml, smr)
    def query_all(self):
        return self._d[1]
    def update(self, left, right, f):
        if right is None:
            p = left
            p += self._size
            for i in range(self._log, 0, -1):
                self._push(p >> i)
            self._d[p] = self._mapping(f, self._d[p])
            for i in range(1, self._log + 1):
                self._update(p >> i)
        else:
            if left == right:
                return
            left += self._size
            right += self._size
            for i in range(self._log, 0, -1):
                if ((left >> i) << i) != left:
                    self._push(left >> i)
                if ((right >> i) << i) != right:
                    self._push((right - 1) >> i)
            l2 = left
            r2 = right
            while left < right:
                if left & 1:
                    self._all_apply(left, f)
                    left += 1
                if right & 1:
                    right -= 1
                    self._all_apply(right, f)
                left >>= 1
                right >>= 1
            left = l2
            right = r2
            for i in range(1, self._log + 1):
                if ((left >> i) << i) != left:
                    self._update(left >> i)
                if ((right >> i) << i) != right:
                    self._update((right - 1) >> i)
    def _update(self, k):
        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])
    def _all_apply(self, k, f) -> None:
        self._d[k] = self._mapping(f, self._d[k])
        if k < self._size:
            self._lz[k] = self._composition(f, self._lz[k])
    def _push(self, k):
        self._all_apply(2 * k, self._lz[k])
        self._all_apply(2 * k + 1, self._lz[k])
        self._lz[k] = self._f0
    def loc(self, l, r):
        return self._lz[self._size+l : self._size+r]
    
ninf = -1
f0 = -1
def op(x,y):
    return max(x,y)
def mapping(f,x):
    return max(f,x)
# composition: あとからきたクエリがf1に入る
def composition(f1,f2):
    return max(f1,f2)

n,m = list(map(int, input().split()))
vals = [0]*(m+1)
sg = LSG(m, [-1]*m)
for i in range(n):
    a,b,c = LI()
    b -= 1
    c -= 1
    vals[b] += a
    vals[c+1] -= a
    sg.update(b,c+1,c)
for i in range(1,m+1):
    vals[i] += vals[i-1]
# print(vals)
q = int(input())
for i in range(q):
    d,e = LI()
    e -= 1
    vals[e] -= d
# print(vals)
j = 0
ans = 0
plus = BIT(m)
cur = 0
def sub(ind):
    return cur - plus.query(ind)

for i in range(m):
    val = vals[i]+sub(i)
    if val>=0:
        continue
    else:
        r = sg.query(i,i+1)
        if r<i:
            print(-1)
            break
        val *= -1
        ans += val
#         plus.add(i,-val)
        plus.add(r,val)
        cur += val
else:
    print(ans)
