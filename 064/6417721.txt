#include <stdio.h>
#include <stdlib.h>

typedef struct {
	int key, id[2];
} data;

typedef struct {
	data obj[1000001];
	int size;
} max_heap;

void push(max_heap* h, data x)
{
	int i = ++(h->size), j = i >> 1;
	data tmp;
	h->obj[i] = x;
	while (j > 0) {
		if (h->obj[i].key > h->obj[j].key) {
			tmp = h->obj[j];
			h->obj[j] = h->obj[i];
			h->obj[i] = tmp;
			i = j;
			j >>= 1;
		} else break;
	}
}

data pop(max_heap* h)
{
	int i = 1, j = 2;
	data output = h->obj[1], tmp;
	h->obj[1] = h->obj[(h->size)--];
	while (j <= h->size) {
		if (j < h->size && h->obj[j^1].key > h->obj[j].key) j ^= 1;
		if (h->obj[j].key > h->obj[i].key) {
			tmp = h->obj[j];
			h->obj[j] = h->obj[i];
			h->obj[i] = tmp;
			i = j;
			j <<= 1;
		} else break;
	}
	return output;
}


int main()
{
	int i, N, H, W, sx, sy, gx, gy, x[100001], y[100001], k[100001];
	scanf("%d %d %d", &H, &W, &N);
	scanf("%d %d %d %d", &sx, &sy, &gx, &gy);
	for (i = 1; i <= N; i++) scanf("%d %d %d", &(x[i]), &(y[i]), &(k[i]));
	
	int j, xx, yy, **dist = (int**)malloc(sizeof(int*) * (H + 2));
	max_heap h;
	data d;
	for (i = 0; i <= H + 1; i++) {
		dist[i] = (int*)malloc(sizeof(int) * (W + 2));
		for (j = 1, dist[i][0] = 0, dist[i][W+1] = 0; j <= W; j++) dist[i][j] = (i == 0 || i == H + 1)? 0: -1;
	}
	for (i = 1, h.size = 0; i <= N; i++) {
		if (dist[x[i]][y[i]] < k[i]) {
			dist[x[i]][y[i]] = k[i];
			d.key = k[i];
			d.id[0] = x[i];
			d.id[1] = y[i];
			push(&h, d);
		}
	}
	while (h.size > 0) {
		d = pop(&h);
		xx = d.id[0];
		yy = d.id[1];
		if (d.key != dist[xx][yy]) continue;
		if (dist[xx-1][yy] < dist[xx][yy] - 1) {
			dist[xx-1][yy] = dist[xx][yy] - 1;
			d.key = dist[xx-1][yy];
			d.id[0] = xx - 1;
			d.id[1] = yy;
			push(&h, d);
		}
		if (dist[xx+1][yy] < dist[xx][yy] - 1) {
			dist[xx+1][yy] = dist[xx][yy] - 1;
			d.key = dist[xx+1][yy];
			d.id[0] = xx + 1;
			d.id[1] = yy;
			push(&h, d);
		}
		if (dist[xx][yy-1] < dist[xx][yy] - 1) {
			dist[xx][yy-1] = dist[xx][yy] - 1;
			d.key = dist[xx][yy-1];
			d.id[0] = xx;
			d.id[1] = yy - 1;
			push(&h, d);
		}
		if (dist[xx][yy+1] < dist[xx][yy] - 1) {
			dist[xx][yy+1] = dist[xx][yy] - 1;
			d.key = dist[xx][yy+1];
			d.id[0] = xx;
			d.id[1] = yy + 1;
			push(&h, d);
		}
	}
	
	int q[100001][2], head, tail;
	dist[sx][sy] = -2;
	q[0][0] = sx;
	q[0][1] = sy;
	for (head = 0, tail = 1; head < tail; head++) {
		xx = q[head][0];
		yy = q[head][1];
		if (dist[xx-1][yy] == -1) {
			dist[xx-1][yy] = -2;
			q[tail][0] = xx - 1;
			q[tail++][1] = yy;
		}
		if (dist[xx+1][yy] == -1) {
			dist[xx+1][yy] = -2;
			q[tail][0] = xx + 1;
			q[tail++][1] = yy;
		}
		if (dist[xx][yy-1] == -1) {
			dist[xx][yy-1] = -2;
			q[tail][0] = xx;
			q[tail++][1] = yy - 1;
		}
		if (dist[xx][yy+1] == -1) {
			dist[xx][yy+1] = -2;
			q[tail][0] = xx;
			q[tail++][1] = yy + 1;
		}
	}
	if (dist[gx][gy] == -2) printf("Yes\n");
	else printf("No\n");
	fflush(stdout);
	return 0;
}
