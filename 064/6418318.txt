#!usr/bin/env python3
from collections import defaultdict, deque
from heapq import heappush, heappop
from itertools import permutations, accumulate
import sys
import math
import bisect
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def IR(n):
    return [I() for _ in range(n)]
def LIR(n):
    return [LI() for _ in range(n)]

sys.setrecursionlimit(1000000)
mod = 998244353

FOR = list("for")
PRINT = list("print")
A = ord("a")
Z = ord("z")


def solve(n):
    print_lis = []
    value = [0]*26+[1]
    for _ in range(n):
        s = input()
        i = 0
        stack = []
        for_count = 1
        while i < len(s):
            stack.append(s[i])
            if stack == FOR:
                stack = []
                right = [0]*27
                exp_num = 0
                sig = 1
                for j in range(i+2,len(s)):
                    si = s[j]
                    if si == ")":
                        i = j
                        break
                    oi = ord(si)
                    if A <= oi <= Z:
                        right[oi-A] += sig
                    elif si.isdecimal():
                        exp_num = exp_num*10+int(si)
                        if exp_num >= mod:
                            exp_num %= mod
                    elif si == "+" or si == "-":
                        res = right[26]+sig*exp_num
                        if res < 0 or res >= mod:
                            res %= mod
                        right[26] = res
                        if si == "+":
                            sig = 1
                        else:
                            sig = -1
                res = right[26]+sig*exp_num
                if res < 0 or res >= mod:
                    res %= mod
                right[26] = res
                coef = [i%mod for i in right]
                exp_num = 0
                for ci,vi in zip(coef,value):
                    exp_num += ci*vi
                    if exp_num >= mod:
                        exp_num %= mod
                for_count *= exp_num
            elif stack == PRINT:
                stack = []
                right = [0]*27
                exp_num = 0
                sig = 1
                for j in range(i+2,len(s)):
                    si = s[j]
                    if si == ")":
                        i = j
                        break
                    oi = ord(si)
                    if A <= oi <= Z:
                        right[oi-A] += sig
                    elif si.isdecimal():
                        exp_num = exp_num*10+int(si)
                        if exp_num >= mod:
                            exp_num %= mod
                    elif si == "+" or si == "-":
                        res = right[26]+sig*exp_num
                        if res < 0 or res >= mod:
                            res %= mod
                        right[26] = res
                        if si == "+":
                            sig = 1
                        else:
                            sig = -1
                res = right[26]+sig*exp_num
                if res < 0 or res >= mod:
                    res %= mod
                right[26] = res
                coef = [i%mod for i in right]
                exp_num = 0
                for ci,vi in zip(coef,value):
                    exp_num += ci*vi
                    if exp_num >= mod:
                        exp_num %= mod
                if for_count > 0:
                    print_lis.append((exp_num,for_count))
            i += 1
        if len(stack) == 1:
            continue
        elif stack:
            if for_count <= 0:
                continue
            val = stack[0]
            o = ord(val)
            stack = stack[3:]
            right = [0]*27
            exp_num = 0
            sig = 1
            for si in stack:
                oi = ord(si)
                if A <= oi <= Z:
                    right[oi-A] += sig
                elif si.isdecimal():
                    exp_num = exp_num*10+int(si)
                    if exp_num >= mod:
                        exp_num %= mod
                elif si == "+" or si == "-":
                    res = right[26]+sig*exp_num
                    if res < 0 or res >= mod:
                        res %= mod
                    right[26] = res
                    if si == "+":
                        sig = 1
                    else:
                        sig = -1
            res = right[26]+sig*exp_num
            if res < 0 or res >= mod:
                res %= mod
            right[26] = res
            k = right[o-A]
            if k == 0:
                coef = [i%mod for i in right]
            else:
                c = (pow(k,for_count)-1)*pow(k-1,mod-2,mod)%mod if k != 1 else for_count%mod
                coef = [c*ci%mod if i+A != o else pow(k,for_count,mod) for i,ci in enumerate(right)]
            exp_num = 0
            for ci,vi in zip(coef,value):
                exp_num += ci*vi
                if exp_num >= mod:
                    exp_num %= mod
            value[o-A] = exp_num

    return print_lis

def main(n,m):
    print_s = solve(n)
    print_t = solve(m)
    if print_s == print_t:
        print("Yes")
    else:
        print("No")
    return


if __name__ == "__main__":
    while 1:
        n,m = LI()
        if n == m == 0:
            break
        main(n,m)


