#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

namespace geometry2d{
    const double EPS = 1e-10;

    int sgn(const double a){
        return (a < -EPS ? -1 : (a > EPS ? +1 : 0));
    }

    struct Point{
        double x, y;
        Point() = default;
        Point(double _x, double _y) : x(_x), y(_y){}

        double length() const {
            return std::sqrt(lengthSquare());
        }

        double lengthSquare() const {
            return x*x + y*y;
        }

        double dot(const Point &other) const {
            return this->x*other.x + this->y*other.y;
        }

        double cross(const Point &other) const {
            return x*other.y - y*other.x;
        }

        double distanceFrom(const Point &other) const {
            return (other-*this).length();
        }

        Point normalized() const {
            return *this/length();
        }

        Point normalUnitVector() const {
            return {-normalized().y, normalized().x};
        }

        bool isZero() const {
            return x == 0.0 && y == 0.0;
        }

        Point rotation(double arg) const {
            double cs = std::cos(arg), sn = std::sin(arg);
            return Point(x*cs - y*sn, x*sn+y*cs);
        }

        double angle() const {
            return std::atan2(y, x);
        }

        Point operator+() const {
            return *this;
        }

        Point operator-() const {
            return {-x, -y};
        }

        Point operator+(const Point &other) const {
            return {this->x+other.x, this->y+other.y};
        }

        Point operator-(const Point &other) const {
            return {this->x-other.x, this->y-other.y};
        }

        Point operator*(double s) const {
            return {x*s, y*s};
        }

        Point operator/(double s) const {
            return {x/s, y/s};
        }

        Point &operator+=(const Point &other) {
            this->x += other.x;
            this->y += other.y;
            return *this;
        }

        Point &operator-=(const Point &other) {
            this->x -= other.x;
            this->y -= other.y;
            return *this;
        }

        Point &operator*=(double s) {
            x *= s;
            y *= s;
            return *this;
        }

        Point &operator/=(double s) {
            x /= s;
            y /= s;
            return *this;
        }
    };

    inline Point operator*(double s, const Point &a) {
        return {a.x*s, a.y*s};
    }

    template <class Char>
    inline std::basic_ostream<Char> &operator<<(std::basic_ostream<Char> &os,
    const Point &a){
        return os << Char('(') << a.x << Char(',') << a.y << Char(')');
    }

    template <class Char>
    inline std::basic_istream<Char> &operator>>(std::basic_istream<Char> &is,
    const Point &a){
        Char unused;
        return is >> unused >> a.x >> unused >> a.y >> unused;
    }

    const Point error_val = { 114514.0, -191981.0 };

    inline bool operator==(const Point &a, const Point &b){
        return sgn(a.x-b.x) == 0 && sgn(a.y-b.y) == 0;
    }

    inline bool operator!=(const Point &a, const Point &b){
        return !(a == b);
    }

    inline bool operator<(const Point &a, const Point &b){
        if(sgn(a.x-b.x) != 0) return sgn(a.x-b.x) < 0;
        else return sgn(a.y-b.y) < 0;
    }

    int iSP(const Point &a, const Point &b, const Point &c){
        int flg = sgn((b-a).cross(c-a));
        if(flg == 1) return +1;
        else if(flg == -1) return -1;
        else{
            if(sgn((b-a).dot(c-b)) > 0) return +2;
            else if(sgn((a-b).dot(c-a)) > 0) return -2;
            else return 0;
        }
    }

    int angletype(const Point &a, const Point &b, const Point &c){
        auto v = (a-b).dot(c-b);
        if(sgn(v) > 0) return 0;
        else if(sgn(v) == 0) return 1;
        else return 2;
    }
}

int main(){
    using namespace geometry2d;
    int x0, y0, x1, y1;
    cin >> x0 >> y0 >> x1 >> y1;
    Point p0(x0, y0), p1(x1, y1);
    int q; cin >> q;
    while(q--){
        int x2, y2; cin >> x2 >> y2;
        Point p2(x2, y2);

        if(iSP(p1, p0, p2) == -1){
            cout << "COUNTER_CLOCKWISE";
        }else if(iSP(p1, p0, p2) == 1){
            cout << "CLOCKWISE";
        }else if(iSP(p1, p0, p2) == 2){
            cout << "ONLINE_BACK";
        }else if(iSP(p1, p0, p2) == -2){
            cout << "ONLINE_FRONT";
        }else{
            cout << "ON_SEGMENT";
        }
        cout << '\n';
    }
    return 0;
}
