#include <bits/stdc++.h>
using namespace std;

struct io_setup {
    io_setup() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout << fixed << setprecision(15);
    }
} io_setup;

template <typename T, bool directed = false>
struct Warshall_Floyd {
    vector<vector<T>> es;
    const T INF_T = numeric_limits<T>::max() / 2;
    const int n;

    inline const vector<T> &operator[](int k) const { return es[k]; }

    inline vector<T> &operator[](int k) { return es[k]; }

    Warshall_Floyd(int n) : es(n, vector<T>(n)), n(n) {
        for (int i = 0; i < n; i++) fill(begin(es[i]), end(es[i]), INF_T);
        for (int i = 0; i < n; i++) es[i][i] = 0;
    }

    void add_edge(int from, int to, T cost = 1) {
        es[from][to] = min(es[from][to], cost);
        if (!directed) es[to][from] = min(es[to][from], cost);
    }

    vector<vector<T>> shortest_path() {
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (es[i][k] == INF_T || es[k][j] == INF_T) continue;
                    es[i][j] = min(es[i][j], es[i][k] + es[k][j]);
                }
            }
        }
        return es;
    }
};

int main() {
    int V, E;
    cin >> V >> E;

    Warshall_Floyd<long long, true> G(V);

    for (int i = 0; i < E; i++) {
        int u, v;
        long long c;
        cin >> u >> v >> c;
        G.add_edge(u, v, c);
    }

    const long long INF = (1LL << 62) - 1;

    auto d = G.shortest_path();

    for (int i = 0; i < V; i++) {
        if (d[i][i] < 0) {
            cout << "NEGATIVE CYCLE\n";
            return 0;
        }
    }

    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (d[i][j] == INF) {
                cout << "INF" << (j == V - 1 ? '\n' : ' ');
            } else {
                cout << d[i][j] << (j == V - 1 ? '\n' : ' ');
            }
        }
    }
}
