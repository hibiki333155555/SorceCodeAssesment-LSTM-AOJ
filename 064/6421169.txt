#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> PP;
//#define MOD 1000000007
#define MOD 998244353
#define INF 2305843009213693951
//#define INF 810114514
#define PI 3.141592653589
#define setdouble setprecision
#define REP(i,n) for(ll i=0;i<(n);++i)
#define OREP(i,n) for(ll i=1;i<=(n);++i)
#define RREP(i,n) for(ll i=(n)-1;i>=0;--i)
#define ALL(v) (v).begin(), (v).end()
#define GOODBYE do { cout << "-1" << endl; return 0; } while (false)
#define MM <<" "<<
#define Endl endl
#define debug true
#define debug2 false



int main(void){
    
    cin.tie(nullptr);
    ios::sync_with_stdio(false);

    ll H,W;
    cin >> H >> W;
    vector<string> C(H);
    REP(i,H){cin >> C[i];}

    ll sy,sx,gy,gx;
    REP(i,H){
        REP(j,W){
            if(C[i][j]=='S'){
                sy=i;sx=j;
            }
            if(C[i][j]=='G'){
                gy=i;gx=j;
            }
        }
    }

    vector<vector<ll>> cost(H,vector<ll>(W,INF));
    deque<pair<ll,ll>> que;

    que.push_back({sy,sx});
    cost[sy][sx] = 0;

    ll dx[4] = {1,0,-1,0};
    ll dy[4] = {0,1,0,-1};

    while(!que.empty()){
        ll ty = que.front().first, tx = que.front().second;
        que.pop_front();

        if(C[ty][tx]=='U'){
            if(ty!=0 && cost[ty-1][tx]==INF && C[ty-1][tx]!='#'){
                cost[ty-1][tx] = cost[ty][tx];
                que.push_front({ty-1,tx});
            }
        }else if(C[ty][tx]=='D'){
            if(ty!=H-1 && cost[ty+1][tx]==INF && C[ty+1][tx]!='#'){
                cost[ty+1][tx] = cost[ty][tx];
                que.push_front({ty+1,tx});
            }
        }else if(C[ty][tx]=='L'){
            if(tx!=0 && cost[ty][tx-1]==INF && C[ty][tx-1]!='#'){
                cost[ty][tx-1] = cost[ty][tx];
                que.push_front({ty,tx-1});
            }
        }else if(C[ty][tx]=='R'){
            if(tx!=W-1 && cost[ty][tx+1]==INF && C[ty][tx+1]!='#'){
                cost[ty][tx+1] = cost[ty][tx];
                que.push_front({ty,tx+1});
            }
        }else{
            REP(k,4){
                ll y = ty+dy[k],x = tx+dx[k];
                if(!(0<=y && y<H))continue;
                if(!(0<=x && x<W))continue;
                if(cost[y][x]!=INF)continue;
                if(C[y][x]=='#')continue;

                cost[y][x] = cost[ty][tx]+1;
                que.push_back({y,x});
            }
        }

    }

    if(cost[gy][gx]==INF){
        cout << -1 << endl;
    }else{
        cout << cost[gy][gx] << endl;
    }

    /*REP(i,H){
        REP(j,W){
            if(cost[i][j]==INF){
                cout << "I" << " ";
            }else{
                cout << cost[i][j] << " ";
            }
        }cout << Endl;
    }*/

    return 0;
}

