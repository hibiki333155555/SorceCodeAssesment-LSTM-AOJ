#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
const int INF = 1e9;
const ll inf = 1LL<<62;

void solve() {
  int h, w; cin >> h >> w;
  int sx, sy, gx, gy;
  vector<string> G(h);
  for (int i=0; i<h; i++) {
    cin >> G[i];
    for (int j=0; j<w; j++) {
      if (G[i][j] == 'S') {
        sx = i;
        sy = j;
      }
      if (G[i][j] == 'V') {
        gx = i;
        gy = j;
      }
    }
  }
  int m; cin >> m;
  vector<vector<ll>> t(h, vector<ll>(w, inf));
  for (int i=0; i<m; i++) {
    int a, b; cin >> a >> b; a--; b--;
    cin >> t[a][b];
    t[a][b]--;
  }
  queue<vector<int>> q;
  q.push({sx, sy, 0});
  vector<vector<vector<int>>> d(2, vector<vector<int>>(h, vector<int>(w, -1)));
  d[0][sx][sy] = 0;
  vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
  while (q.size()) {
    auto now = q.front(); q.pop();
    int i = now[0], j = now[1];
    int state = now[2];
    for (int k=0; k<4; k++) {
      int nx = i + dx[k], ny = j + dy[k];
      if (0 <= nx && nx < h && 0 <= ny && ny < w && G[nx][ny] != '#') {
        if (d[state][i][j] >= t[nx][ny]) continue;
        if (G[nx][ny] == 'V' && state == 0) {
          q.push({nx, ny, 1});
          d[1][nx][ny] = d[0][i][j] + 1;
        } else {
          if (d[state][nx][ny] != -1) continue;
          d[state][nx][ny] = d[state][i][j] + 1;
          q.push({nx, ny, state});
        }
      }
    }
  }/*
  for (int i=0; i<h; i++) {
    for (int j=0; j<w; j++) {
      cout << d[0][i][j] << " ";
    }
    cout << endl;
  }
  for (int i=0; i<h; i++) {
    for (int j=0; j<w; j++) {
      cout << d[1][i][j] << " ";
    }
    cout << endl;
  }*/
  cout << (d[1][sx][sy] != -1 ? "Yes" : "No") << '\n';
}

int main() {
  ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  // int t; cin >> t;
  /*while (t--)*/ solve();
}

