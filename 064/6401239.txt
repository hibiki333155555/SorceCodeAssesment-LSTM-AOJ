#![allow(unused_imports)]
use std::cmp::*;
use std::collections::*;
use std::io::Write;
use std::ops::Bound::*;

#[allow(unused_macros)]
macro_rules! debug {
    ($($e:expr),*) => {
        #[cfg(debug_assertions)]
        $({
            let (e, mut err) = (stringify!($e), std::io::stderr());
            writeln!(err, "{} = {:?}", e, $e).unwrap()
        })*
    };
}

fn main() {
    let n = read::<usize>();

    let mut edges = vec![vec![]; n];
    for i in 0..n - 1 {
        let v = read_vec::<String>();
        let a = v[0].parse::<usize>().unwrap() - 1;
        let b = v[1].parse::<usize>().unwrap() - 1;
        let ch = v[2].chars().next().unwrap().to_digit(36).unwrap() as usize - 10;
        edges[a].push((b, ch));
        edges[b].push((a, ch));
    }

    let mut count = vec![0; n];
    dfs(0, 0, &edges, &mut count);
    let mut rev_count = HashMap::new();
    for cc in count {
        *rev_count.entry(cc).or_insert(0) += 1;
    }

    let mut ans = 0i64;
    let chl = 26;
    for (&k, &v) in &rev_count {
        for i in 0..chl {
            let key = (1 << i) ^ k;
            if rev_count.contains_key(&key) {
                ans += v * rev_count[&key];
            }
        }
    }
    ans /= 2;

    for (&k, &v) in &rev_count {
        ans += v * (v - 1) / 2;
    }

    println!("{}", ans);
}

fn dfs(cur: usize, parent: usize, edges: &Vec<Vec<(usize, usize)>>, count: &mut Vec<i32>) {
    for &(to, ch) in edges[cur].iter().filter(|&&x| x.0 != parent) {
        count[to] = count[parent] ^ (1 << ch);
        dfs(to, cur, edges, count);
    }
}

fn read<T: std::str::FromStr>() -> T {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    s.trim().parse().ok().unwrap()
}

fn read_vec<T: std::str::FromStr>() -> Vec<T> {
    read::<String>()
        .split_whitespace()
        .map(|e| e.parse().ok().unwrap())
        .collect()
}

