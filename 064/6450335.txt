#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)n; i++)
using ll = long long;
constexpr ll mod = 998244353;

struct mint {
  ll x;
  mint(ll _x = 0) {if((_x %= mod) < 0) _x += mod; x = _x;}
  bool operator==(const mint a) {return x == a.x;}
  mint operator-() const {return mint(-x);}
  mint& operator+=(const mint a) {
    if((x += a.x) >= mod) x -= mod;
    return *this;
  }
  mint& operator-=(const mint a) {
    if((x += mod-a.x) >= mod) x -= mod;
    return *this;
  }
  mint& operator*=(const mint a) {
    (x *= a.x) %= mod;
    return *this;
  }
  mint operator+(const mint a) const {
    mint res(*this);
    return res+=a;
  }
  mint operator-(const mint a) const {
    mint res(*this);
    return res-=a;
  }
  mint operator*(const mint a) const {
    mint res(*this);
    return res*=a;
  }
  mint pow(ll t) const {
    if(!t) return 1;
    mint a = pow(t>>1);
    a *= a;
    if(t&1) a *= *this;
    return a;
  }
  // for prime mod
  mint inv() const {return pow(mod-2);}
  mint& operator/=(const mint a) {return (*this) *= a.inv();}
  mint operator/(const mint a) const {
    mint res(*this);
    return res/=a;
  }
  ll val() {return x;}
};

int main(){
  int n, m;
  cin >> n >> m;
  vector<int> a(m);
  rep(i,m) cin >> a[i];
  vector<mint> dp(n+1), perm(n+1), permi(n+1);
  perm[0] = 1; permi[0] = 1;
  for(int i = 1; i <= n; i++) {
    perm[i] = perm[i-1]*mint(i);
    permi[i] = perm[i].inv();
  }
  dp[0] = 1;
  rep(i,m) {
    vector<mint> dpn(n+1);
    rep(j,n+1) dp[j] *= perm[n-j];
    for(int j = 1; j <= n; j++) dp[j] += dp[j-1];
    rep(j,n+1) {
      dpn[j] += dp[j];
      if(j-a[i]-1 >= 0) dpn[j] -= dp[j-a[i]-1];
      dpn[j] *= permi[n-j];
    }
    swap(dp,dpn);
  }
  cout << dp[n].val() << endl;
  return 0;
}

