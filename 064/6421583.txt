#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<pll> vpll;

#define FOR(i, a, b) for(ll i=(a); i<(b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define NREP(i, n) FOR(i, 1, n+1)

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

using SimpleGraph = vector<vector<ll>>;
struct Edge{
    ll to, cost;
    Edge(ll t, ll c) : to(t), cost(c) { }
};
using Graph = vector<vector<Edge>>;
struct Edge3{
    ll from, to, cost;
    Edge3(ll f, ll t, ll c) : from(f), to(t), cost(c) { }
};
using EdgeGraph = vector<vector<Edge3>>;

ll H, W;
bool isvalid(ll x, ll y) {
    if(0 <= x && x < H && 0 <= y && y < W) {return true;}
    else {return false;}
}

ll bert(ll x, ll y) {
    return (x * W + y);
}

const ll INF = 1e15;

int main(void){
    ll N; cin >> N;
    string S; cin >> S;
    string T = "";
    ll M = 2 * N - 1;
    REP(i, M) {
        if(i % 2 == 1) {T += '$';}
        else {T += S[i/2];}
    }
    
    vl R(M, 0);
    
    int i = 0, j = 0;
    while (i < T.length()) {
        while (i-j >= 0 && i+j < T.length() && T[i-j] == T[i+j]) ++j;
        R[i] = j;
        int k = 1;
        while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;
        i += k; j -= k;
    }
    
    vl L(M, 0);
    REP(i, M) {
        L[i] = min(i+1, M-i);
    }
    
    ll res = 0;
    REP(i, M) {
        if(i % 2 == 1 && L[i] == R[i]) {res++;}
    }
    cout << res << endl;
    
    
    return 0;
}
