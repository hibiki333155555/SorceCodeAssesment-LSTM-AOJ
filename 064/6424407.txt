#include<iostream>
#include<iomanip>
#include<cmath>
using namespace std;
#define EPS (1e-10)
#define equal(a,b) (fabs(a-b)<EPS)

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE = -1;
static const int ON_SEGMENT = 0;
static const int ONLINE_FRONT = 2;
static const int ONLINE_BACK = -2;
class Point {
public:
	double x, y;
	/*构造函数*/
	Point() {}
	Point(double x, double y) :x(x), y(y) {}
	/*针对加法的重载*/
	Point operator + (Point& p) { return Point(x + p.x, y + p.y); }
	Point operator - (Point& p) { return Point(x - p.x, y - p.y); }
	Point operator * (double a) { return Point(a * x, a * y); }
	Point operator / (double a) { return Point(x / a, y / a); }

	/*返回向量的模*/
	double abs() { return(sqrt(x * x + y * y)); }
};

/*写成大写防止和vector冲突*/
typedef Point Vector;

/*这里用Line表示线段*/
class Line {
public:
	Point p1, p2;
	Line() {}
	Line(Point p1, Point p2) :p1(p1), p2(p2) {}
	/*获取直线的方向向量*/
	Vector GetVector() { return Point(p2.x - p1.x, p2.y - p1.y); }
};

/*圆类*/
class Circule {
public:
	/*圆心*/
	Point c;
	/*半径*/
	double r;
	/*空构造函数*/
	Circule() {}
	/*方便构造临时变量*/
	Circule(Point c, double r) :c(c), r(r) {}
};
/*计算两个向量的内积*/
double dot(Vector v1, Vector v2)
{
	return v1.x * v2.x + v1.y * v2.y;
}

/*计算两个向量的外积 v1积v2*/
double cross(Vector v1, Vector v2)
{
	return v1.x * v2.y - v1.y * v2.x;
}

/*计算点到直线的距离*/
double PointToLint(Point p, Line l)
{
	Vector base = l.GetVector();
	double S = abs(cross(base, p - l.p1));
	return S / base.abs();
}

/*求点到点的距离*/
double PointToPoint(Point p1, Point p2)
{
	return (p2 - p1).abs();
}

void GetCross(Circule circule_one, Circule circule_two )
{
	double dis = PointToPoint(circule_one.c, circule_two.c);
	/*半径与交点构成的三角形交点所在的角的cos*/
	double co = -(pow(circule_one.r, 2) + pow(circule_two.r, 2) - pow(dis, 2)) / (2 * circule_one.r * circule_two.r);
	double alpha = asin(circule_two.r * sqrt(1 - pow(co, 2)) / dis);
	double t = atan((circule_two.c.y - circule_one.c.y) / (circule_two.c.x - circule_one.c.x));
	if(circule_two.c.x - circule_one.c.x<0)
		t=M_PI+t;
		
	Point p1(circule_one.c.x + circule_one.r * cos(t + alpha), circule_one.c.y + circule_one.r * sin(t + alpha));
	Point p2(circule_one.c.x + circule_one.r * cos(t - alpha), circule_one.c.y + circule_one.r * sin(t - alpha));
	cout << setiosflags(ios::fixed) << setprecision(8);
	if (p1.x < p2.x)
		cout << p1.x << " " << p1.y << " " << p2.x << " " << p2.y << endl;
	else if(p1.x>p2.x) 
		cout << p2.x << " " << p2.y << " " << p1.x << " " << p1.y << endl;
	else
	{
		if (p1.y < p2.y)
			cout << p1.x << " " << p1.y << " " << p2.x << " " << p2.y << endl;
		else
			cout << p2.x << " " << p2.y << " " << p1.x << " " << p1.y << endl;
	}
}

int main()
{
	Circule c1, c2;
	cin >> c1.c.x >> c1.c.y >> c1.r;
	cin >> c2.c.x >> c2.c.y >> c2.r;
	GetCross(c1, c2);
	return 0;
}
