#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstring>
using namespace std;
const int N=26;
//int st[N];
//a,b分别表示2个儿子，x表示兄弟 
//f表示父节点，deg表示儿子个数， 
//dep 表示深度，hei表示高度 
struct node{
	int c,a,b,f,deg,x;
}tree[N];

int dfs(int root)
{
	if(root == -1) return 0; 
	int l=0,r=0;
	l=dfs(tree[root].a);

	r=dfs(tree[root].b);
	return max(l,r)+1;
}
int ll=0;
int p[N];
int get_dep(int pos)
{
	int t = pos,cnt = 0;
	while(p[pos] != -1)
	{
		cnt ++;
		pos = p[pos];
	}
	return cnt;
}
int n;
int main()
{
	memset(p,-1,sizeof p);
	memset(tree,-1,sizeof tree);
	cin>>n;
	//scanf("%d",&n);
	//儿子数量deg不为0，且父亲不为-1时 为中间节点
	//st为0时是根节点 
	//儿子数量为0时是叶子节点 
	for(int i=0;i<n;i++)
	{
		tree[i].f=-1;
		tree[i].x=-1;
	}
	
	for(int i=0;i<n;i++)
	{
		int a,b,c;
		cin>>c>>a>>b;
		//if(tree[i]!=-1)
		//tree[i].f=-1;
		tree[i].deg =0;
		//tree[i].x=-1;
		tree[i] = {c,b,a};
		if(a!=-1)
		{
			tree[a].x =b;
			tree[i].deg+=1;
			tree[a].f=c;
			p[a] = c;
			//st[a]=1;
		}
		if(b!=-1)
		{
			tree[b].x =a;
			tree[i].deg+=1;
			tree[b].f=c;
			p[b] = c;
			//st[b]=1;
		}	
	}
	for(int i=0;i<n;i++)
	{
		if(tree[i].f!=-1&&tree[i].deg!=0)
		printf("node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, internal node\n",tree[i].c,tree[i].f ,tree[i].x ,tree[i].deg ,get_dep(tree[i].c) ,dfs(i));
		else if(tree[i].f!=-1&&tree[i].deg==0)
		printf("node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, leaf\n",tree[i].c,tree[i].f ,tree[i].x ,tree[i].deg ,get_dep(tree[i].c) ,dfs(i) );
		else if(tree[i].f==-1)
		printf("node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, root\n",tree[i].c,tree[i].f ,tree[i].x ,tree[i].deg ,get_dep(tree[i].c) ,dfs(i));
	}
	return 0;
 } 
