#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <exception>
#include <limits>
#include <cmath>

struct Point {
  double x, y;
};

double min_between(std::vector<Point>& pts, double min_lr, int bgn, int mid, int end) {
  auto comp_x_fn = [](const Point& lhs, const Point& rhs) {
    return lhs.x < rhs.x;
  };
  auto comp_y_fn = [](const Point& lhs, const Point& rhs) {
    return lhs.y < rhs.y;
  };
  std::sort(pts.begin() + bgn, pts.begin() + mid, comp_y_fn);
  std::sort(pts.begin() + mid, pts.begin() + end, comp_y_fn);
  double max_x_l = std::max_element(pts.begin()+bgn, pts.begin()+mid, comp_x_fn)->x;
  double min_x_r = std::min_element(pts.begin()+mid, pts.begin()+end, comp_x_fn)->x;
  double min_dist = std::numeric_limits<double>::max();
  for (int idx_l=bgn; idx_l<mid; idx_l++) {
    if (min_x_r - pts[idx_l].x >= min_lr) continue;
    auto lower = std::lower_bound(
      pts.begin()+mid, pts.begin()+end,
      pts[idx_l].y-min_lr, [](const Point& elem, double value) {
        return elem.y < value;
      }
    );
    for (int idx_r = std::distance(pts.begin(), lower); idx_r<end; idx_r++) {
      if (pts[idx_r].x - max_x_l >= min_lr) continue;
      if (pts[idx_r].y - pts[idx_l].y <= -1.0 * min_lr) continue;
      if (pts[idx_r].y - pts[idx_l].y >= min_lr) break;
      double dist = std::sqrt(
        std::pow(pts[idx_r].x - pts[idx_l].x, 2.0) +
        std::pow(pts[idx_r].y - pts[idx_l].y, 2.0)
      );
      if (dist < min_dist) min_dist = dist;
    }
  }
  return min_dist;
}

double min_distance(std::vector<Point>& pts, int bgn, int end) {
  if (end - bgn <= 0) {
    std::cerr << "Violated invariance: bgn < end" << std::endl;
    std::terminate();
  } else if (end - bgn == 1) {
    return std::numeric_limits<double>::max();
  } else {
    int mid = bgn + (end - bgn) / 2;
    double min_l = min_distance(pts, bgn, mid);
    double min_r = min_distance(pts, mid, end);
    double min_lr = std::min(min_l, min_r);
    double min_bet = min_between(pts, min_lr, bgn, mid, end);
    return std::min(min_lr, min_bet);
  }
}

int main() {
  int n; std::cin >> n;
  std::vector<Point> pts(n);
  for (int i=0; i<n; i++) std::cin >> pts[i].x >> pts[i].y;
  std::sort(pts.begin(), pts.end(), [](const Point& lhs, const Point& rhs) {
    return lhs.x < rhs.x;
  });
  std::cout << std::fixed << std::setprecision(7) << min_distance(pts, 0, n) << std::endl;;
}
