#ifndef CLASS_MODINT
#define CLASS_MODINT

#include <cstdint>

template <std::uint32_t mod>
class modint {
private:
	std::uint32_t n;
public:
	modint() : n(0) {};
	modint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};
	static constexpr std::uint32_t get_mod() { return mod; }
	std::uint32_t get() const { return n; }
	bool operator==(const modint& m) const { return n == m.n; }
	bool operator!=(const modint& m) const { return n != m.n; }
	modint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }
	modint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }
	modint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }
	modint operator+(const modint& m) const { return modint(*this) += m; }
	modint operator-(const modint& m) const { return modint(*this) -= m; }
	modint operator*(const modint& m) const { return modint(*this) *= m; }
	modint inv() const { return (*this).pow(mod - 2); }
	modint pow(std::uint64_t b) const {
		modint ans = 1, m = modint(*this);
		while (b) {
			if (b & 1) ans *= m;
			m *= m;
			b >>= 1;
		}
		return ans;
	}
};

#endif // CLASS_MODINT

#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;
using mint = modint<998244353>;

int main() {
	// step #1. read input
	cin.tie(0);
	ios_base::sync_with_stdio(false);
	int N;
	cin >> N;
	vector<vector<int> > G(N);
	for (int i = 0; i < N - 1; i++) {
		int a, b;
		cin >> a >> b; a--, b--;
		G[a].push_back(b);
		G[b].push_back(a);
	}
	int Q;
	cin >> Q;
	vector<int> X(Q), Y(Q);
	for (int i = 0; i < Q; i++) {
		cin >> X[i] >> Y[i];
		X[i]--, Y[i]--;
	}

	// step #2. Initialize Tree
	vector<int> par(N), depth(N);
	vector<mint> subpower(N), toppower(N);
	function<void(int, int)> make_tree = [&](int pos, int pre) {
		par[pos] = pre;
		subpower[pos] = 1;
		for (int i : G[pos]) {
			if (i != pre) {
				depth[i] = depth[pos] + 1;
				make_tree(i, pos);
				subpower[pos] += subpower[i] * 2;
			}
		}
	};
	make_tree(0, 0);

	// step #3. Top-down Tree DP
	function<void(int, int)> topdown = [&](int pos, int pre) {
		mint sum = 0;
		for (int i : G[pos]) {
			if (i != pre) {
				sum += subpower[i];
			}
		}
		for (int i : G[pos]) {
			if (i != pre) {
				toppower[i] = toppower[pos] * 2 + sum * 2 - subpower[i] * 2 + 1;
				topdown(i, pos);
			}
		}
	};
	topdown(0, 0);

	// step #4. doubling
	int bits = 0;
	while ((1 << bits) < N) {
		bits++;
	}
	vector<vector<int> > bpar(bits, vector<int>(N));
	bpar[0] = par;
	for (int i = 1; i < bits; i++) {
		for (int j = 0; j < N; j++) {
			bpar[i][j] = bpar[i - 1][bpar[i - 1][j]];
		}
	}

	// step #5. LCA
	function<int(int, int)> lca = [&](int va, int vb) {
		if (depth[va] < depth[vb]) {
			swap(va, vb);
		}
		for (int i = bits - 1; i >= 0; i--) {
			if (depth[va] - depth[vb] >= (1 << i)) {
				va = bpar[i][va];
			}
		}
		if (va == vb) {
			return va;
		}
		for (int i = bits - 1; i >= 0; i--) {
			if (bpar[i][va] != bpar[i][vb]) {
				va = bpar[i][va];
				vb = bpar[i][vb];
			}
		}
		return bpar[0][va];
	};

	// step #6. answer queries
	for (int i = 0; i < Q; i++) {
		if (depth[X[i]] < depth[Y[i]]) {
			swap(X[i], Y[i]);
		}
		mint answer;
		int V = lca(X[i], Y[i]);
		if (V == Y[i]) {
			int prevert = X[i];
			for (int j = bits - 1; j >= 0; j--) {
				if (depth[prevert] - depth[V] > (1 << j)) {
					prevert = bpar[j][prevert];
				}
			}
			answer = toppower[prevert] * subpower[X[i]] * mint(2).pow(depth[X[i]] - depth[Y[i]]);
		}
		else {
			answer = subpower[X[i]] * subpower[Y[i]] * mint(2).pow(depth[X[i]] + depth[Y[i]] - 2 * depth[V]);
		}
		cout << answer.get() << endl;
	}

	return 0;
}
