#include<iostream>
#include<vector>


struct SplayNode{
    SplayNode *parent;
    SplayNode *left;
    SplayNode *right;

    int Value;//値(普通、頂点には値や重みが割り当てられることが多い)

    int SubTeeSize = 1;//1は初期化値(自分自身)


    SplayNode(){
        parent = nullptr;
        left = nullptr;
        right = nullptr;
    }


    bool isExist(SplayNode *Nd){
        if(Nd!=nullptr)return true;
        else return false;
    } 



    /*
        ある地点を回転させる
    */
    void rotate(){

        SplayNode *Parent , *GrandParent , *Child;
        Parent = this->parent;
        GrandParent = Parent->parent;

        if(isExist(Parent) == false){
            return;
        }



        //元の親に対する位置で場合分け
        if(Parent->left == this){
            Child = this->right;//Childはnullptrかもしれない
            this->right = Parent;
            Parent->left = Child;

        }else if(Parent->right == this){
            Child = this->left;
            this->left = Parent;
            Parent->right = Child;

        }

        if(isExist(GrandParent)){
            //GrandParentのどちらの辺なのかで場合分け
            if(Parent == GrandParent->left){
                GrandParent->left = this;

            }else if(Parent == GrandParent->right){
                GrandParent->right = this;
                
            }
        }

        //GrandParentがnullptrの場合でも代入OK
        this->parent = GrandParent;


        //親と位置を入れ替えるので
        Parent->parent = this;



        //Childは移動するので。
        if(isExist(Child))Child->parent = Parent;


        /*
            Nodeの持つ情報をupdateしないといけないが、順番に注意！！
            ChildはChild以下の部分木が変化してないので何もしなくてOK
            GrandParentは、部分木の中の順番が変わったけど、集合としては変わってないので何もしなくてOK
            Parentと自分自身(this)は順番が変わって、部分木の内容も変わったので、
            下から　Parent　⇨  this の順番でupdateする
        */
        Parent->update();
        this->update();

        

        return;

    }







    /*
        自分の親から見た自分の位置
        0 -> 親がそもそもいない or 例外の場合
        1 -> 親から見て左の子の場合
        2 -> 親から見て右の子の場合 
    */
    int state(){
        if(isExist(this->parent)== false){
            return 0;
        }else{
            if(this->parent->left == this){
                return 1;
            }else if(this->parent->right == this){
                return 2;
            }else {
                return 0;
            }
        }
    }







    /*
        あるNodeを回転を駆使し一番上まで持っていく
        この時、回転する順番に注意
    */
    void splay(){
        while(isExist(this->parent)){
            if(isExist(this->parent->parent)==false){
                //(自分のGrandParentがいない場合、rotateは一回のみ)
                this->rotate();
                return;


            //それ以外の場合、(自分、親、親の親)の位置関係が大事
            }else if(this->state() == this->parent->state()){
                //GrandParentからの道が(右、右)or (左、左)の場合
                //GrandParentを一つ下に下ろして、自分を上げる
                this->parent->rotate();
                this->rotate();

            }else{
                //それ以外の場合、単純に自分を2回上に上げれば良い
                this->rotate();
                this->rotate();
            }
        }



        return;
    }   






    /*
        サイズなど、Nodeの持っている情報をupdateする(順番大事)
    */
    void update(){
        this->SubTeeSize = 1;

        if(isExist(this->left)){
            this->SubTeeSize += this->left->SubTeeSize;
        }

        if(isExist(this->right)){
            this->SubTeeSize += this->right->SubTeeSize;
        }

        return;
    }





};




class SplayTree{
    int Size;

    std::vector<SplayNode> Node;

    SplayTree(){

    }

    SplayTree(int size_){
        Size = size_+10;
        std::vector<SplayNode>(Size).swap(Node);
    }

    bool isExist(SplayNode *Nd){
        if(Nd==nullptr){
            return false;
        }else{
            return true;
        }
    }


    SplayNode *getNode(int index , SplayNode *root){

        SplayNode *now = root;

        while(1){

            int left_size = 0;
            if(isExist(now->left)){
                left_size = now->left->SubTeeSize;
            } 

            if(index < left_size){
                now = now->left;
            }else if(index == left_size){
                now->splay();
                break;
            }else if(index > left_size){
                now = now->right;
                index = index - left_size-1;
            }

        }

        return now;
    }



};


    SplayNode *getNode(int index , SplayNode *root){

        SplayNode *now = root;

        while(1){

            int left_size = 0;
   
            if(now->left!=nullptr){
                left_size = now->left->SubTeeSize;
            } 

            if(index < left_size){
             
                now = now->left;
            }else if(index == left_size){
        
                now->splay();
                break;      
            }else if(index > left_size){

                now = now->right;
                index = index - left_size - 1;
            }

        }

        return now;

    }





int main(){

    SplayNode V[200200];
    int n, q;
    std::cin >> q ;
    int Q = 0;
    int arr[q+10];
    for(int Q = 0 ; Q < q ; Q++){

        V[Q].parent = &V[Q+1];
        V[Q+1].left = &V[Q];
        V[Q].update();
    }
    SplayNode *root = &V[q];
    int size = 0;

    for(int i = 0 ; i < q; i++){
        int o;
        std::cin >> o;
        int x , y ;
        if(o == 0){
            std::cin >> x;
            root = getNode(size++ , root);
            root->Value = x;
        }else if(o == 1){
            std::cin >> x;
            root = getNode(x,root);
            
            std::cout << root->Value << std::endl;

        }else{
            size--;
        }
        
    }

    return 0;


}
