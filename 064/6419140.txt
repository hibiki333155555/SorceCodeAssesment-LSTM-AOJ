use std::collections::BTreeMap;

use mod_int::ModInt;
const MOD: i64 = 998244353;
fn main() {
    let (r, w) = (std::io::stdin(), std::io::stdout());
    let mut sc = IO::new(r.lock(), w.lock());

    loop {
        let n: usize = sc.read();
        let m: usize = sc.read();
        if n == 0 && m == 0 {
            break;
        }

        let mut s = Evaluator {
            memory: BTreeMap::new(),
            print: vec![],
        };
        for _ in 0..n {
            let line = sc.read::<String>();
            let statement = parse_line(&line);
            s.eval(&statement);
        }

        let mut t = Evaluator {
            memory: BTreeMap::new(),
            print: vec![],
        };
        for _ in 0..m {
            let line = sc.read::<String>();
            let statement = parse_line(&line);
            t.eval(&statement);
        }

        if s.print == t.print {
            println!("Yes");
        } else {
            println!("No");
        }
    }
}

struct Evaluator {
    memory: BTreeMap<char, ModInt>,
    print: Vec<(i64, i64)>,
}

impl Evaluator {
    fn eval(&mut self, statement: &Statement) {
        match statement {
            Statement::Declare { name } => {
                self.memory.insert(*name, ModInt::from(0i64));
            }
            Statement::Assign(assign) => {
                self.eval_assign(assign, 1);
            }
            Statement::Print(print) => {
                self.eval_print(print, 1);
            }
            Statement::For {
                for_elements,
                inner,
            } => {
                self.eval_for(for_elements, inner);
            }
        }
    }

    fn eval_expression(&self, expr: &Expression) -> ModInt {
        let mut sum = ModInt::from(0i64);
        for term in expr.terms.iter() {
            let prefix = term.0;
            match &term.1 {
                Term::Value(var) => {
                    let value = *self.memory.get(var).unwrap();
                    sum += value * prefix;
                }
                Term::Number(value) => {
                    sum += *value * prefix;
                }
            }
        }
        sum
    }

    fn eval_assign(&mut self, assign: &Assignment, count: i64) {
        if count == 0 {
            return;
        }

        let a0 = *self.memory.get(&assign.name).unwrap();
        let mut x = 0;
        let mut other_terms = vec![];
        for &(prefix, term) in assign.expr.terms.iter() {
            if let Term::Value(var) = term {
                if assign.name == var {
                    x += prefix;
                } else {
                    other_terms.push((prefix, term));
                }
            } else {
                other_terms.push((prefix, term));
            }
        }

        let expr = Expression { terms: other_terms };
        let y = self.eval_expression(&expr);
        if x == 1 {
            let new_value = a0 + y * count;
            self.memory.insert(assign.name, new_value);
            return;
        }
        if x == 0 {
            self.memory.insert(assign.name, y);
            return;
        }

        // a <- x * a + y
        let (x, xn) = if x < 0 {
            let x = ModInt::from(MOD + x);
            (x, x.pow(count))
        } else {
            assert!(x > 1);
            let x = ModInt::from(x);
            (x, x.pow(count))
        };
        let an = y * (xn - 1) / (x - 1) + a0 * xn;
        self.memory.insert(assign.name, an);
    }

    fn eval_print(&mut self, print: &Print, counts: i64) {
        if counts == 0 {
            return;
        }
        let result = self.eval_expression(&print.expr);
        let n = self.print.len();
        if !self.print.is_empty() && self.print[n - 1].0 == result.value() {
            self.print[n - 1].1 += counts;
        } else {
            self.print.push((result.value(), counts));
        }
    }

    fn eval_for(&mut self, loops: &[Expression], inner: &ForInner) {
        let mut loop_count = 1;
        for expr in loops {
            let result = self.eval_expression(expr);
            loop_count *= result.value();
        }

        match inner {
            ForInner::Assign(assign) => {
                self.eval_assign(assign, loop_count);
            }
            ForInner::Print(print) => {
                self.eval_print(print, loop_count);
            }
        }
    }
}

#[derive(Debug)]
enum Statement {
    Declare {
        name: char,
    },
    Assign(Assignment),
    Print(Print),
    For {
        for_elements: Vec<Expression>,
        inner: ForInner,
    },
}

#[derive(Debug)]
enum ForInner {
    Assign(Assignment),
    Print(Print),
}

#[derive(Debug)]
struct Assignment {
    name: char,
    expr: Expression,
}

#[derive(Debug)]
struct Print {
    expr: Expression,
}

#[derive(Debug, Clone)]
struct Expression {
    terms: Vec<(i64, Term)>,
}

#[derive(Debug, Clone, Copy)]
enum Term {
    Value(char),
    Number(ModInt),
}

fn parse_line(line: &str) -> Statement {
    if line.starts_with("for(") {
        // for
        let (mut elements, inner) = parse_for(line);
        elements.reverse();
        Statement::For {
            for_elements: elements,
            inner,
        }
    } else if line.starts_with("print(") {
        // print
        Statement::Print(parse_print(line))
    } else if line.contains("<-") {
        // assign
        Statement::Assign(parse_assignment(line))
    } else {
        // declare
        Statement::Declare {
            name: line.chars().next().unwrap(),
        }
    }
}

fn parse_print(line: &str) -> Print {
    let l = line.len();
    assert_eq!(&line[..6], "print(");
    assert_eq!(&line[(l - 1)..], ")");
    let expression = &line[6..(l - 1)];
    let expression = parse_expression(expression);
    Print { expr: expression }
}

fn parse_for(line: &str) -> (Vec<Expression>, ForInner) {
    if line.starts_with("for(") {
        let right = line.find(')').unwrap();
        let expression = &line[4..right];
        let expression = parse_expression(expression);

        let rest = &line[(right + 1)..];
        let (mut elements, inner) = parse_for(rest);
        elements.push(expression);
        (elements, inner)
    } else {
        let inner = parse_for_inner(line);
        (vec![], inner)
    }
}

fn parse_assignment(line: &str) -> Assignment {
    let value_name = line.chars().next().unwrap();
    assert_eq!(&line[1..3], "<-");
    let expression = &line[3..];

    Assignment {
        name: value_name,
        expr: parse_expression(expression),
    }
}

fn parse_for_inner(for_inner: &str) -> ForInner {
    if for_inner.starts_with("print(") {
        ForInner::Print(parse_print(for_inner))
    } else {
        ForInner::Assign(parse_assignment(for_inner))
    }
}

fn parse_expression(expression: &str) -> Expression {
    let mut q = expression.chars().collect::<Vec<_>>();
    if q[0] != '-' {
        q.insert(0, '+');
    }

    let mut terms = vec![];
    let mut buf = vec![];
    let mut prefix = 0;
    for c in q {
        if c != '+' && c != '-' {
            buf.push(c);
        } else {
            if !buf.is_empty() {
                let term = parse_term(buf);
                terms.push((prefix, term))
            }
            buf = vec![];
            prefix = if c == '+' { 1 } else { -1 };
        }
    }
    if !buf.is_empty() {
        let term = parse_term(buf);
        terms.push((prefix, term))
    }

    Expression { terms }
}

fn parse_term(buf: Vec<char>) -> Term {
    if 'a' <= buf[0] && buf[0] <= 'z' {
        assert_eq!(buf.len(), 1);
        Term::Value(buf[0])
    } else {
        let mut value = ModInt::from(0i64);
        for c in buf {
            let v = (c as u8 - '0' as u8) as i64;
            value = value * 10i64 + v;
        }
        Term::Number(value)
    }
}

pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);

impl<R: std::io::Read, W: std::io::Write> IO<R, W> {
    pub fn new(r: R, w: W) -> Self {
        Self(r, std::io::BufWriter::new(w))
    }
    pub fn write<S: ToString>(&mut self, s: S) {
        use std::io::Write;
        self.1.write_all(s.to_string().as_bytes()).unwrap();
    }
    pub fn read<T: std::str::FromStr>(&mut self) -> T {
        use std::io::Read;
        let buf = self
            .0
            .by_ref()
            .bytes()
            .map(|b| b.unwrap())
            .skip_while(|&b| b == b' ' || b == b'\n' || b == b'\r' || b == b'\t')
            .take_while(|&b| b != b' ' && b != b'\n' && b != b'\r' && b != b'\t')
            .collect::<Vec<_>>();
        unsafe { std::str::from_utf8_unchecked(&buf) }
            .parse()
            .ok()
            .expect("Parse error.")
    }
    pub fn usize0(&mut self) -> usize {
        self.read::<usize>() - 1
    }
    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {
        (0..n).map(|_| self.read()).collect()
    }
    pub fn chars(&mut self) -> Vec<char> {
        self.read::<String>().chars().collect()
    }
}
pub mod mod_int {
    type ModInternalNum = i64;
    thread_local!(
        static MOD: std::cell::RefCell<ModInternalNum> = std::cell::RefCell::new(0);
    );

    pub fn set_mod_int<T: ToInternalNum>(v: T) {
        MOD.with(|x| x.replace(v.to_internal_num()));
    }
    fn modulo() -> ModInternalNum {
        998244353
    }

    #[derive(Debug)]
    pub struct ModInt(ModInternalNum);
    impl Clone for ModInt {
        fn clone(&self) -> Self {
            Self(self.0)
        }
    }
    impl Copy for ModInt {}

    impl ModInt {
        fn internal_new(mut v: ModInternalNum) -> Self {
            let m = modulo();
            if v >= m {
                v %= m;
            }
            Self(v)
        }

        pub fn internal_pow(&self, mut e: ModInternalNum) -> Self {
            let mut result = 1;
            let mut cur = self.0;
            let modulo = modulo();
            while e > 0 {
                if e & 1 == 1 {
                    result *= cur;
                    result %= modulo;
                }
                e >>= 1;
                cur = (cur * cur) % modulo;
            }
            Self(result)
        }

        pub fn pow<T>(&self, e: T) -> Self
        where
            T: ToInternalNum,
        {
            self.internal_pow(e.to_internal_num())
        }

        pub fn value(&self) -> ModInternalNum {
            self.0
        }
    }

    pub trait ToInternalNum {
        fn to_internal_num(&self) -> ModInternalNum;
    }
    impl ToInternalNum for ModInt {
        fn to_internal_num(&self) -> ModInternalNum {
            self.0
        }
    }
    macro_rules! impl_primitive {
        ($primitive:ident) => {
            impl From<$primitive> for ModInt {
                fn from(v: $primitive) -> Self {
                    let v = v as ModInternalNum;
                    Self::internal_new(v)
                }
            }
            impl ToInternalNum for $primitive {
                fn to_internal_num(&self) -> ModInternalNum {
                    *self as ModInternalNum
                }
            }
        };
    }
    impl_primitive!(u8);
    impl_primitive!(u16);
    impl_primitive!(u32);
    impl_primitive!(u64);
    impl_primitive!(usize);
    impl_primitive!(i8);
    impl_primitive!(i16);
    impl_primitive!(i32);
    impl_primitive!(i64);
    impl_primitive!(isize);

    impl<T: ToInternalNum> std::ops::AddAssign<T> for ModInt {
        fn add_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }

            self.0 += rhs;
            if self.0 >= m {
                self.0 -= m;
            }
        }
    }

    impl<T: ToInternalNum> std::ops::Add<T> for ModInt {
        type Output = ModInt;
        fn add(self, rhs: T) -> Self::Output {
            let mut res = self;
            res += rhs;
            res
        }
    }
    impl<T: ToInternalNum> std::ops::SubAssign<T> for ModInt {
        fn sub_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            if rhs > 0 {
                self.0 += m - rhs;
            }
            if self.0 >= m {
                self.0 -= m;
            }
        }
    }
    impl<T: ToInternalNum> std::ops::Sub<T> for ModInt {
        type Output = Self;
        fn sub(self, rhs: T) -> Self::Output {
            let mut res = self;
            res -= rhs;
            res
        }
    }
    impl<T: ToInternalNum> std::ops::MulAssign<T> for ModInt {
        fn mul_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            self.0 *= rhs;
            self.0 %= m;
        }
    }
    impl<T: ToInternalNum> std::ops::Mul<T> for ModInt {
        type Output = Self;
        fn mul(self, rhs: T) -> Self::Output {
            let mut res = self;
            res *= rhs;
            res
        }
    }

    impl<T: ToInternalNum> std::ops::DivAssign<T> for ModInt {
        fn div_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            let inv = Self(rhs).internal_pow(m - 2);
            self.0 *= inv.value();
            self.0 %= m;
        }
    }

    impl<T: ToInternalNum> std::ops::Div<T> for ModInt {
        type Output = Self;
        fn div(self, rhs: T) -> Self::Output {
            let mut res = self;
            res /= rhs;
            res
        }
    }
}

