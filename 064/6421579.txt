#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

// g <- pair < v , cost > 
template < class T >
vector< T > dijkstra(vector<vector<pair<int, T>>> &graph, int s) {
    T INF = numeric_limits< T >::max();
    vector<T> dist(graph.size(), INF);
    priority_queue<pair<T,int>, vector<pair<T,int>>, greater<pair<T,int>>> q;
    q.push({dist[s] = T(0), s});
    while(!q.empty()){
        auto [uc, ui] = q.top(); q.pop();
        if(uc != dist[ui]) continue;
        for(auto [vi, vc] : graph[ui]) if(dist[vi] > uc + vc) 
            q.push({dist[vi] = uc + vc, vi});
    }
    return dist;
}

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    int H,W; cin >> H >> W;
    vector<string> C(H);
    rep(i,H) cin >> C[i];

    vector<vector<pair<int,int>>> G(H * W);
    auto f = [&](int i, int j) { return i * W + j; };
    int s = -1, g = -1;

    rep(i,H)rep(j,W) {
        if(C[i][j] == 'S') {
            s = f(i, j);
            C[i][j] = '.';
        }
        if(C[i][j] == 'G') {
            g = f(i, j);
            C[i][j] = '.';
        }
    }

    int dx[] = {0, 1, 0, -1};
    int dy[] = {1, 0, -1, 0};
    rep(i,H)rep(j,W) {
        if(C[i][j] == '#') continue;
        if(C[i][j] == '.') {
            rep(d,4) {
                int nx = i + dx[d], ny = j + dy[d];
                if(0 <= nx && nx < H && 0 <= ny && ny < W && C[nx][ny] != '#') {
                    G[f(i, j)].push_back({f(nx, ny), 1});
                }
            }
        }

        if(C[i][j] == 'R') {
            int nx = i, ny = j + 1;
            if(0 <= nx && nx < H && 0 <= ny && ny < W && C[nx][ny] != '#') {
                G[f(i, j)].push_back({f(nx, ny), 0});
            }
        }
        if(C[i][j] == 'L') {
            int nx = i, ny = j - 1;
            if(0 <= nx && nx < H && 0 <= ny && ny < W && C[nx][ny] != '#') {
                G[f(i, j)].push_back({f(nx, ny), 0});
            }
        }
        if(C[i][j] == 'U') {
            int nx = i - 1, ny = j;
            if(0 <= nx && nx < H && 0 <= ny && ny < W && C[nx][ny] != '#') {
                G[f(i, j)].push_back({f(nx, ny), 0});
            }
        }
        if(C[i][j] == 'D') {
            int nx = i + 1, ny = j;
            if(0 <= nx && nx < H && 0 <= ny && ny < W && C[nx][ny] != '#') {
                G[f(i, j)].push_back({f(nx, ny), 0});
            }
        }
    }

    auto dist = dijkstra<int>(G, s)[g];
    cout << (dist == numeric_limits<int>::max() ? -1 : dist) << endl;
}
