import sys
from collections import defaultdict
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(h, w, p):
    q = [[None]*h for i in range(w)]
    for i in range(h):
        for j in range(w):
            q[w-j-1][i] = p[i][j]
    return q

def solve():
    H, W = map(int, readline().split())
    if H == W == 0:
        return False
    G = [readline().strip() for i in range(H)]
    b0 = 0
    for i in range(H):
        for j in range(W):
            if G[i][j] == "#":
                b0 |= 1 << (i*W + j)
    b0 ^= (1 << (H*W))-1
    s0 = sum(e.count("#") for e in G)
    bmp = {}
    for i in range(H):
        for j in range(W):
            bmp[1 << (i*W + j)] = (i, j)
    N = int(readline())
    S = []
    P = []
    for k in range(N):
        h, w = map(int, readline().split())
        ds = set()
        p = [readline().strip() for i in range(h)]
        S.append(sum(e.count("#") for e in p))
        for t in range(4):
            b = 0
            for i in range(h):
                for j in range(w):
                    if p[i][j] == "#":
                        b |= 1 << (i*W + j)
            ds.add((h, w, b))
            p = rotate(h, w, p)
            h, w = w, h
        es = defaultdict(list)
        for h, w, b in ds:
            for y in range(H-h+1):
                for x in range(W-w+1):
                    b1 = b << (y*W + x)
                    if b1 & b0 != b1:
                        continue
                    es[y].append((x, b1))
        P.append(es)
    Q = int(readline())
    for i in range(Q):
        k, *ts = map(int, readline().split())
        if sum(S[t-1] for t in ts) + s0 != H*W:
            write("NO\n")
            continue
        A = (1 << k) - 1

        mp = [set() for i in range(1 << k)]
        def dfs(s, state):
            if s == A:
                return 1
            if state in mp[s]:
                return 0
            f = (state & -state)
            ey, ex = bmp[f]
            for i in range(k):
                if s & (1 << i):
                    continue
                for x, b in P[ts[i]-1][ey]:
                    if ex < x or (state & b) != b or (b & f) == 0:
                        continue
                    if dfs(s | (1 << i), state ^ b):
                        return 1
            mp[s].add(state)
            return 0
        if dfs(0, b0):
            write("YES\n")
        else:
            write("NO\n")
    return True
while solve():
    ...
