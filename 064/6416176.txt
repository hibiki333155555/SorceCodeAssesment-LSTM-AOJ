#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

template < class T, bool is_min > class CHT_add_monotone {
  public:
    using P = pair<T, T>;
    deque<P> H;

    CHT_add_monotone() {}

    bool empty() { return H.empty(); }

    void clear() { H.clear(); }

    int sgn(T x) { return x == 0 ? 0 : (x < 0 ? -1 : 1); }

    using D = long double;
    bool check(P &a, P &b, P &c) {
        if(a.second == b.second || b.second == c.second) return sgn(b.first - a.first) * sgn(c.second - b.second) >= sgn(c.first - b.first) * sgn(b.second - a.second);
        return D(b.first - a.first) * sgn(c.second - b.second) / D(abs(b.second - a.second)) >= D(c.first - b.first) * sgn(b.second - a.second) / D(abs(c.second - b.second));
    }

    void add(T a, T b) {
        if(!is_min) a *= -1, b *= -1;
        P line(a, b);
        if(empty()) {
            H.push_front(line);
            return;
        }

        if(H.front().first <= a) {
            if(H.front().first == a) {
                if(H.front().second <= b) return;
                H.pop_front();
            }
            while(H.size() >= 2 && check(line, H.front(), H[1])) H.pop_front();
            H.push_front(line);
        } else {
            assert(a <= H.back().first);
            if(H.back().first == a) {
                if(H.back().second <= b) return;
                H.pop_back();
            }
            while(H.size() >= 2 && check(H[H.size() - 2], H.back(), line)) H.pop_back();
            H.push_back(line);
        }
    }

    T get_y(P &a, T &x){ return a.first * x + a.second; }

    T query(T x) {
        assert(!empty());
        int l = -1, r = H.size() - 1;
        while(l + 1 < r) {
            int m = (l + r) / 2;
            if(get_y(H[m], x) >= get_y(H[m + 1], x)) l = m;
            else r = m;
        }
        return (is_min ? +1 : -1) * get_y(H[r], x);
    }

    T query_monotone_inc(T x) {
        assert(!empty());
        while(H.size() >= 2 && get_y(H.front(), x) >= get_y(H[1], x)) H.pop_front();
        return (is_min ? +1 : -1) * get_y(H.front(), x);
    }

    T query_monotone_dec(T x) {
        assert(!empty());
        while(H.size() >= 2 && get_y(H.front(), x) >= get_y(H[1], x)) H.pop_front();
        return (is_min ? +1 : -1) * get_y(H.front(), x);
    }
};

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    int n; cin >> n;
    vector<ll> a(n);
    rep(i,n) cin >> a[i];
    vector<pair<ll,ll>> p(n);
    for(auto &[x, y] : p) cin >> x >> y;

    rep(i,n) {
        ll ans = 0;
        vector<pair<ll,ll>> v;
        rep(j,n) if(j != i) {
            auto [xi, yi] = p[i];
            auto [xj, yj] = p[j];
            v.push_back({a[j] * (xj - xi), a[j] * (yj - yi)});
        }

        CHT_add_monotone<long double, true> cht_min;
        CHT_add_monotone<long double, false> cht_max;
        sort(v.begin(), v.end(), [&](auto L, auto R){ return L.first < R.first; });
        for(auto [x, y] : v) cht_min.add(x, y), cht_max.add(x, y);
        for(auto [x, y] : v) {
            ll cur = -1;
            if(x >= 0) {
                cur = llround(cht_max.query((long double)-1.0 * y / x) * x);
            } else {
                cur = llround(cht_min.query((long double)-1.0 * y / x) * x);
            }
            ans = max(ans, cur * a[i]);
        }

        cout << ans << endl;
    }
}

