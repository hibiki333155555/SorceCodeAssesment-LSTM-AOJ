

#[allow(unused_imports)]
use std::collections::HashMap;
#[allow(unused_imports)]
use std::collections::{VecDeque, BinaryHeap};
#[allow(unused_imports)]
use std::hash::Hash;
#[allow(unused_imports)]
use std::io::{BufWriter, Write};
#[allow(unused_imports)]
use std::iter::Sum;
#[allow(unused_imports)]
use std::ops::{Add, Div, Deref};
#[allow(unused_imports)]
use std::ops::Index;
#[allow(unused_imports)]
use std::ops::Mul;
#[allow(unused_imports)]
use std::ops::Sub;
#[allow(unused_imports)]
use std::ptr::NonNull;
#[allow(unused_imports)]
use std::str::FromStr;
#[allow(unused_imports)]
use std::{collections::BTreeMap, collections::BTreeSet, fs::read, ops::AddAssign, ops::Neg, ops::RangeInclusive, rc::Rc, vec};
#[allow(unused_imports)]
use std::cmp::{Ordering, Reverse};
#[allow(unused_imports)]
use std::fmt::Debug;
/*
use rand::{SeedableRng, Rng};
use rand::prelude::{StdRng, IteratorRandom};
*/

const PARSE_ERROR: &str = "Can't Parse";
const EOF_ERROR: &str = "No Line";
#[allow(unused_macros)]
macro_rules! freeze {
    ($($id:ident), *) => {
        $(let $id = $id;)*
    };
}
#[allow(unused_macros)]
macro_rules! read_line {
    () => {
        {
            let mut buffer = String::new();
            std::io::stdin().read_line(&mut buffer).expect(EOF_ERROR);
            buffer.trim().to_owned()
        }
    };
    (&mut $buffer: ident) => {
        {
            std::io::stdin().read_line(&mut $buffer).expect(EOF_ERROR);
            $buffer.trim().to_owned()
        }
    };
}
#[allow(unused_macros)]
macro_rules! show {
    () => {};
    ($tt:expr) => {
        println!("{} {} => {:?}", line!(), stringify!($tt), $tt);
    };
    ($tt:tt) => {
        println!("{} {} => {:?}", line!(), stringify!($tt), $tt);
    };
    ($head:expr, $($tail:expr)*) => {
        show!($head);
        show!($($tail)*);
    };
}
#[allow(unused_macros)]
macro_rules! read {
    () => {
        read_line!()
    };
    ([[char]; $size: expr]) => {
        (0 .. $size).into_iter().map(|_| read!([char])).collect::<Vec<_>>()
    };
    ([[usize1]; $size: expr]) => {
        (0 .. $size).into_iter().map(|_| read!([usize1])).collect::<Vec<_>>()
    };
    ([[$ty:ty]; $size: expr]) => {
        (0 .. $size).into_iter().map(|_| read!([$ty])).collect::<Vec<_>>()
    };
    ([usize1; $size: expr]) => {
        (0 .. $size).into_iter().map(|_| read!(usize1)).collect::<Vec<_>>()
    };
    ([$ty:ty; $size: expr]) => {
        (0 .. $size).into_iter().map(|_| read!($ty)).collect::<Vec<_>>()
    };
    ([$block: block; $size: expr]) => {
        (0 .. $size).into_iter().map(|_| read!($block)).collect::<Vec<_>>()
    };
    
    ([f64] ASC) => {
        {
            read!(mut vec: [f64]);
            vec.sort_by(|a, b| a.partial_cmp(b).unwrap());
            vec
        }
    };
    ([f64; $len: expr] ASC) => {
        {
            read!(mut vec: [f64; $len]);
            vec.sort_by(|a, b| a.partial_cmp(b).unwrap());
            vec
        }
    };
    ([$($tt: tt)*] ASC) => {
        {
            read!(mut vec: [$($tt)*]);
            vec.sort();
            vec
        }
    };
    ([f64] DESC) => {
        {
            read!(mut vec: [f64]);
            vec.sort_by(|a, b| a.partial_cmp(b).unwrap().reverse());
            vec
        }
    };
    ([f64; $len: expr] DESC) => {
        {
            read!(mut vec: [f64; $len]);
            vec.sort_by(|a, b| a.partial_cmp(b).unwrap().reverse());
            vec
        }
    };
    ([$($tt: tt)*] DESC) => {
        {
            read!(mut vec: [$($tt)*]);
            vec.sort_by_key(|&v| Reverse(v));
            vec
        }
    };
    ([char]) => {
        read_line!().chars().collect::<Vec<_>>()
    };
    ([String]) => {
        read_line!().split_whitespace().map(|s| s.to_owned()).collect::<Vec<String>>()
    };
    ([usize1]) => {
        read_line!().split_whitespace().map(|x| x.parse::<usize>().ok().expect(PARSE_ERROR) - 1).collect::<Vec<usize>>()
    };
    ([$ty: ty]) => {
        read_line!().split_whitespace().map(|x| x.parse().ok().expect(PARSE_ERROR)).collect::<Vec<$ty>>()
    };
    (usize1) => {
        read_line!().parse::<usize>().ok().expect(PARSE_ERROR) - 1
    };
    ($ty: ty) => {
        read_line!().parse::<$ty>().ok().expect(PARSE_ERROR)
    };
    ($block: block) => {
        $block
    };
    ($ident: ident: [$($tt:tt)*]) => {
        let $ident = read!([$($tt)*]);
    };
    (mut $ident: ident: [$($tt:tt)*]) => {
        let mut $ident = read!([$($tt)*]);
    };
    ($ident: ident: [$($tt:tt)*] ASC) => {
        let $ident = read!([$($tt)*] ASC);
    };
    ($ident: ident: [$($tt:tt)*] DESC) => {
        let $ident = read!([$($tt)*] DESC);
    };
    ($ident: ident: String) => {
        let $ident = read!();
    };
    (mut $ident: ident: String) => {
        let mut $ident = read!();
    };
    ($ident: ident: $ty: ty) => {
        let $ident = read_line!().parse::<$ty>().unwrap();
    };
    (mut $ident: ident: $ty: ty) => {
        let mut $ident = read_line!().parse::<$ty>().unwrap();
    };
    ($($token: tt)*) => {
        let line = read_line!();
        let mut iter = line.split_whitespace().into_iter();
        read_from_iter!(iter; $($token)*);
    };
}
#[allow(unused_macros)]
macro_rules! read_from_iter {
    ($iter:expr; mut $ident:ident:usize1, $($rest:tt)*) => {
        let mut $ident = $iter.next().unwrap().parse::<usize>().expect(PARSE_ERROR) - 1;
        read_from_iter!($iter; $($rest)*);
    };
    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {
        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(PARSE_ERROR);
        read_from_iter!($iter; $($rest)*);
    };
    ($iter:expr; $ident:ident:usize1, $($rest:tt)*) => {
        let $ident = $iter.next().unwrap().parse::<usize>().expect(PARSE_ERROR) - 1;
        read_from_iter!($iter; $($rest)*);
    };
    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {
        let $ident = $iter.next().unwrap().parse::<$ty>().expect(PARSE_ERROR);
        read_from_iter!($iter; $($rest)*);
    };
    ($iter:expr; mut $ident:ident:usize1) => {
        let mut $ident = $iter.next().unwrap().parse::<usize>().expect(PARSE_ERROR) - 1;
    };
    ($iter:expr; mut $ident:ident:$ty:ty) => {
        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(PARSE_ERROR);
    };
    ($iter:expr; $ident:ident:usize1) => {
        let $ident = $iter.next().unwrap().parse::<usize>().expect(PARSE_ERROR) - 1;
    };
    ($iter:expr; $ident:ident:$ty:ty) => {
        let $ident = $iter.next().unwrap().parse::<$ty>().expect(PARSE_ERROR);
    };
    ($iter: expr; ) => {};
}
#[allow(dead_code)]
struct KeyValue<K, V> {
    key: K,
    value: V
}
impl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {
    fn eq(&self, other: &Self) -> bool {
        self.key.eq(&other.key)
    }
}
impl <K: PartialOrd, V> Eq for KeyValue<K, V> {}
impl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.key.partial_cmp(&other.key)
    }
}
impl <K: PartialOrd, V> Ord for KeyValue<K, V> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.key.partial_cmp(&other.key).ok_or("Can't Compare").unwrap()
    }
}
pub struct Convolution {
    modulo: u64,
    sum_e: [u64; 30],
    sum_ie: [u64; 30],
}
fn ceil_pow2(n: usize) -> usize {
    let mut result = 0;
    while (1 << result) < n {result += 1;}
    result
}
fn number_of_trailing_zeros(n: usize) -> usize {
    if n == 0 {return 64;}
    let mut mrb = n & (!n + 1);
    let mut result = 0;
    for d in &[32, 16, 8, 4, 2] {
        if mrb >= 1 << d {
            result += d;
            mrb >>= d;
        }
    }
    result + (mrb >> 1)
}
fn inverse(z: u64, modulo: u64) -> u64 {
    pow_mod(z, modulo - 2, modulo)
}
fn inv_gcd(a: u64, b: u64) -> (u64, u64) {
    if b == 0 {return (1, 0);}
    let q = a / b;
    let r = a % b;
    let (x, y) = inv_gcd(b, r);
    (b - y, (a * 2 - x - q * y) % a)
}
fn primitive_root(modulo: u64) -> u64 {
    if modulo == 998244353 {
        3
    }else if modulo == 2 {
        1
    }else if modulo == 167772161 {
        3
    }else if modulo == 469762049 {
        3
    }else if modulo == 754974721 {
        11
    }else {
        let mut divs = [0; 20];
        divs[0] = 2;
        let mut cnt = 1;
        let mut x = (modulo - 1) / 2;
        while x % 2 == 0 {x >>= 1;}
        let mut i = 3;
        while i * i <= x {
            if x % i == 0 {
                divs[cnt] = i;
                cnt += 1;
                while x % i == 0 {
                    x /= i;
                }
            }
            i += 2;
        }
        if x > 1 {
            divs[cnt] = x;
            cnt += 1;
        }
        let mut g = 2;
        loop {
            let mut ok = true;
            for i in 0 .. cnt {
                if pow_mod(g, (modulo - 1) / divs[i], modulo) == 1 {
                    ok = false;
                    break;
                }
            }
            if ok {break;}
            g += 1;
        }
        g
    }

}
fn pow_mod(base: u64, exp: u64, modulo: u64) -> u64 {
    let mut result = 1u64;
    let mut b = base % modulo;
    let mut e = exp;
    while e > 0 {
        if e & 1 == 1 {
            result = result * b % modulo;
        }
        e >>= 1;
        b = b * b % modulo;
    }
    result
}
impl Convolution {
    pub fn new(modulo: u64) -> Convolution {
        let mut es = [0u64; 30];
        let mut ies = [0u64; 30];
        let cnt = number_of_trailing_zeros((modulo - 1) as usize);
        let root = primitive_root(modulo);
        let base = pow_mod(root, (modulo - 1) >> cnt, modulo);
        let mut e = base;
        let mut ie = inverse(base, modulo);
        for i in (2 ..= cnt).rev() {
            es[i - 2] = e;
            ies[i - 2] = ie;
            e = e * e % modulo;
            ie = ie * ie % modulo;
        }
        e = 1;
        ie = 1;
        let mut sum_e = [0u64; 30];
        let mut sum_ie = [0u64; 30];
        if cnt >= 2 {
            for i in 0 .. cnt - 2 {
                sum_e[i] = es[i] * e % modulo;
                sum_ie[i] = ies[i] * ie % modulo;
                e = e * ies[i] % modulo;
                ie = ie * es[i] % modulo;
            }
        }
        Convolution{modulo, sum_e, sum_ie}
    }
    pub fn convolution(&self, a: &Vec<u64>, b: &Vec<u64>) -> Vec<u64> {
        let modulo = self.modulo;
        let n = a.len();
        let m = b.len();
        if n == 0 || m == 0 {return Vec::new();}
        let z = 1 << ceil_pow2(n + m - 1);
        let mut ra = vec![0u64; z];
        let mut rb = vec![0u64; z];
        for i in 0 .. n {
            ra[i] = a[i];
        }
        for i in 0 .. m {
            rb[i] = b[i];
        }
        self.butterfly(&mut ra);
        self.butterfly(&mut rb);
        for i in 0 .. z {
            ra[i] = ra[i] * rb[i] % modulo;
        }
        self.butterfly_inverse(&mut ra);
        ra.resize(n + m - 1, 0u64);
        let inverse_z = inverse(z as u64, modulo);
        for i in 0 .. n + m - 1 {
            ra[i] = ra[i] * inverse_z % modulo;
        }
        ra
    }
    fn butterfly(&self, a: &mut Vec<u64>) {
        let modulo = self.modulo;
        let n = a.len();
        let h = ceil_pow2(n);
        let se = &self.sum_e;
        for ph in 1 ..= h {
            let w = 1 << (ph - 1);
            let p = 1 << (h - ph);
            let mut now = 1u64;
            for s in 0 .. w {
                let offset = s << (h - ph + 1);
                for i in 0 .. p {
                    let left = a[i + offset];
                    let right = a[i + offset + p] * now % modulo;
                    a[i + offset] = (left + right) % modulo;
                    a[i + offset + p] = (left + modulo - right) % modulo;
                }
                now = now * se[number_of_trailing_zeros(!s)] % modulo;
            }
        }
    }
    fn butterfly_inverse(&self, a: &mut Vec<u64>) {
        let modulo = self.modulo;
        let n = a.len();
        let h = ceil_pow2(n);
        let sie = &self.sum_ie;
        for ph in (1 ..= h).rev() {
            let w = 1 << (ph - 1);
            let p = 1 << (h - ph);
            let mut now = 1u64;
            for s in 0 .. w {
                let offset = s << (h - ph + 1);
                for i in 0 .. p {
                    let left = a[i + offset];
                    let right = a[i + offset + p];
                    a[i + offset] = (left + right) % modulo;
                    a[i + offset + p] = now * (left + modulo - right) % modulo;
                }
                now = now * sie[number_of_trailing_zeros(!s)] % modulo;
            }
        }
    }
}
const MOD: u64 = 998244353;
fn main() {
    read!(n: usize, k: usize);
    read!(score: [usize]);
    read!(parent: [usize]);
    let convolution = Convolution::new(MOD);
    let mut graph = vec![Vec::<usize>::new(); n];
    for i in 1 .. n {
        graph[parent[i - 1] - 1].push(i);
    }
    let mut queue = VecDeque::new();
    let mut history = Vec::with_capacity(n);
    queue.push_back(0);
    while let Some(top) = queue.pop_front() {
        history.push(top);
        for &child in &graph[top] {
            queue.push_back(child);            
        }
    }
    history.reverse();
    let mut pattern = vec![Vec::<u64>::new(); n];
    for v in history {
        let mut count = vec![0u64; k + 1];
        count[0] += 1;
        if score[v] <= k {
            count[score[v]] += 1;
        }
        for &child in &graph[v] {
            let mut merged = convolution.convolution(&count, &pattern[child]);
            merged.resize(k + 1, 0);
            count = merged;
        }
        pattern[v] = count;
    }
    println!("{}", pattern[0][k]);
}
