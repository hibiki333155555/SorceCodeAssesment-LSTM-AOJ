#!/usr/bin/env python3
import sys
import math
from functools import lru_cache
from heapq import heappush, heappop, heappushpop
from itertools import permutations
from operator import itemgetter, le
from collections import deque
from collections import Counter
from itertools import accumulate
from collections import defaultdict
from bisect import bisect_right as br
from bisect import bisect_left as bl
sys.setrecursionlimit(2147483647)
mod = 10**9 + 7
inf = float('inf')
input=lambda: sys.stdin.readline().rstrip("\r\n")
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))

def dfs(v, p, d):
    global nuts, can
    if d == 10**5:
        return
    for u in edges[v]:
        if u == p: 
            continue
        if nuts[u]:
            for t in edges[u]:
                if t == v: 
                    continue
                if not nuts[t]:
                    nuts[t], nuts[u] = True, False
                    can[u] = True
                    dfs(u, v, d+1)
                    nuts[t], nuts[u] = False, True
        else:
            can[u] = True
            dfs(u, v, d+1)
    return

n, m = LI()
edges = [[] for _ in range(n)]
for _ in range(n-1):
    x, y = LI()
    edges[x-1].append(y-1)
    edges[y-1].append(x-1)

nuts = [False] * n
can = [False] * n
depth = 0
for _ in range(m):
    a = I()
    nuts[a-1] = True
can[0] = True
dfs(0, -1, 0)
print(sum(can))

