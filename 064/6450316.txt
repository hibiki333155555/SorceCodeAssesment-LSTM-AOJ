#include <bits/stdc++.h>
using namespace std;
#pragma region template
#define rep(i,n) for(ll i=0;i<n;i++)
#define repl(i,l,r) for(ll i=(l);i<(r);i++)
#define per(i,n) for(ll i=n-1;i>=0;i--)
#define perl(i,r,l) for(ll i=r-1;i>=l;i--)
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define ins insert
#define all(x) (x).begin(),(x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define popcount(x) __builtin_popcountll(x)
using ll = long long;
using vl = vector<ll>;
using vvl = vector<vector<ll>>;
using Graph = vector<vector<ll>>;
using P = pair<ll, ll>;
const ll MOD = 1000000007;
const ll MOD9 = 998244353;
const int inf = 1e9+10;
const ll INF = 4e18;
const ll dy[8] = {1,0,-1,0,1,1,-1,-1};
const ll dx[8] = {0,-1,0,1,1,-1,1,-1};
const double PI = 3.14159265358979323846;
template <class T> using V = vector<T>;
template<class T, class K>bool chmax(T &a, const K b) { if (a<b) { a=b; return 1; } return 0; }
template<class T, class K>bool chmin(T &a, const K b) { if (b<a) { a=b; return 1; } return 0; }
ll power(ll a, ll p){ll ret = 1; while(p){if(p & 1){ret = ret * a;} a = a * a; p >>= 1;} return ret;}
ll modpow(ll a, ll p, ll mod){ll ret = 1; while(p){if(p & 1){ret = ret * a % mod;} a = a * a % mod; p >>= 1;} return ret;}
ll modinv(ll a, ll m) {ll b = m, u = 1, v = 0; while (b) {ll t = a / b ;a -= t * b; swap(a, b);u -= t * v; swap(u, v);}u %= m;if (u < 0) u += m;return u;}
#ifdef LOCAL_
#define debug(var)  do{std::cerr << #var << " : ";view(var);}while(0)
template<typename T> void view(T e){std::cerr << e << std::endl;}
template<typename T, typename K> void view(std::pair<T, K> e){std::cerr << "(" <<e.fi << ", " << e.se << ")" << std::endl;}
template<typename T> void view(std::set<T> &st){ for(const auto& e : st){std::cerr << e << " ";} std::cerr << std::endl;}
template<typename T, typename K> void view(std::map<T, K> &mp){ for(const auto& [k, v]: mp){std::cerr << "(" << k << ", " << v << ")" << std::endl;}}
template<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cerr << e << " "; } std::cerr << std::endl;}
template<typename T> void view(const std::vector<std::vector<T> >& vv){cerr << endl;int cnt = 0;for(const auto& v : vv){cerr << cnt << "th : "; view(v); cnt++;} cerr << endl;}
#else
#define debug(...) (void(0))
#endif
#pragma endregion
//////////////////////////////////////////////////////////

struct edge {
    int to;
    ll c;
};



int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    //cout << fixed << setprecision(20);

    int n, m;
    cin >> n >> m;
    vector<vector<edge>> g(n);
    rep(i,m) {
        int aa, bb, cc;
        cin >> aa >> bb >> cc;
        --aa;--bb;
        g[aa].push_back(edge{bb, cc});
        // g[bb].push_back(edge{aa, cc});
    }


    set<ll> st;
    for (int bit = 0;bit < (1 << 20); bit++) {
        ll c = 1;
        for (int i = 0;i < 20; i++) {
            if (bit >> i & 1) c = lcm(c, i+1);
        }
        st.insert(c);
    }
    vector<ll> vec;
    vec.reserve(1000);

    for (auto x: st) {
        vec.push_back(x);
    }
    map<ll, ll> vecinv;
    rep(i, (int)vec.size()) vecinv[vec[i]] = i;

    vector<vector<int>> G(n * (int)st.size());

    for (int i = 0;i < n; i++) {
        for (int j = 0;j < (int)vec.size(); j++) {
            for (auto [to, c] : g[i]) {
                ll x = vecinv[lcm(c, vec[j])];
                G[i + j*n].push_back(to + x*n);
            }
        }
    }

    vector<ll> seen(G.size(), 0);
    auto dfs = [&](auto&& dfs, int x) -> void {
        if (seen[x]) return;
        seen[x] = 1;
        for (int to:G[x]) {
            dfs(dfs, to);
        }
        return;
    };
    dfs(dfs, 0 + 0*n);

    // debug(vec);debug(vecinv);
    // for (int i = 0;i < n; i++) {
    //     for (int j = 0;j < 20; j++) {
    //         cout << i << " " << vec[j] << " " << seen[i+j*n] << "   ";
    //     }
    //     cout << endl;
    // }
    // cout << endl;


    ll mn = INF, mx = -INF;
    for (int j = 0;j < (int)vec.size(); j++) {
        if (seen[n-1 + j*n]) {
            chmin(mn, vec[j]);
            chmax(mx, vec[j]);
        }
    }

    if (mn == INF && mx == -INF) {
        cout << "IMPOSSIBLE" << endl;
    } else {
        cout << mn << " " << mx << endl;
    }




    return 0;
}
