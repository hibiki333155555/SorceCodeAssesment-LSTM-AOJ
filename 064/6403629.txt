#include <iostream>
#include <queue>

using namespace std;
const int N = 100;
const int INFTY = (1 << 21);

int n;
int M[N][N];
int d[N];// 距離でカラーを管理

void bfs( int s)
{
    queue<int> q;
    q.push(s);
    for( int i = 0; i < n; i++) d[i] = INFTY;
    d[s] = 0;
    int u;
    while( !q.empty())
    {
        u = q.front();// キューの先頭を取得
        q.pop();// キューの先頭を消去
        for( int v = 0; v < n; v++)
        {// 隣接ノードかどうか検索
            // 隣接ノードでないなら、次のノードへ
            if( M[u][v] == 0) continue;
            // 隣接ノードかつすでに距離計算済み（初期値INFTYでない）なら次のノードへ
            if( d[v] != INFTY) continue;
            // 隣接ノードかつ距離計算済みでないなら、元ノードとノード１の距離＋１を距離に格納
            d[v] = d[u] + 1;
            
            // 隣接ノードをキューに格納
            // 隣接ノードの距離が全て格納終了したら、
            // その隣接ノードを元ノードとしてループを進めることができる
            q.push(v);
        }
    }
    // ノード番号とノード１からの距離を出力
    for( int i = 0; i < n; i++)
    {
        cout << i+1 << " " << ((d[i] == INFTY) ? (-1) : d[i]) << endl;
    }
}

int main()
{
    int u, k, v;
    
    cin >> n;
    // 初期化
    for(int i = 0; i < n; i++)
    {
        for( int j = 0; j < n; j++) M[i][j] = 0;
    }
    //　いつも通り隣接ノード番号を行列に格納
    for( int i = 0; i < n; i++)
    {
        cin >> u >> k;
        u--;// ノード番号は１から始まるので
        for( int j = 0; j < k; j++)
        {
            cin >> v;
            v--;// ノード番号は１から始まるので
            M[u][v] = 1;
        }
    }
    
    // ノード番号とノード１からの距離を出力
    bfs(0);
    return 0;
}
