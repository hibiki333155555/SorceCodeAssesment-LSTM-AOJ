from heapq import heapify, heappop, heappush, heappushpop

INF = float('inf')


class dijkstra:
    def __init__(self, n, edges):
        self.n = n  # ノード数
        self.edges = edges  # 有向グラフ
        self.prev = [-1] * n  # 前のノード

    def build(self, start):
        self.dist = [INF] * self.n
        self.dist[start] = 0
        next_q = [(0, start)]
        heapify(next_q)
        while next_q:
            cd, cn = heappop(next_q)
            if self.dist[cn] < cd: continue
            for nn, nd in self.edges[cn]:
                nd_ = self.dist[cn] + nd
                if self.dist[nn] <= nd_: continue
                self.dist[nn] = nd_
                self.prev[nn] = cn
                heappush(next_q, (nd_, nn))
        return self.dist

    def shortest_distance(self, goal):
        return self.dist[goal]

    def shortest_path(self, goal):
        path = []
        node = goal
        while node is not None:
            path.append(node)
            node = self.prev[node]
        return path[::-1]


##########################################


H, W = map(int, input().split())
C = [input() for _ in range(H)]
G = [[] for _ in range(H * W)]
dh = (-1, 1, 0, 0)
dw = (0, 0, -1, 1)
sh, sw = -1, -1
gh, gw = -1, -1
for h in range(H):
    for w in range(W):
        if C[h][w] == '#':
            continue
        if C[h][w] == 'S':
            sh, sw = h, w
        if C[h][w] == 'G':
            gh, gw = h, w
        for i in range(4):
            nh = h + dh[i]
            nw = w + dw[i]
            if 0 <= nh < H and 0 <= nw < W:
                if C[nh][nw] == '#':
                    continue
                if C[h][w] == 'U' and nh - h == -1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] == 'D' and nh - h == 1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] == 'L' and nw - w == -1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] == 'R' and nw - w == 1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] in {'.', 'S', 'G'}:
                    G[nh * W + nw].append((h * W + w, 1))

dijF = dijkstra(W * H, G)
F = dijF.build(gh*W+gw)
ans = F[sh*W+sw]
if ans == float('inf'):
    print(-1)
else:
    print(ans)
