#include <bits/stdc++.h>

#pragma region snippet
// prefix: rangeaddbinaryindexedtree

template <typename T>
struct RangeAddBinaryIndexedTree {
   public:
    RangeAddBinaryIndexedTree(int n) {
        assert(0 <= n && n <= 1e7);
        _n = n + 1;
        data[0].assign(_n, 0);
        data[1].assign(_n, 0);
    }

    void add(int i, T val) {
        assert(0 <= i && i < _n - 1);
        add(i, i + 1, val);
    }
    void add(int l, int r, T val) {
        assert(0 <= l && l < _n - 1);
        assert(0 < r && r < _n);
        l++;
        r++;
        add_sub(0, l, -val * (l - 1));
        add_sub(0, r, val * (r - 1));
        add_sub(1, l, val);
        add_sub(1, r, -val);
    }

    T sum(int i) {
        assert(0 <= i && i < _n);
        return sum_sub(0, i) + sum_sub(1, i) * i;
    }

    T get(int i) {
        assert(0 <= i && i < _n - 1);
        return sum(i + 1) - sum(i);
    }

    void show() {
        for (int i = 0; i < _n - 1; i++) {
            std::cout << get(i) << " ";
        }
        std::cout << std::endl;
    }

    int size() { return _n - 1; }

   private:
    int _n;
    std::vector<T> data[2];
    void add_sub(int p, int i, T val) {
        for (int idx = i; idx < _n; idx += (idx & -idx)) {
            data[p][idx] += val;
        }
    }
    T sum_sub(int p, int i) {
        T res = 0;
        for (int idx = i; idx > 0; idx -= (idx & -idx)) {
            res += data[p][idx];
        }
        return res;
    }
};

#pragma endregion

using namespace std;
int main() {
    int N, Q;
    cin >> N >> Q;
    RangeAddBinaryIndexedTree<long long> bit(N);

    for (int i = 0; i < Q; i++) {
        int q;
        cin >> q;
        if (q == 0) {
            int s, t, x;
            cin >> s >> t >> x;
            bit.add(s - 1, t, x);
        } else {
            int s, t;
            cin >> s >> t;
            std::cout << bit.sum(t) - bit.sum(s - 1) << std::endl;
        }
    }
}
