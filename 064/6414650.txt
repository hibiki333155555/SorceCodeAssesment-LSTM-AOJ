#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;

#define REP(i,n) for(int i=0;i<(n);i++)
#define ALL(v) v.begin(),v.end()
#define debug(a) cerr<<#a<<":"<<a<<endl;
#define debug2(a,b) cerr<<"("<<#a<<","<<#b<<"):("<<a<<","<<b<<")"<<endl;
#define debug3(a,b,c) cerr<<"("<<#a<<","<<#b<<","<<#c<<"):("<<a<<","<<b<<","<<c<<")"<<endl;
#define debug4(a,b,c,d) cerr<<"("<<#a<<","<<#b<<","<<#c<<","<<d<<"):("<<a<<","<<b<<","<<c<<","<<d<<")"<<endl;

template<typename T>
istream& operator>>(istream&is,vector<T>&v){
  for(T&p:v)is>>p;
  return is;
}
template<typename T>
ostream& operator<<(ostream&os,const vector<T>&v){
  if(&os==&cerr)os<<"[";
  for(int i=0;i<v.size();i++){
    os<<v[i];
    if(i+1<v.size())os<<(&os==&cerr?",":" ");
  }
  if(&os==&cerr)os<<"]";
  return os;
}

template<typename T,bool directed>
struct Dinic{
  struct edge{
    int to,cap,rev;
    edge(){}
    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){} 
  };
  vector<vector<edge>> G;
  vector<int> level,iter;
  Dinic(){}
  Dinic(int n):G(n),level(n),iter(n){}
  int add_edge(int from,int to,T cap){
    G[from].emplace_back(to,cap,G[to].size());
    G[to].emplace_back(from,directed?0:cap,G[from].size()-1);
    return G[to].back().rev;
  }
  inline void bfs(int s){
    fill(level.begin(),level.end(),-1);
    queue<int> que;
    level[s]=0;
    que.emplace(s);
    while(que.size()){
      int v=que.front();que.pop();
      for(int i=0;i<(int)G[v].size();i++){
        edge &e=G[v][i];
        if(e.cap==0||~level[e.to])continue;
        level[e.to]=level[v]+1;
        que.emplace(e.to);
      }
    }
  }
  
  inline T dfs(int v,int t,T f){
    if(v==t)return f;
    for(int &i=iter[v];i<(int)G[v].size();i++){//このdfsで使わなかった辺は次のBFSまで使われることはない
      edge &e=G[v][i];
      if(e.cap>0&&level[v]<level[e.to]){//bfsをしているのでlevel[v]<level[e.to]ならlevel[v]+1==level[e.to]
        T d=dfs(e.to,t,min(f,e.cap));
        if(d==0)continue;
        e.cap-=d;
        G[e.to][e.rev].cap+=d;
        return d;
      }
    }
    return 0;
  }
  
  T flow(int s,int t,T lim){
    T fl=0;
    while(true){
      bfs(s);
      if(level[t]<0||lim==0)break;
      fill(iter.begin(),iter.end(),0);
      while(true){
        T f=dfs(s,t,lim);
        if(f==0)break;
        fl+=f;
        lim-=f;
      }
    }
    return fl;
  }
  
  T flow(int s,int t){
    return flow(s,t,numeric_limits<T>::max()/2);
  }
  
  T cut(int s,int t,int x,int a){
    static_assert(directed,"must be directed");
    auto &e=G[x][a];
    int y=e.to;
    T cr=G[y][e.rev].cap;
    if(cr==0) return e.cap=0;
    e.cap=G[y][e.rev].cap=0;
    T cap=cr-flow(x,y,cr);
    if(x!=s&&cap!=0)flow(x,s,cap);
    if(t!=y&&cap!=0)flow(t,y,cap);
    return cap;
  }
  
  T link(int s,int t,int x,int a,T f){
    auto &e=G[x][a];
    e.cap+=f;
    return flow(s,t,f);
  }
};

int main(){
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n;cin>>n;
  vector<int> a(n),b(n);
  cin>>a;
  cin>>b;
  int cnt=0;
  Dinic<int,true> fl(2*n+2);
  int S=2*n;int T=S+1;
  set<pair<int,int>> se;
  REP(i,n){
    if(a[i]>=b[i])continue;
    cnt++;
    fl.add_edge(S,i,1);
    fl.add_edge(n+i,T,1);
    REP(j,n){
      if(i==j)continue;
      if(a[j]>=b[j])continue;
      if(se.count(minmax(i,j)))continue;
      swap(a[i],b[j]);
      if(a[i]>=b[i]&&a[j]>=b[j]){
        fl.add_edge(min(i,j),n+max(i,j),1);
        se.insert(minmax(i,j));
      }
      swap(a[i],b[j]);
    }
  }
  cout<<cnt-fl.flow(S,T)<<endl;
}
