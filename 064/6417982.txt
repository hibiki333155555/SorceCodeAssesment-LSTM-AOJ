#include "bits/stdc++.h"
#include <unistd.h>
using namespace std;
using i64 = long long;
using u64 = unsigned long long;
using ld = long double;
using i_i = pair<int, int>;
using i_b = pair<int, bool>;
using l_l = pair<i64, i64>;
using d_d = pair<double, double>;
using s_s = pair<string, string>;
using i_i_i = tuple<int, int, int>;
using i_i_i_i = tuple<int, int, int, int>;
using l_l_l = tuple<i64, i64, i64>;
using l_l_l_l = tuple<i64, i64, i64, i64>;
#define rep(i, n) for(int i = 0; i < n; i++)
#define ifbit(n,k) ((n>>k)&1) //if kth bit of n is on then true (sitakara, 0-indexed)
#define zpad(i) cout << setfill('0') << setw(i)
#define dout cout << fixed << setprecision(10)
#define pcnt __builtin_popcount
constexpr int INF = 2147483647;
constexpr i64 I64F = 9223372036854775807;
constexpr int m1007 = 1000000007;
constexpr int m9982 = 998244353;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

int main() {
	int si, sj, sk; cin >> si >> sj >> sk;
	int gi, gj, gk; cin >> gi >> gj >> gk;
	int t = si / 2;
	si += t * -2;
	sj += t * 2;
	t = gi / 2;
	gi += t * -2;
	gj += t * 2;
	t = sj / 2;
	sj += t * -2;
	sk += t * 2;
	t = gj / 2;
	gj += t * -2;
	gk += t * 2;
	map<i_i_i, int> mp;
	mp[{-1, -1, 3}] = 1;
	mp[{1, -1, 1}] = 1;
	mp[{-1, 1, 1}] = 1;
	mp[{0, 0, 0}] = 1;
	mp[{1, 1, -1}] = 1;
	mp[{-1, -1, 2}] = 2;
	mp[{1, -1, 0}] = 2;
	mp[{0, 0, 1}] = 2;
	mp[{-1, 1, 0}] = 2;
	mp[{1, 1, -2}] = 2;
	mp[{0, -1, 2}] = 3;
	mp[{-1, 0, 1}] = 3;
	mp[{0, 1, 0}] = 3;
	mp[{1, 0, -1}] = 3;
	mp[{-1, 0, 2}] = 4;
	mp[{0, -1, 1}] = 4;
	mp[{1, 0, 0}] = 4;
	mp[{0, 1, -1}] = 4;
	bool yes = false;
	if (mp[{si, sj, sk}] == mp[{gi, gj, gk}]) yes = true;
	cout << (yes ? "Yes" : "No") << endl;
	
	return 0;
}

