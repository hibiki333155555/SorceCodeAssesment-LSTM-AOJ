// O(QN) TLE

#include <stdio.h>

const int Mod = 998244353;

typedef struct Edge {
	struct Edge *next;
	int v, id;
	long long ans;
} edge;
	
int main()
{
	int i, N, u, w;
	edge *adj[100001] = {}, e[200001], *p;
	scanf("%d", &N);
	for (i = 0; i < N - 1; i++) {
		scanf("%d %d", &u, &w);
		e[i*2].v = w;
		e[i*2+1].v = u;
		e[i*2].id = i * 2;
		e[i*2+1].id = i * 2 + 1;
		e[i*2].ans = -1;
		e[i*2+1].ans = -1;
		e[i*2].next = adj[u];
		e[i*2+1].next = adj[w];
		adj[u] = &(e[i*2]);
		adj[w] = &(e[i*2+1]);
	}
	
	int par[100001] = {}, depth[100001], prev[100001], q[100001], head, tail;
	long long sum;
	par[1] = 1;
	depth[1] = 0;
	prev[1] = -1;
	q[0] = 1;
	for (head = 0, tail = 1; head < tail; head++) {
		u = q[head];
		for (p = adj[u]; p != NULL; p = p->next) {
			w = p->v;
			if (w == par[u]) continue;
			par[w] = u;
			depth[w] = depth[u] + 1;
			prev[w] = p->id;
			q[tail++] = w;
		}
	}
	for (head--; head > 0; head--) {
		u = q[head];
		i = prev[u];
		e[i].ans = 1;
		for (p = adj[u]; p != NULL; p = p->next) {
			w = p->v;
			if (w == par[u]) continue;
			e[i].ans += p->ans * 2;
		}
		e[i].ans %= Mod;
	}
	for (; head < tail; head++) {
		u = q[head];
		for (p = adj[u], sum = 1; p != NULL; p = p->next) {
			w = p->v;
			sum += p->ans * 2;
		}
		for (p = adj[u]; p != NULL; p = p->next) {
			i = p->id ^ 1;
			if (e[i].ans >= 0) continue;
			e[i].ans = (sum - p->ans * 2) % Mod;
		}
	}
	
	int j, Q, x, y, xx, yy, z;
	long long pow[100001];
	for (i = 1, pow[0] = 1; i <= N; i++) pow[i] = pow[i-1] * 2 % Mod;
	scanf("%d", &Q);
	for (j = 1; j <= Q; j++) {
		scanf("%d %d", &x, &y);
		xx = x;
		yy = y;
		while (depth[xx] > depth[yy]) xx = par[xx];
		while (depth[yy] > depth[xx]) yy = par[yy];
		while (xx != yy) {
			xx = par[xx];
			yy = par[yy];
		}
		z = xx;
		if (z != x && z != y) {
			printf("%lld\n", e[prev[x]].ans * e[prev[y]].ans % Mod * pow[depth[x] + depth[y] - depth[z] * 2] % Mod);
		} else if (z == x) {
			z = y;
			while (depth[z] > depth[x] + 1) z = par[z];
			printf("%lld\n", e[prev[y]].ans * e[prev[z] ^ 1].ans % Mod * pow[depth[y] - depth[x]] % Mod);			
		} else {
			z = x;
			while (depth[z] > depth[y] + 1) z = par[z];
			printf("%lld\n", e[prev[x]].ans * e[prev[z] ^ 1].ans % Mod * pow[depth[x] - depth[y]] % Mod);		
		}
	}
	fflush(stdout);
	return 0;
}

