#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<pll> vpll;

#define FOR(i, a, b) for(ll i=(a); i<(b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define NREP(i, n) FOR(i, 1, n+1)

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

using SimpleGraph = vector<vector<ll>>;
struct Edge{
    ll to, cost;
    Edge(ll t, ll c) : to(t), cost(c) { }
};
using Graph = vector<vector<Edge>>;
struct Edge3{
    ll from, to, cost;
    Edge3(ll f, ll t, ll c) : from(f), to(t), cost(c) { }
};
using EdgeGraph = vector<vector<Edge3>>;

const ll MOD = 998244353;
const ll nmax = 2010, kmax = 2010;
ll dp[nmax][kmax];

int main(void){
    ll N, K; cin >> N >> K;
    vl A(N), P(N);
    REP(i, N) {cin >> A[i];}
    SimpleGraph G(N);
    REP(i, N) {
        if(i == 0) {P[i] = 0;}
        else {cin >> P[i]; P[i]--;}
        
        if(i != 0) {
            ll p = P[i];
            G[p].push_back(i);
        }
    }
    
    for(ll i = N-1; i >= 0; --i) {
        ll a = A[i];
        
        dp[i][a] = 1;
        for(auto ni:G[i]) {
            REP(k, kmax) {
                if(k + a < kmax) {
                    dp[i][k+a] += dp[ni][k];
                    dp[i][k+a] %= MOD;
                }
            }
        }
    }
    
    ll res = dp[0][K];
    cout << res << endl;
    
    
    return 0;
}
