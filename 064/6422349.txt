#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable: 4244) // 最悪をします
// AtCoder の時だけ ACL をインクルードしてマクロを定義
#if __has_include(<atcoder/all>)
#include <atcoder/all>
#define ACL_ENABLED
#endif

#if __has_include(<boost/multiprecision/cpp_int.hpp>)
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/math/constants/constants.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/math/constants/constants.hpp>
#include <boost/qvm/mat.hpp>
#include <boost/qvm/mat_operations.hpp>
#include <boost/qvm/quat.hpp>
#include <boost/qvm/quat_operations.hpp>
#include <boost/qvm/to_string.hpp>
#include <boost/qvm/vec.hpp>
#include <boost/qvm/vec_access.hpp>
#include <boost/qvm/vec_mat_operations.hpp>
#include <boost/qvm/vec_operations.hpp>
#include <boost/range/algorithm/for_each.hpp>
#include <boost/range/irange.hpp>

#define BOOST_ENABLED 
using namespace boost::multiprecision;
namespace ublas = boost::numeric::ublas;
namespace qvm = boost::qvm;

using Vector3D = boost::qvm::vec<long double, 3>;
using Quaternion = boost::qvm::quat<long double>;
using Matrix3x3 = boost::qvm::mat<long double, 3, 3>;
using Matrix4x4 = boost::qvm::mat<long double, 4, 4>;
// constexpr long double PI = boost::math::constants::pi<long double>();

#if defined(ACL_ENABLED) && defined(ONLINE_JUDGE) // TORIAEZU: AtCoder の ONLINE_JUDGE 環境でだけ long double の特殊化を入れる。(Boost 1_73 未満のバージョンで qvm を使うためのワークアラウンド)
namespace boost {
	namespace qvm {
		template <> long double sqrt<long double>(long double a)
		{
			return sqrtl(a);
		}
		template <> long double sin<long double>(long double a)
		{
			return sinl(a);
		}
		template <> long double cos<long double>(long double a)
		{
			return cosl(a);
		}
	}
}
#endif

#endif

#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <numeric>
#include <queue>
#include <stack>
#include <map> 
#include <set>
#include <string>
#include <functional>
#include <list>
#include <random>
#include <time.h>
#include <iomanip>
#include <assert.h>
#include <numeric>
#include <sstream>
#include <memory>

#define BIT(nr) (1UL << (nr))
#define int long long
//#define ll long long
#define double long double
#define mod 1000000007
#define MAXN (int)1e+5 * 2+1
#define LL_MAX 9223372036854775807	//ない環境用
#define LL_HALFMAX 9223372036854775807 / 2	//ない環境用
#define MIN -(9223372036854775807 / 2)
#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)
#define rep(i,n) REP(i,0,n)
#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)
#define ALLOF(c) (c).begin(), (c).end()
#define REPS(i,x) for(int i=1;i<=(int)(x);i++)
#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)
#define RREPS(i,x) for(int i=((int)(x));i>0;i--)
#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define mp make_pair
template<typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }
template<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }

const double PI = 3.14159265358979323846;

// map が k と同値のキーを持つ要素 e を持っている場合、 e.second に対して chmin(e.second, v) そうでなければ、そのキーに対応する値に v を挿入
// 挿入された(キー 存在しない)場合には true, 代入された(キー 存在)場合には false 
template<typename MAP, typename T1, typename T2>
bool insert_or_chmin(MAP& map, T1 k, T2 v) {
	if (map.find(k) == map.end()) {
		// キーが存在しないので、挿入
		map[k] = v;
		return true;
	}
	else {
		// キーが存在するので、 chmin
		chmin(map[k], v);
		return false;
	}
}

// 上の chmax 版
template<typename MAP, typename T1, typename T2>
bool insert_or_chmax(MAP& map, T1 k, T2 v) {
	if (map.find(k) == map.end()) {
		// キーが存在しないので、挿入
		map[k] = v;
		return true;
	}
	else {
		// キーが存在するので、 chmax
		chmax(map[k], v);
		return false;
	}
}


using namespace std;
using pint = pair<int, int>;

//デバッグ用カッコの有無
#ifdef DEBUG
template <class T>ostream& operator<<(ostream& o, const vector<T>& v)
{
	o << "{"; for (int i = 0; i < (int)v.size(); i++)o << (i > 0 ? ", " : "") << v[i]; o << "}"; return o;
}
#endif // DEBUG

template <class T>ostream& operator<<(ostream& o, const vector<T>& v)
{
	for (int i = 0; i < (int)v.size(); i++)o << (i > 0 ? " " : "") << v[i]; return o;
}

int dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位
int dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位

int dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)
int dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)

using Weight = int;
using Flow = int;
struct Edge {
	int src, dst;

	// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持
	int rev;
	Weight weight;
	Flow cap;
	Edge() : src(0), dst(0), weight(0) {}
	Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}
};
using Edges = std::vector<Edge>;
using Graph = std::vector<Edges>;
using Array = std::vector<Weight>;
using Matrix = std::vector<Array>;

void add_edge(Graph& g, int a, int b, Weight w = 1) {
	g[a].emplace_back(a, b, w);
	g[b].emplace_back(b, a, w);
}
void add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }

// 辺がメンバに src と dst を持つ隣接リスト表記のグラフをダンプ(https://hello-world-494ec.firebaseapp.com/) に投げることを想定
template <typename T>
void dump_graph(T G) {
	int V = G.size();
	int E = 0;
	ostringstream os;

	for (auto es : G) {
		for (auto e : es) {
			E++;
			os << e.src << " " << e.dst << "\n";
		}
	}
	cout << V << " " << E << "\n";
	cout << os.str() << "\n";
}

// グリッドからグラフを構築
// @pre: gはノード数H*Wのグラフ
void create_from_grid(Graph& g, int h, int w, vector<string>& mapData, char wall) {
	//グラフ構築 O(HW)
	rep(y, h) {
		rep(x, w) {
			if (mapData[y][x] == wall) {
				continue;
			}

			int id = y * w + x;
			//右と下(変位が正)のみ見る(辺の重複を回避するため)
			rep(i, 2) {
				int nx = x + dxp[i];
				int ny = y + dyp[i];
				int nid = ny * w + nx;
				if (nx < 0 || nx >= w) {
					continue;
				}
				if (ny < 0 || ny >= h) {
					continue;
				}
				if (mapData[ny][nx] != wall) {
					add_edge(g, id, nid);
				}
			}
		}
	}
}

// マスに重みが定義されるグリッドから重み付きグラフを構築、ダイクストラなどをするとき始点のこすとは入らないことに注意
// @pre: gはノード数H*Wのグラフ
void create_weighted_from_grid(Graph& g, int h, int w, vector<vector<int>>& mapData) {
	//グラフ構築 O(HW)
	rep(y, h) {
		rep(x, w) {
			int id = y * w + x;
			// こんどは全方向見る(行きと帰りで重みが違うはず)
			rep(i, 4) {
				int nx = x + dx[i];
				int ny = y + dy[i];
				int nid = ny * w + nx;
				if (nx < 0 || nx >= w) {
					continue;
				}
				if (ny < 0 || ny >= h) {
					continue;
				}

				// 移動先のコストを足す
				add_arc(g, id, nid, mapData[ny][nx]);
			}
		}
	}
}

// グリッドにおいて座標をグラフのノード番号に変換する
int point_to_node_num(int x, int y, int W) {
	return y * W + x;
}

void solve_TLE(ostringstream& aout, long long N, long long M, std::vector<long long> u, std::vector<long long> v) {

}

/*
* にう式抽象化 BFS から indexer を除いたもの https://niuez.github.io/posts/impl_abstract_dijkstra/
* テンプレート引数
* State:							BFS のキューにいれる型
* GenerateNextFunc(State, Func):	State: 現在の State Func: 生成された次の state を引数に取って、その state が条件を満たす場合 最短距離を更新してキューに追加する bfs の内部実装 を引数に取る関数
*									すべての生成される次状態 state について、 Func(state) を呼び出してください
* GetRefFunc(state):				state を引数に取って更新すべき dist 配列の要素への参照を返す関数
* initialDistance:					距離の初期値、デフォルト0
*/
template<typename State, typename GenerateNextFunc, typename GetRefFunc>
void Bfs(State initialState, GenerateNextFunc genNext, GetRefFunc getRef, int initialDistance = 0) {
	std::queue<State> q;

	q.push(initialState);
	auto& initDist = getRef(initialState);
	initDist = initialDistance;

	while (!q.empty()) {
		auto state = q.front();
		q.pop();

		// state に基づいて次の状態を生成する
		genNext(state, [&](State nxt) {
			auto& prvRef = getRef(state);
			auto& nxtRef = getRef(nxt);

			if (nxtRef > prvRef + 1) {
				nxtRef = prvRef + 1;
				q.push(nxt);
			}
		});
	}
}

signed main() {
	int n;
	cin >> n;

	Graph G(n + 1);
	rep(i, n) {
		int u, k;
		cin >> u >> k;

		vector<int> v(k);
		rep(j, k) {
			cin >> v[j];
			add_arc(G, u, v[j]);
		}
	}


	vector<int> dist(n + 1, LL_HALFMAX);

	auto genNxt = [&](int s, auto func) {
		for (auto e : G[s]) {
			func(e.dst);
		}
	};

	auto getRef = [&](int s) -> int& {
		return dist[s];
	};

	Bfs(1, genNxt, getRef, 0);

	REPS(i, n) {
		cout << i << " " << (dist[i] == LL_HALFMAX ? -1 : dist[i]) << "\n";
	}

	return 0;
}

