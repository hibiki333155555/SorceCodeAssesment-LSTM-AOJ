#include <bits/stdc++.h>
using namespace std;
#define bokusunny ios::sync_with_stdio(false), cin.tie(nullptr);

struct Edge {
  int to;
  long long w;

  Edge(const int to, const long long w) : to(to), w(w) {}
};
using Graph = vector<vector<Edge>>;

void solve(int N) {
  vector<int> A(N), B(N), C(N);
  for (int i = 0; i < N; i++) cin >> A[i] >> B[i] >> C[i];
  int M = max(*max_element(A.begin(), A.end()), *max_element(B.begin(), B.end())) + 1;
  Graph G(M);
  for (int i = 0; i < N; i++) {
    G[A[i]].emplace_back(B[i], C[i]);
    G[B[i]].emplace_back(A[i], C[i]);
  }

  auto warshall_floyd = [](const Graph &graph) {
    int n = (int)graph.size();
    const long long inf = 1LL << 60;
    vector Dist(n, vector<long long>(n, inf));
    for (int i = 0; i < n; i++) Dist[i][i] = 0;
    for (int from = 0; from < n; from++) {
      for (auto [to, w] : graph[from]) {
        Dist[from][to] = min(Dist[from][to], w);
      }
    }

    for (int k = 0; k < n; k++) {
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
          if (Dist[i][k] == inf || Dist[k][j] == inf) continue;
          Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]);
        }
      }
    }

    return Dist;
  };

  auto D = warshall_floyd(G);
  const int INFINT = 1 << 30;
  int mi = INFINT;
  int ans = -1;
  for (int from = 0; from < M; from++) {
    auto tot = accumulate(D[from].begin(), D[from].end(), 0LL);
    if (tot < mi) {
      mi = tot;
      ans = from;
    }
  }

  assert(ans != -1);
  cout << ans << ' ' << mi << endl;
}

int main() {
  bokusunny;

  int N;
  while (cin >> N) {
    if (N == 0) break;
    solve(N);
  }

  return 0;
}

