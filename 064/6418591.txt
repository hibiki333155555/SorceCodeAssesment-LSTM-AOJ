#include<stdio.h>
#define MAX 25
#define NIL -1

typedef struct Node{
  int p, l, r;
}Node;

Node T[MAX];
int D[MAX];
int H[MAX];

int max(int a, int b){
  if(a > b) return a;
  else return b;
}

//ここの計算量の考察
void setDepth(int u, int p){
  D[u] = p;
  if(T[u].r != NIL) setDepth(T[u].r, p + 1);
  if(T[u].l != NIL) setDepth(T[u].l, p + 1);
}

//ここの計算量の考察
int setHeight(int u){
  int hl = 0, hr = 0;
  if(T[u].l != NIL) hr = setHeight(T[u].l) + 1;
  if(T[u].r != NIL) hl = setHeight(T[u].r) + 1;
  return H[u] = max(hl, hr);
}

//節点uの兄弟を返す
int getSibling(int u){
  if(T[u].p == NIL) return NIL;
  else if(T[T[u].p].l == u && T[T[u].p].r != NIL) return T[T[u].p].r;
  else if(T[T[u].p].r == u && T[T[u].p].l != NIL) return T[T[u].p].l;
  else return NIL;
}

int getdegree(int u){
  if(T[u].l == NIL && T[u].r == NIL) return 0;
  else if(T[u].l == NIL || T[u].r == NIL) return 1;
  else return 2;
}

void print(int u){
  printf("node %d: ", u);
  printf("parent = %d, ", T[u].p);
  printf("sibling = %d, ", getSibling(u));
  printf("degree = %d, ", getdegree(u));
  printf("depth = %d, ", D[u]);
  printf("height = %d, ", H[u]);

  if(T[u].p == NIL) printf("root");
  else if(T[u].l == NIL && T[u].r == NIL) printf("leaf");
  else printf("internal node");

  printf("\n");
}

int main()
{
  int n;
  int id, l, r, root;
  scanf("%d", &n);

  for(int i = 0; i < n; i++ ){
    T[i].p = T[i].l = T[i].r = NIL;
  }

  for(int i = 0; i < n; i++ ){
    scanf("%d %d %d", &id, &l, &r);
    T[id].l = l;
    T[id].r = r;
    T[l].p = id;
    T[r].p = id;
  }

  for(int i = 0; i < n; i++ ){
    if(T[i].p == NIL) root = i;
  }

  setDepth(root, 0);
  setHeight(root);

  for(int i = 0; i < n; i++ ) print(i);

  return 0;
}
