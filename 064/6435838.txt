#include <iostream>
#include <vector>
#include <limits>

struct Node {
  int min_cost = std::numeric_limits<int>::max();
  int min_edge = -1;
  int min_edge_is_forward = true;
};

struct Edge {
  int source = -1;
  int target = -1;
  int capacity = -1;
  int cost = -1;
};

int main() {
  int V, E, F; std::cin >> V >> E >> F;
  std::vector<Node> nodes(V);
  std::vector<Edge> forwards(E), backwards(E);
  for (int i=0; i<E; i++) {
    int u, v, c, d;
    std::cin >> u >> v >> c >> d;
    forwards[i].source = u;
    forwards[i].target = v;
    forwards[i].capacity = c;
    forwards[i].cost = d;
    backwards[i].source = v;
    backwards[i].target = u;
    backwards[i].capacity = 0;
    backwards[i].cost = (-1) * d;
  }
  int flow=0, cost=0;
  std::vector<Node> nexts(V);
  while(flow < F) {
    
    // Bellman Foward 緩和
    nodes[0].min_cost = 0;
    for (int i=0; i<V; i++) {
      for (int j=0; j<V; j++) {
        nexts[j].min_cost = std::numeric_limits<int>::max();
        nexts[j].min_edge = -1;
        nexts[j].min_edge_is_forward = true;
      }
      for (int j=0; j<E; j++) {
        if (forwards[j].capacity > 0) {
          int cand_cost_forward = nodes[forwards[j].source].min_cost + forwards[j].cost;
          if (cand_cost_forward < nexts[forwards[j].target].min_cost) {
            nexts[forwards[j].target].min_cost = cand_cost_forward;
            nexts[forwards[j].target].min_edge = j;
            nexts[forwards[j].target].min_edge_is_forward = true;
          }
        }
        if (backwards[j].capacity > 0) {
          int cand_cost_backward = nodes[backwards[j].source].min_cost + backwards[j].cost;
          if (cand_cost_backward < nexts[backwards[j].target].min_cost) {
            nexts[backwards[j].target].min_cost = cand_cost_backward;
            nexts[backwards[j].target].min_edge = j;
            nexts[backwards[j].target].min_edge_is_forward = false;
          }
        }
      }
      nodes.swap(nexts);
    }
    
    // 可能なパスが見つからない場合はエラーを出力して終了
    if (nodes[V-1].min_edge < 0) {
      std::cout << -1 << std::endl;
      return 0;
    }
    
    // 可能なパスの最大capacityを求める
    int max_capacity = F - flow;
    int cur_idx = V - 1;
    while(cur_idx > 0) {
      if (nodes[cur_idx].min_edge_is_forward) {
        if (forwards[nodes[cur_idx].min_edge].capacity < max_capacity) {
          max_capacity = forwards[nodes[cur_idx].min_edge].capacity;
        }
        cur_idx = forwards[nodes[cur_idx].min_edge].source;
      } else {
        if (backwards[nodes[cur_idx].min_edge].capacity < max_capacity) {
          max_capacity = backwards[nodes[cur_idx].min_edge].capacity;
        }
        cur_idx = backwards[nodes[cur_idx].min_edge].source;
      }
    }
    
    // 見つけたパスにフローを流す
    flow += max_capacity;
    cur_idx = V - 1;
    while(cur_idx > 0) {
      if (nodes[cur_idx].min_edge_is_forward) {
        forwards[nodes[cur_idx].min_edge].capacity -= max_capacity;
        cost += forwards[nodes[cur_idx].min_edge].cost * max_capacity;
        backwards[nodes[cur_idx].min_edge].capacity += max_capacity;
        cur_idx = forwards[nodes[cur_idx].min_edge].source;
      } else {
        backwards[nodes[cur_idx].min_edge].capacity -= max_capacity;
        cost += backwards[nodes[cur_idx].min_edge].cost * max_capacity;
        forwards[nodes[cur_idx].min_edge].capacity += max_capacity;
        cur_idx = backwards[nodes[cur_idx].min_edge].source;
      }
    }

  }
  std::cout << cost << std::endl;
}
