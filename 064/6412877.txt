#include<bits/stdc++.h> 
using namespace std;
typedef long long ll;
#define all(x) (x).begin(),(x).end()
template<typename T1,typename T2> bool chmin(T1 &a,T2 b){if(a<=b)return 0; a=b; return 1;}
template<typename T1,typename T2> bool chmax(T1 &a,T2 b){if(a>=b)return 0; a=b; return 1;}
int dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};
long double eps = 1e-9;
long double pi = acos(-1);

template< typename T > istream &operator>>(istream &is, vector< T > &v) {
	for(T &in : v) is >> in;
	return is;
}

template< typename T > ostream &operator<<(ostream &os, const vector< T > &v) {
	for(int i = 0; i < (int) v.size(); i++) {
		os << v[i] << (i + 1 != (int) v.size() ? " " : "");
	}
	return os;
}

template< int mod = 1000000007 >
struct ModInt {
	int x;
	ModInt() : x(0) {}
	ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}
	ModInt &operator+=(const ModInt &p) {
		if((x += p.x) >= mod) x -= mod;
		return *this;
	}
	ModInt &operator-=(const ModInt &p) {
		if((x += mod - p.x) >= mod) x -= mod;
		return *this;
	}
	ModInt &operator*=(const ModInt &p) {
		x = (int) (1LL * x * p.x % mod);
		return *this;
	}
	ModInt &operator/=(const ModInt &p) {
		*this *= p.inverse();
		return *this;
	}

	ModInt operator-() const { return ModInt(-x); }
	ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }
	ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }
	ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }
	ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }
	bool operator==(const ModInt &p) const { return x == p.x; }
	bool operator!=(const ModInt &p) const { return x != p.x; }

	ModInt inverse() const {
		int a = x, b = mod, u = 1, v = 0, t;
		while(b > 0) {
			t = a / b;
			swap(a -= t * b, b);
			swap(u -= t * v, v);
		}
		return ModInt(u);
	}

	ModInt pow(int64_t n) const {
		ModInt ret(1), mul(x);
		while(n > 0) {
			if(n & 1) ret *= mul;
			mul *= mul;
			n >>= 1;
		}
		return ret;
	}

	friend ostream &operator<<(ostream &os, const ModInt &p) {
		return os << p.x;
	}

	friend istream &operator>>(istream &is, ModInt &a) {
		int64_t t;
		is >> t;
		a = ModInt< mod >(t);
		return (is);
	}

	static int get_mod() { return mod; }
};

// const int mod = 1000000007;
const int mod = 998244353;
using mint = ModInt< mod >;

typedef vector<ll> vec;
typedef vector<vec> mat;

mat mul(mat &a,mat&b){
	mat c(a.size(),vec(b[0].size()));
	for (int i = 0; i < (int)a.size(); i++){
		for (int k = 0; k < (int)b.size(); k++){
			if(a[i][k] != 0)
			for (int j = 0; j < (int)b[0].size(); j++){
				c[i][j] += a[i][k] * b[k][j] % mod;
				if(c[i][j] >= mod) c[i][j] -= mod;
			}
		}
	}
	return c;
}

mat matpow(mat a,ll m){
	mat b(a.size(),vec(a.size()));
	for (int i = 0; i < (int)a.size(); i++){
		b[i][i]=1;
	}
	while(m>0){
		if(m&1) b=mul(b,a);
		a=mul(a,a);
		m>>=1;
	}
	return b;
}

mat A(2,vec(2));

void make_mat(array<ll,2> f){
	auto [a,b] = f;
	A[0][0]=a, A[0][1]=b;
	A[1][0]=0, A[1][1]=1;
}

ll calc(ll m, ll x){
	A = matpow(A,m);
	return (A[0][0] * x % mod + A[0][1] ) % mod;
}

// ans = A[1][0]
ll value[222];

void declaration(char &c){
	value[c] = 0;
}


mint expression(string &s, int p){
	int n = s.size();
	mint ret = 0;
	mint now = 0;
	bool minus = false;
	for(int i=p;i<n;i++){
		if(s[i] == ')') break;
		if(s[i] == '-'){
			minus = true;
			ret += now * (1-2 * (minus));
			now = 0;
		}
		else if(s[i] == '+'){
			minus = false;
			ret += now * (1-2 * (minus));
			now = 0;
		}
		else if('0' <= s[i] and s[i] <= '9'){
			now *= 10;
			now += s[i] - '0';
		}
		else {
			now = value[s[i]];
		}
	}
	ret += now * (1-2 * (minus));
	// cerr << "expression: " << s.substr(p) << " ::: " << ret << endl;
	return ret;
}

array<ll,2> expression2(string &s, int p, char c){
	// expression: a * value[c] + b -> return (a, b)
	array<ll,2> ret = {0, expression(s, p).x};
	ll cnt = 0;
	bool minus = false;
	for(int i=p;i<(int)s.size();i++){
		if(s[i] == c) {
			if(minus) cnt--;
			else cnt++;
			minus = false;
		}
		if(s[i] == '-')minus=true;
		else minus=false;
	}
	ret[0] = cnt;
	ret[1] += mod - (value[c] * cnt) % mod;
	ret[1] %= mod;
	return ret;
}

void assignment(string &s){
	value[s[0]] = expression(s, 3).x;
}

void assignment(char c, ll x){
	value[c] = x;
}

vector<array<ll,2>> ans;
void print(string &s, int p, ll cnt){
	// print(<expression>)
	if(cnt != 0) ans.push_back({cnt, expression(s, p+6).x});
}


// <program>::=(<declaration>|<assignment>|<print>|<for>)+


void for2(string &s){
	ll cnt = 1;
	for(int i=0;i<(int)s.size();i++){
		if(s.substr(i, 4) == "for("){
			cnt *= expression(s, i+4).x;
			assert(cnt < 1e9);
			while(s[i] != ')') i++;
			continue;
		}
		else{
			if(s.substr(i, 6) == "print(") print(s, i, cnt);
			else{
				// <assignment>
				// a<-f(a) or a<-x
				// f(a) = (a+a+a+...+a)+b = ax + b
				array<ll, 2> f = expression2(s, i+3, s[i]);
				make_mat(f);
				ll nx = calc(cnt, value[s[i]]);
				// cerr << "AAAAAAAAAAA " << cnt << " " << nx << endl;
				// cerr << f[0] << " " << f[1] << endl;
				// cerr << A[0][0] << " " << A[0][1] << endl;
				// cerr << A[1][0] << " " << A[1][1] << endl;
				value[s[i]] = nx;
			}
			break;
		}
	}
}

/*
6 3
a
a<-1
i
j
for(2)for(3)a<-a+a
print(a)
b
b<-64
print(b)
0 0
*/

vector<array<ll,2>> program(vector<string> &s){
	ans.clear();
	int n = s.size();
	for(int i=0;i<n;i++){
		if(s[i].size() == 1){
			declaration(s[i][0]);
		}
		else if(s[i][1] == '<' and s[i][2] == '-') {
			assignment(s[i]);
		}
		else if(s[i].substr(0,5) == "print"){
			print(s[i],0,1);
		}
		else{
			for2(s[i]);
		}
	}
	return ans;
}

bool solve(){
	int n,m;
	cin>>n>>m;
	if(n == 0 and m == 0) return false;
	vector<string> s(n), t(m);
	cin>>s>>t;

	// {
	// 	vector<array<ll,2>> vs,vt;
	// 	vs = program(s);
	// 	vt = program(t);
	// 	cerr << "s: ----------------------" << endl;
	// 	for(auto [c,v]:vs)cerr << c << " " << v << endl;
	// 	cerr << "t: ----------------------" << endl;
	// 	for(auto [c,v]:vt)cerr << c << " " << v << endl;
	// 	cerr << "AAAAAAAAAAAAAAAAA" << endl;
	// }

	if(program(s) == program(t)) cout << "Yes\n";
	else cout << "No\n";

	return true;
}


signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout << fixed << setprecision(20);

	while(solve());
}
