#include <stdio.h>
#include <sys/time.h>

struct timeval t;
double beg, cur;
const int Mod = 998244353;

typedef struct Edge {
	struct Edge *next;
	int v, id;
	long long ans;
} edge;

void init_LCA(int N, edge* adj[], int par[][20], int depth[])
{
	static int i, u, w, x, q[100001], head, tail;
	static edge *p;
	par[1][0] = 0;
	for (u = 2, depth[0] = -1, depth[1] = 0; u <= N; u++) depth[u] = -1;
	q[0] = 1;
	for (head = 0, tail = 1; head < tail; head++) {
		u = q[head];
		for (p = adj[u]; p != NULL; p = p->next) {
			w = p->v;
			if (depth[w] < 0) {
				par[w][0] = u;
				depth[w] = depth[u] + 1;
				for (i = 0, x = u; x != 0; x = par[x][i++]) par[w][i+1] = par[x][i];
				q[tail++] = w;
			}
		}
	}
}

int get_LCA(int par[][20], int depth[], int u, int w)
{
	int i;
	while (depth[u] > depth[w]) {
		for (i = 1; depth[par[u][i]] >= depth[w]; i++);
		u = par[u][i-1];
	}
	while (depth[w] > depth[u]) {
		for (i = 1; depth[par[w][i]] >= depth[u]; i++);
		w = par[w][i-1];
	}
	while (u != w) {
		for (i = 1; par[u][i] != par[w][i]; i++);
		u = par[u][i-1];
		w = par[w][i-1];
	}
	return u;
}

int LCA_par[100001][20], depth[100001];
	
int main()
{
	gettimeofday(&t, NULL);
	beg = t.tv_sec + (double)t.tv_usec / 1000000;
	
	int i, N, u, w;
	edge *adj[100001] = {}, e[200001], *p;
	scanf("%d", &N);
	for (i = 0; i < N - 1; i++) {
		scanf("%d %d", &u, &w);
		e[i*2].v = w;
		e[i*2+1].v = u;
		e[i*2].id = i * 2;
		e[i*2+1].id = i * 2 + 1;
		e[i*2].ans = -1;
		e[i*2+1].ans = -1;
		e[i*2].next = adj[u];
		e[i*2+1].next = adj[w];
		adj[u] = &(e[i*2]);
		adj[w] = &(e[i*2+1]);
	}
	
	int par[100001] = {}, prev[100001], q[100001], head, tail;
	long long sum;
	par[1] = 1;
	prev[1] = -1;
	q[0] = 1;
	for (head = 0, tail = 1; head < tail; head++) {
		u = q[head];
		for (p = adj[u]; p != NULL; p = p->next) {
			w = p->v;
			if (w == par[u]) continue;
			par[w] = u;
			prev[w] = p->id;
			q[tail++] = w;
		}
	}
	for (head--; head > 0; head--) {
		u = q[head];
		i = prev[u];
		e[i].ans = 1;
		for (p = adj[u]; p != NULL; p = p->next) {
			w = p->v;
			if (w == par[u]) continue;
			e[i].ans += p->ans * 2;
		}
		e[i].ans %= Mod;
	}
	for (; head < tail; head++) {
		u = q[head];
		for (p = adj[u], sum = 1; p != NULL; p = p->next) {
			w = p->v;
			sum += p->ans * 2;
		}
		for (p = adj[u]; p != NULL; p = p->next) {
			i = p->id ^ 1;
			if (e[i].ans >= 0) continue;
			e[i].ans = (sum - p->ans * 2) % Mod;
		}
	}
	
	init_LCA(N, adj, LCA_par, depth);
	
	int j, Q, x, y, z;
	long long pow[100001];
	for (i = 1, pow[0] = 1; i <= N; i++) pow[i] = pow[i-1] * 2 % Mod;
	scanf("%d", &Q);
	for (j = 1; j <= Q; j++) {
		scanf("%d %d", &x, &y);
		z = get_LCA(LCA_par, depth, x, y);
		if (z != x && z != y) {
			printf("%lld\n", e[prev[x]].ans * e[prev[y]].ans % Mod * pow[depth[x] + depth[y] - depth[z] * 2] % Mod);
		} else if (z == x) {
			z = y;
			while (depth[z] > depth[x] + 1) {
				for (i = 1; depth[LCA_par[z][i]] >= depth[x] + 1; i++);
				z = LCA_par[z][i-1];
			}
			printf("%lld\n", e[prev[y]].ans * e[prev[z] ^ 1].ans % Mod * pow[depth[y] - depth[x]] % Mod);			
		} else {
			z = x;
			while (depth[z] > depth[y] + 1) {
				for (i = 1; depth[LCA_par[z][i]] >= depth[y] + 1; i++);
				z = LCA_par[z][i-1];
			}
			printf("%lld\n", e[prev[x]].ans * e[prev[z] ^ 1].ans % Mod * pow[depth[x] - depth[y]] % Mod);		
		}
	}
	fflush(stdout);
	return 0;
}

