#define _CRT_SECURE_NO_WARNINGS
#define FASTIO ios::sync_with_stdio(false), cin.tie(0)
#define FREOPEN(s) freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);


#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")


#pragma G++ optimize(1)
#pragma G++ optimize(2)
#pragma G++ optimize(3)
#pragma G++ optimize("Ofast")
#pragma G++ optimize("inline")
#pragma G++ optimize("-fgcse")
#pragma G++ optimize("-fgcse-lm")
#pragma G++ optimize("-fipa-sra")
#pragma G++ optimize("-ftree-pre")
#pragma G++ optimize("-ftree-vrp")
#pragma G++ optimize("-fpeephole2")
#pragma G++ optimize("-ffast-math")
#pragma G++ optimize("-fsched-spec")
#pragma G++ optimize("unroll-loops")
#pragma G++ optimize("-falign-jumps")
#pragma G++ optimize("-falign-loops")
#pragma G++ optimize("-falign-labels")
#pragma G++ optimize("-fdevirtualize")
#pragma G++ optimize("-fcaller-saves")
#pragma G++ optimize("-fcrossjumping")
#pragma G++ optimize("-fthread-jumps")
#pragma G++ optimize("-funroll-loops")
#pragma G++ optimize("-fwhole-program")
#pragma G++ optimize("-freorder-blocks")
#pragma G++ optimize("-fschedule-insns")
#pragma G++ optimize("inline-functions")
#pragma G++ optimize("-ftree-tail-merge")
#pragma G++ optimize("-fschedule-insns2")
#pragma G++ optimize("-fstrict-aliasing")
#pragma G++ optimize("-fstrict-overflow")
#pragma G++ optimize("-falign-functions")
#pragma G++ optimize("-fcse-skip-blocks")
#pragma G++ optimize("-fcse-follow-jumps")
#pragma G++ optimize("-fsched-interblock")
#pragma G++ optimize("-fpartial-inlining")
#pragma G++ optimize("no-stack-protector")
#pragma G++ optimize("-freorder-functions")
#pragma G++ optimize("-findirect-inlining")
#pragma G++ optimize("-frerun-cse-after-loop")
#pragma G++ optimize("inline-small-functions")
#pragma G++ optimize("-finline-small-functions")
#pragma G++ optimize("-ftree-switch-conversion")
#pragma G++ optimize("-foptimize-sibling-calls")
#pragma G++ optimize("-fexpensive-optimizations")
#pragma G++ optimize("-funsafe-loop-optimizations")
#pragma G++ optimize("inline-functions-called-once")
#pragma G++ optimize("-fdelete-null-pointer-checks")




#include<stdio.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<string>
#include<algorithm>
#include<queue>
#include<map>
#include<unordered_map>
#include<set>
#include<unordered_set>
#include<list>
#include<vector>
#include<queue>
#include<tuple>
#include<sstream>
#include<stack>


//XDDDDDDi
using namespace std;
#define MT make_tuple
#define MP make_pair


#define MOD 1000000007
#define PI (acos(-1.0))
#define EPS 1e-6
#define MMT(s,a) memset(s, a, sizeof s)
#define GO(i,a,b) for(int i = (a); i < (b); ++i)
#define GOE(i,a,b) for(int i = (a); i <= (b); ++i)
#define OG(i,a,b) for(int i = (a); i > (b); --i)
#define OGE(i,a,b) for(int i = (a); i >= (b); --i)

typedef unsigned long long ull;
typedef long long ll;
typedef double db;
typedef long double ldb;
typedef stringstream sstm;
int fx[4][2] = {1,0,-1,0,0,1,0,-1};

template<typename T> using maxHeap = priority_queue<T, vector<T>, less<T> >;
template<typename T> using minHeap = priority_queue<T, vector<T>, greater<T> >;

inline char nc(){ static char buf[1000000], *p1 = buf, *p2 = buf; return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1000000,stdin),p1 == p2) ? EOF : *p1++; }
#define nc getchar
template<typename T> inline int read(T& sum){ char ch = nc(); if(ch == EOF || ch == -1) return 0; int tf = 0; sum = 0; while((ch < '0' || ch > '9') && (ch != '-')) ch = nc(); tf = ((ch == '-') && (ch = nc())); while(ch >= '0' && ch <= '9') sum = sum*10 + (ch-48), ch = nc(); (tf) && (sum = -sum); return 1; }
template<typename T,typename... Arg> inline int read(T& sum,Arg&... args){ int ret = read(sum); if(!ret) return 0; return read(args...); }
template<typename T1,typename T2> inline void read(T1* a,T2 num){ for(int i = 0; i < num; i++){read(a[i]);} }
template<typename T1,typename T2> inline void read(T1* a,T2 bn,T2 ed){ for(;bn <= ed; bn++){read(a[bn]);} }
inline void read(char* s){ char ch = nc(); int num = 0; while(ch != ' ' && ch != '\n' && ch != '\r' && ch != EOF){s[num++] = ch;ch = nc();} s[num] = '\0'; }
inline void read(string& s){ static char tp[1000005]; char ch = nc(); int num = 0; while(ch != ' ' && ch != '\n' && ch != '\r' && ch != EOF){tp[num++] = ch;ch = nc();} tp[num] = '\0';    s = (string)tp; }
template<typename T> inline void print(T k){ int num = 0,ch[20]; if(k == 0){ putchar('0'); return ; } (k<0)&&(putchar('-'),k = -k); while(k>0) ch[++num] = k%10, k /= 10; while(num) putchar(ch[num--]+48); }
template<typename T,typename... Arg> inline void print(T k,Arg... args){ print(k),putchar(' '); print(args...);}
template<typename T1,typename T2> inline void print(T1* a,T2 num){ print(a[0]); for(int i = 1; i < num; i++){putchar(' '),print(a[i]);} }
template<typename T1,typename T2> inline void print(T1* a,T2 bn,T2 ed){ print(a[bn++]); for(;bn <= ed; bn++){putchar(' '),print(a[bn]);} }
/*math*/
template<typename T> inline T gcd(T a, T b){ return b==0 ? a : gcd(b,a%b); }
template<typename T> inline T lowbit(T x){ return x&(-x); }
template<typename T> inline bool mishu(T x){ return x>0?(x&(x-1))==0:false; }
template<typename T1,typename T2, typename T3> inline ll q_mul(T1 a,T2 b,T3 p){ ll w = 0; while(b){ if(b&1) w = (w+a)%p; b>>=1; a = (a+a)%p; } return w; }
template<typename T,typename T2> inline ll f_mul(T a,T b,T2 p){ return (a*b - (ll)((long double)a/p*b)*p+p)%p; }
template<typename T1,typename T2, typename T3> inline ll q_pow(T1 a,T2 b,T3 p){ ll w = 1; while(b){ if(b&1) w = (w*a)%p; b>>=1; a = (a*a)%p;} return w; }
template<typename T1,typename T2, typename T3> inline ll s_pow(T1 a,T2 b,T3 p){ ll w = 1; while(b){ if(b&1) w = q_mul(w,a,p); b>>=1; a = q_mul(a,a,p);} return w; }
template<typename T> inline ll ex_gcd(T a, T b, T& x, T& y){ if(b == 0){ x = 1, y = 0; return (ll)a; } ll r = exgcd(b,a%b,y,x); y -= a/b*x; return r;/*gcd*/ }
template<typename T1,typename T2> inline ll com(T1 m, T2 n) { int k = 1;ll ans = 1; while(k <= n){ ans=((m-k+1)*ans)/k;k++;} return ans; }
template<typename T> inline bool isprime(T n){ if(n <= 3) return n>1; if(n%6 != 1 && n%6 != 5) return 0; T n_s = floor(sqrt((db)(n))); for(int i = 5; i <= n_s; i += 6){ if(n%i == 0 || n%(i+2) == 0) return 0; } return 1; }
/* ----------------------------------------------------------------------------------------------------------------------------------------------------------------- */
#define NN 114514

using namespace std;

int fa[NN][32];

int n;


int depth[NN];  

map<int,vector<int>>mp;

void dfs(int deep,int i)
{
    
    depth[i]=deep;
    if(mp[i].size()==0)return;
    for(auto x:mp[i])
    {
        //cout<<x<<" "<<i<<endl;
        //if(i==x)continue;
        fa[x][0]=i;
        dfs(deep+1,x);
    }
    return;
}
void LCA_initial(int n)
{
    int max_deep=int(log(n)/log(2));
    for(int i=1;i<=max_deep;i++)
    {
        for(int j=0;j<=n;j++)
        {
            if(fa[j][i-1]!=-1)fa[j][i]=fa[fa[j][i-1]][j-1];
        }
    }
    return;
}

int LCA_query(int x,int y)
{
    if(depth[x]<depth[y])
    {
        x^=y;
        y^=x;
        x^=y;
    }
    int cc;
    int logs=int(log(depth[x])/log(2));
    for(int i=logs;i>=0;i--)
    {
        if(depth[x]-(1<<i)>=depth[y])
        {
            x=fa[x][i];
        }
    }
    if(x==y)return x;
    for(int i=logs;i>=0;i--)
    {
        if(fa[x][i]!=-1&&fa[x][i]!=fa[y][i])
        {
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return fa[x][0];
}

signed main()
{
    //FASTIO;
    int a,b,c,d;
    cin>>a;

    mp.clear();
    memset(fa,-1,sizeof(fa));
    for(int i=0;i<a;i++)
    {
        cin>>b;
        mp[i].clear();
        for(int j=1;j<=b;j++)
        {
            cin>>c;
            //cout<<" "<<c<<endl;
            mp[i].push_back(c);
        }

    }

    dfs(0,0);
    LCA_initial(a);

    cin>>b;
    while(b--)
    {
        cin>>c>>d;
        cout<<LCA_query(c,d)<<endl;
    }
    for(int i=0;i<=10;i++)
    {
        cout<<depth[i]<<" ";
    }
    return 0;
}
