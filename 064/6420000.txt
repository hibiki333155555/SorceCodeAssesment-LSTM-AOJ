#line 1 "main.cpp"
#define PROBLEM "https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2667"

#line 2 "lib/prelude.hpp"
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#endif
#include <bits/stdc++.h>
using namespace std;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
#define rep2(i, m, n) for (auto i = (m); i < (n); i++)
#define rep(i, n) rep2(i, 0, n)
#define repr2(i, m, n) for (auto i = (n); i-- > (m);)
#define repr(i, n) repr2(i, 0, n)
#define all(x) begin(x), end(x)
#line 3 "lib/graph.hpp"

struct unit_edge {
  int v;
  int to() const { return v; }
  operator int() const { return to(); }
  int w() const { return 1; }
};

template <class Weight>
struct weighted_edge {
  int v;
  Weight weight;
  int to() const { return v; }
  operator int() const { return to(); }
  Weight w() const { return weight; }
};

template <class Inner>
class basic_graph {
 public:
  using weight_type = int;

  const Inner& inner;

  basic_graph(const Inner& g) : inner(g) {}

  template <class F>
  void adj(int v, F&& f) const {
    for (auto u : inner[v]) f(unit_edge{u});
  }
};

template <class Inner, class Weight>
class basic_weighted_graph {
 public:
  using weight_type = Weight;

  const Inner& inner;

  basic_weighted_graph(const Inner& g) : inner(g) {}

  template <class F>
  void adj(int v, F&& f) const {
    for (auto [u, w] : inner[v]) f(weighted_edge<weight_type>{u, w});
  }
};

template <class T>
class graph_trait : public T {
 public:
  graph_trait(T t) : T(move(t)) {}
};

template <class T>
using W = typename graph_trait<T>::weight_type;

template <size_t N>
class graph_trait<vector<int>[N]> : public basic_graph<vector<int>[N]> {
  using basic_graph<vector<int>[N]>::basic_graph;

 public:
  int size() const { return N; }
};

template <>
class graph_trait<vector<vector<int>>>
    : public basic_graph<vector<vector<int>>> {
  using basic_graph<vector<vector<int>>>::basic_graph;

 public:
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};

template <size_t N, class Weight>
class graph_trait<vector<pair<int, Weight>>[N]>
    : public basic_weighted_graph<vector<pair<int, Weight>>[N], Weight> {
  using basic_weighted_graph<vector<pair<int, Weight>>[N],
                             Weight>::basic_weighted_graph;

 public:
  int size() const { return N; }
};

template <class Weight>
class graph_trait<vector<vector<pair<int, Weight>>>>
    : public basic_weighted_graph<vector<vector<pair<int, Weight>>>, Weight> {
  using basic_weighted_graph<vector<vector<pair<int, Weight>>>,
                             Weight>::basic_weighted_graph;

 public:
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};
#line 3 "lib/graph/hld.hpp"

class hld {
 public:
  template <class G>
  hld(G& graph, int r = 0) {
    graph_trait<G> g(graph);
    in.resize(g.size());
    out.resize(g.size());
    par.resize(g.size());
    heavy.assign(g.size(), -1);
    head.resize(g.size());
    par[r] = -1;
    dfs(g, r);
    int t = 0;
    decompose(g, t, r);
  }

  int idx(int v) const { return in[v]; }
  int lca(int u, int v) const {
    while (head[u] != head[v]) {
      if (in[u] > in[v]) swap(u, v);
      v = par[head[v]];
    }
    return in[u] < in[v] ? u : v;
  }

  // Call f(l[0], r[0]), f(l[1], r[1]), ...
  // s.t. union of [l[i], r[i]) == {idx(v) for v in u-v-path}.
  template <class F>
  void paths(int u, int v, F&& f, bool exclude_lca = true) const {
    while (head[u] != head[v]) {
      if (in[u] > in[v]) swap(u, v);
      f(idx(head[v]), idx(v) + 1);
      v = par[head[v]];
    }
    if (in[u] > in[v]) swap(u, v);
    f(idx(u) + exclude_lca, idx(v) + 1);
  }

  template <class F>
  void subtree(int v, F&& f, bool exclude_root = true) const {
    f(in[v] + exclude_root, out[v]);
  }

 private:
  vector<int> in, out, par, heavy, head;

  template <class G>
  int dfs(graph_trait<G> g, int v) {
    int total_size = 1, max_size = 0;
    g.adj(v, [&](int u) {
      if (u != par[v]) {
        par[u] = v;
        int sz = dfs(g, u);
        total_size += sz;
        if (sz > max_size) max_size = sz, heavy[v] = u;
      }
    });
    return total_size;
  }

  template <class G>
  void decompose(graph_trait<G> g, int& t, int v) {
    in[v] = t++;
    if (heavy[v] != -1) head[heavy[v]] = head[v], decompose(g, t, heavy[v]);
    g.adj(v, [&](int u) {
      if (u != par[v] && u != heavy[v]) head[u] = u, decompose(g, t, u);
    });
    out[v] = t;
  }
};
#line 3 "lib/algebra.hpp"

template <class Unit, class Op>
struct monoid : private Unit, private Op {
    using type = decltype(declval<Unit>()());
    monoid(Unit unit, Op op) : Unit(unit), Op(op) {}
    type unit() const { return Unit::operator()(); }
    type op(type a, type b) const { return Op::operator()(a, b); }
};

template <class Unit, class Op, class Inv>
struct group : monoid<Unit, Op>, private Inv {
    using type = typename monoid<Unit, Op>::type;
    group(Unit unit, Op op, Inv inv) : monoid<Unit, Op>(unit, op), Inv(inv) {}
    type inv(type a) const { return Inv::operator()(a); }
};

template <class T>
struct addition {
    using type = T;
    type unit() const { return 0; }
    type op(type a, type b) const { return a + b; }
    type inv(type a) const { return -a; }
};

template <class T>
struct maximum {
    using type = T;
    type unit() const { return numeric_limits<T>::min(); }
    type op(type a, type b) const { return a > b ? a : b; }
};

template <class T>
struct minimum {
    using type = T;
    type unit() const { return numeric_limits<T>::max(); }
    type op(type a, type b) const { return a > b ? b : a; }
};
#line 3 "lib/bit/clz.hpp"

template <class T>
__attribute__ ((target ("lzcnt"))) int clz(T x) {
    if (!x) return sizeof(T) * 8;
    if constexpr (sizeof(T) <= sizeof(int)) {
        return __builtin_clz((int)x);
    } else if constexpr (sizeof(T) <= sizeof(ll)) {
        return __builtin_clzll((ll)x);
    } else if constexpr (sizeof(T) <= sizeof(ll) * 2) {
        int l = clz((ll)(x >> sizeof(ll) * 8));
        return l != sizeof(ll) * 8 ? l : l + clz((ll)x);
    }
}
#line 4 "lib/bit/ilog2.hpp"

template <class T>
int ilog2(T x) { assert(x != 0); return sizeof(T) * 8 - 1 - clz(x); }

template <class T>
int ilog2_ceil(T x) { return x == 0 || x == 1 ? 1 : ilog2(x - 1) + 1; }

template <class T>
T bit_floor(T x) { return T(1) << ilog2(x); }

template <class T>
T bit_ceil(T x) { return T(1) << ilog2_ceil(x); }
#line 5 "lib/ds/fwk.hpp"

template <class M>
class fenwick_tree {
 public:
  using value_type = typename M::type;
  fenwick_tree(vector<value_type> data, M m = M()) : m(m), data(move(data)) {
    data.insert(data.cbegin(), m.unit());
    for (int i = 1; i < data.size(); i++) {
      if (i + lsb(i) < data.size())
        data[i + lsb(i)] = m.op(data[i + lsb(i)], data[i]);
    }
  }
  fenwick_tree(int n = 0, M m = M())
      : fenwick_tree(vector<value_type>(n + 1, m.unit()), m) {}
  int size() const { return data.size() - 1; }
  void clear() { fill(data.begin(), data.end(), m.unit()); }
  void add(int i, value_type v) {
    for (i++; i < data.size(); i += lsb(i)) data[i] = m.op(data[i], v);
  }
  void sub(int i, value_type v) { add(i, m.inv(v)); }
  value_type sum(int r) const {
    value_type res = m.unit();
    for (; r; r -= lsb(r)) res = m.op(res, data[r]);
    return res;
  }
  value_type sum(int l, int r) const { return m.op(m.inv(sum(l)), sum(r)); }
  template <class F>
  int partition_point(F pred = F()) const {
    int i = 0;
    value_type s = m.unit();
    if (!pred(s)) return i;
    for (int w = bit_floor(data.size()); w; w >>= 1) {
      if (i + w < data.size()) {
        value_type s2 = m.op(s, data[i + w]);
        if (pred(s2)) i += w, s = s2;
      }
    }
    return i + 1;
  }
  // min i s.t. !comp(sum(i), x)
  template <class Comp = less<value_type>>
  int lower_bound(value_type x, Comp comp = Comp()) const {
    return partition_point([&](value_type s) { return comp(s, x); });
  }

 private:
  M m;
  vector<value_type> data;
  static int lsb(int a) { return a & -a; }
  template <class, class> friend class range_fenwick_tree;
};
#line 3 "lib/ds/range_fwk.hpp"

template <class M, class F>
class range_fenwick_tree {
 public:
  using value_type = typename M::type;
  range_fenwick_tree(vector<value_type> data, M m = M(), F mul = F())
      : m(m), mul(mul), rect(move(data), m), tri(data.size(), m) {}
  range_fenwick_tree(int n = 0, M m = M(), F mul = F())
      : m(m), mul(mul), rect(n, m), tri(n, m) {}
  int size() const { return rect.size(); }
  void clear() { rect.clear(), tri.clear(); }
  void add(int i, value_type v) { rect.add(i, v); }
  void add(int l, int r, value_type v) {
    tri.add(l, v), tri.sub(r, v);
    rect.sub(l, mul(v, l)), rect.add(r, mul(v, r));
  }
  void sub(int i, value_type v) { add(i, m.inv(v)); }
  void sub(int l, int r, value_type v) { add(l, r, m.inv(v)); }
  value_type sum(int r) const { return m.op(rect.sum(r), mul(tri.sum(r), r)); }
  value_type sum(int l, int r) const { return m.op(m.inv(sum(l)), sum(r)); }
  // template <class F>
  // int partition_point(F pred = F()) const {
  //   int i = 0;
  //   value_type s = m.unit();
  //   if (!pred(s)) return i;
  //   for (int w = bit_floor(rect.data.size()); w; w >>= 1) {
  //     if (i + w < rect.data.size()) {
  //       value_type s2 =
  //           m.op(m.op(s, rect.data[i + w]), mul(tri.data[i + w], i + w + 1));
  //       if (pred(s2)) i += w, s = s2;
  //     }
  //   }
  //   return i + 1;
  // }
  // // min i s.t. !comp(sum(i), x)
  // template <class Comp = less<value_type>>
  // int lower_bound(value_type x, Comp comp = Comp()) const {
  //   return partition_point([&](value_type s) { return comp(s, x); });
  // }

 private:
  M m;
  F mul;
  fenwick_tree<M> rect, tri;
};
#line 5 "main.cpp"

int n, q;
vector<int> G[150000];
int c, u, v;

int main() {
  scanf("%d%d", &n, &q);
  rep(_, n - 1) {
    int u, v;
    scanf("%d%d", &u, &v);
    G[u].push_back(v);
  }
  hld hld(G, 0);
  range_fenwick_tree fwk(n, addition<ll>{}, multiplies<ll>{});
  while (q--) {
    scanf("%d%d%d", &c, &u, &v);
    if (c == 0) {
      ll ans = 0;
      hld.paths(u, v, [&](int l, int r) { ans += fwk.sum(l, r); });
      printf("%lld\n", ans);
    } else {
      hld.subtree(u, [&](int l, int r) { fwk.add(l, r, v); });
    }
  }
}

