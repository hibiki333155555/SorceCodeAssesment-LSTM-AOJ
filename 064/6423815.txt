#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

template < class Semigroup > class disjoint_sparse_table {
  private:
    static int msb(int c) {
        #ifdef __has_builtin
            return 31 - __builtin_clz(c);
        #else
            int ret = 0;
            if(c >> 16) c >>= 16, ret += 16;
            if(c >>  8) c >>=  8, ret +=  8;
            if(c >>  4) c >>=  4, ret +=  4;
            if(c >>  2) c >>=  2, ret +=  2;
            return ret + (c >> 1);
        #endif
    }

  public:
    using T = typename Semigroup::set;
    int n;
    vector<vector< T >> table;

    disjoint_sparse_table(const vector< T > &a) : table() {
        table.push_back(a);
        n = a.size();
        for(int i = 2; i < n; i <<= 1) {
            vector< T > v;
            for(int j = i; j < n; j += i << 1) {
                v.push_back(a[j - 1]);
                for(int k = 2; k <= i; k++) 
                    v.push_back(Semigroup::op(a[j - k], v.back()));
                v.push_back(a[j]);
                for(int k = 1; k < i && j + k < n; k++) 
                    v.push_back(Semigroup::op(v.back(), a[j + k]));
            }
            table.push_back(move(v));
        }
    }

    // [l,r)
    T fold(int l, int r) {
        assert(0 <= l && l < r && r <= n);
        if(l == --r) return table.front()[l];
        else {
            int p = msb(l ^ r);
            return Semigroup::op(table[p][l ^ (1 << p) - 1], table[p][r]);
        }
    }
};

namespace algebra {

template < class T > class MAX {
  public:
    using set = T;
    static constexpr T op(const T &l, const T &r) { return max(l, r); }
    static constexpr T id = numeric_limits< T >::min();
};

}

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    int n; cin >> n;
    vector<int> h(n);
    rep(i,n) cin >> h[i], h[i]--;

    // diamet[l][r] := max diameter in [l, r)
    // height[l][r] := height of tree has max diameter
    
    // m <- max h[l, r)
    // diamet[l][r] <- 1 + max( diamet[l][m], 
    //                          diamet[m + 1][r],
    //                          height[l][m] + height[m][r] + 1 )

    disjoint_sparse_table< algebra::MAX< int > > dst(h);
    vector<int> id(n);
    rep(i,n) id[h[i]] = i;

    map<pair<int,int>,int> memo_height, memo_diameter;

    function<int(int,int)> height = [&](int l, int r) -> int {
        if(l == r) return -1;
        if(l + 1 == r) return 0;
        if(memo_height.count({l, r})) return memo_height[{l, r}];
        int m = id[dst.fold(l, r)];
        return memo_height[{l, r}] = max(height(l, m), height(m + 1, r)) + 1;
    };

    function<int(int,int)> diameter = [&](int l, int r) -> int {
        if(l == r) return -1;
        if(l + 1 == r) return 0;
        if(memo_diameter.count({l, r})) return memo_diameter[{l, r}];
        int m = id[dst.fold(l, r)];
        return memo_diameter[{l, r}] = max({diameter(l, m), diameter(m + 1, r), height(l, m) + height(m + 1, r) + 1}) + 1;
    };

    cout << diameter(0, n) << endl;
}
