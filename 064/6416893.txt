#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using ld = long double;

struct Setup_io {
    Setup_io() {
        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
        cout << fixed << setprecision(15);
    }
} setup_io;

template <typename T>
inline bool chmax(T &a, const T &b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

template <typename T>
inline bool chmin(T &a, const T &b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

// #include <boost/multiprecision/cpp_bin_float.hpp>
// #include <boost/multiprecision/cpp_int.hpp>
// using namespace boost::multiprecision;

// #include <atcoder>
// using namespace atcoder;
// using mint = modint1000000007;
// using mint = modint998244353;

// const int MOD = 1000000007;
// const int MOD = 998244353;

struct Edge {
    int to;
    ll cost;
    Edge(){};
    Edge(int to, ll cost) : to(to), cost(cost){};
};

int main() {
    int N;
    cin >> N;
    vector<vector<Edge>> G(N);
    for (int i = 0; i < N - 1; i++) {
        int s, t;
        ll w;
        cin >> s >> t >> w;
        G[s].emplace_back(Edge(t, w));
        G[t].emplace_back(Edge(s, w));
    }

    vector<ll> dp(N, 0);
    vector<int> seen(N, 0);

    auto dfs = [&](auto &f, int now) -> int {
        seen[now] = 1;
        for (auto i : G[now]) {
            if (!seen[i.to]) {
                chmax(dp[now], f(f, i.to) + i.cost);
            }
        }
        return dp[now];
    };
    dfs(dfs, 0);

    int ans = 0;
    seen = vector<int>(N, 0);
    auto dfs2 = [&](auto &f, int now, int par) -> void {
        seen[now] = 1;
        vector<int> v, v2 = {0}, v3 = {0};
        for (auto i : G[now]) {
            if (!seen[i.to]) {
                v.emplace_back(dp[i.to] + i.cost);
                v2.emplace_back(dp[i.to] + i.cost);
                v3.emplace_back(dp[i.to] + i.cost);
            } else {
                v.emplace_back(0);
                v2.emplace_back(0);
                v3.emplace_back(0);
            }
        }
        v3.emplace_back(0);
        for (int i = 1; i < (int)v2.size(); i++) {
            chmax(v2[i], v2[i - 1]);
        }
        for (int i = (int)v3.size() - 2; i >= 1; i--) {
            chmax(v3[i], v3[i + 1]);
        }
        for (int i = 0; i < (int)G[now].size(); i++) {
            if (!seen[G[now][i].to]) {
                f(f, G[now][i].to, max(v2[i], v3[i + 2]) + G[now][i].cost);
            }
        }
        v.emplace_back(par);
        sort(v.rbegin(), v.rend());
        chmax(ans, v[0] + v[1]);
        return;
    };
    dfs2(dfs2, 0, 0);
    cout << ans << endl;
    return 0;
}
