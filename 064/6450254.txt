#include <bits/stdc++.h>
using namespace std;

#define all(a) begin(a), end(a)
#define rall(a) rbegin(a), rend(a)
#define uniq(a) (a).erase(unique(all(a)), (a).end())
using ll = long long;
using ull = unsigned long long;
using pll = pair<ll, ll>;
using vll = vector<ll>;
constexpr double PI = 3.14159265358979323846;
constexpr ll dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};
constexpr ll dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};
constexpr ll sign(ll a) { return (a > 0) - (a < 0); }
constexpr ll fdiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }
constexpr ll cdiv(ll a, ll b) { return -fdiv(-a, b); }
constexpr ull bit(int n) { return 1ull << n; }
template <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &a) {
    os << "(" << a.first << ", " << a.second << ")";
    return os;
}
template <typename T, typename U, typename V> ostream &operator<<(ostream &os, const tuple<T, U, V> &a) {
    os << "(" << get<0>(a) << ", " << get<1>(a) << ", " << get<2>(a) << ")";
    return os;
}
template <typename T> ostream &operator<<(ostream &os, const vector<T> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
template <typename T> ostream &operator<<(ostream &os, const set<T> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
template <typename T> ostream &operator<<(ostream &os, const multiset<T> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
template <typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &a) {
    os << "(";
    for (auto itr = a.begin(); itr != a.end(); ++itr) os << *itr << (next(itr) != a.end() ? ", " : "");
    os << ")";
    return os;
}
#ifdef ONLINE_JUDGE
#define dump(...) (void(0))
#else
void debug() { cerr << endl; }
template <typename Head, typename... Tail> void debug(Head &&head, Tail &&... tail) {
    cerr << head;
    if (sizeof...(Tail)) cerr << ", ";
    debug(tail...);
}
#define dump(...) cerr << __LINE__ << ": " << #__VA_ARGS__ << " = ", debug(__VA_ARGS__)
#endif
template <typename T> constexpr T mypow(T x, ll n) {
    T ret = 1;
    while (n) {
        if (n & 1) ret *= x;
        x *= x;
        n >>= 1;
    }
    return ret;
}
constexpr ll modpow(ll x, ll n, ll mod) {
    x %= mod;
    ll ret = 1;
    while (n) {
        if (n & 1) ret *= x;
        x *= x;
        n >>= 1;
        x %= mod;
        ret %= mod;
    }
    return ret;
}
template <typename T> T xor64(T lb, T ub) {
    static ull x = 88172645463325252ull;
    x ^= x << 7;
    return lb + (x ^= x >> 9) % (ub - lb);
}
constexpr ll safemod(ll x, ll mod) { return (x % mod + mod) % mod; }
template <typename T> constexpr T sq(const T &a) { return a * a; }
template <typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
template <typename T, typename U> bool chmax(T &a, const U &b) { return a < b ? a = b, true : false; }
template <typename T, typename U> bool chmin(T &a, const U &b) { return a > b ? a = b, true : false; }
template <typename T> T make_vector(T &&a) { return a; }
template <typename... Ts> auto make_vector(int h, Ts &&... ts) { return vector(h, make_vector(ts...)); }
struct rep {
    struct itr {
        ll v;
        itr(ll v) : v(v) {}
        void operator++() { ++v; }
        ll operator*() const { return v; }
        bool operator!=(itr i) const { return v < *i; }
    };
    ll l, r;
    rep(ll l, ll r) : l(l), r(r) {}
    rep(ll r) : rep(0, r) {}
    itr begin() const { return l; };
    itr end() const { return r; };
};
struct per {
    struct itr {
        ll v;
        itr(ll v) : v(v) {}
        void operator++() { --v; }
        ll operator*() const { return v; }
        bool operator!=(itr i) const { return v > *i; }
    };
    ll l, r;
    per(ll l, ll r) : l(l), r(r) {}
    per(ll r) : per(0, r) {}
    itr begin() const { return r - 1; };
    itr end() const { return l - 1; };
};
struct io_setup {
    static constexpr int PREC = 20;
    io_setup() {
        cout << fixed << setprecision(PREC);
        cerr << fixed << setprecision(PREC);
    };
} iOS;
template <ll MOD = 1000000007> struct modint {
    ll val;
    modint(ll val = 0) : val(val >= 0 ? val % MOD : (MOD - (-val) % MOD) % MOD) {}
    static ll mod() { return MOD; }
    modint inv() const {
        ll a = val, b = MOD, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            swap(a -= t * b, b);
            swap(u -= t * v, v);
        }
        return modint(u);
    }
    modint pow(ll k) const {
        modint ret = 1, mul = val;
        while (k) {
            if (k & 1) ret *= mul;
            mul *= mul;
            k >>= 1;
        }
        return ret;
    }
    modint &operator+=(const modint &a) {
        if ((val += a.val) >= MOD) val -= MOD;
        return *this;
    }
    modint &operator-=(const modint &a) {
        if ((val += MOD - a.val) >= MOD) val -= MOD;
        return *this;
    }
    modint &operator*=(const modint &a) {
        (val *= a.val) %= MOD;
        return *this;
    }
    modint &operator/=(const modint &a) { return *this *= a.inv(); }
    modint operator+() const { return *this; }
    modint operator-() const { return modint(-val); }
    friend bool operator==(const modint &a, const modint &b) { return a.val == b.val; }
    friend bool operator!=(const modint &a, const modint &b) { return rel_ops::operator!=(a, b); }
    friend modint operator+(const modint &a, const modint &b) { return modint(a) += b; }
    friend modint operator-(const modint &a, const modint &b) { return modint(a) -= b; }
    friend modint operator*(const modint &a, const modint &b) { return modint(a) *= b; }
    friend modint operator/(const modint &a, const modint &b) { return modint(a) /= b; }
    friend istream &operator>>(istream &is, modint &a) {
        ll val;
        is >> val;
        a = modint(val);
        return is;
    }
    friend ostream &operator<<(ostream &os, const modint &a) { return os << a.val; }
};
template <typename F> ll bisect(ll ok, ll ng, F f) {
    while (abs(ok - ng) > 1) {
        ll mid = (ok + ng) / 2;
        (f(mid) ? ok : ng) = mid;
    }
    return ok;
}
template <typename mint> struct combination {
    vector<mint> fact, finv, inv;
    combination(int n) : fact(n + 1), finv(n + 1), inv(n + 1) {
        fact[0] = fact[1] = finv[0] = finv[1] = inv[1] = 1;
        for (int i : rep(2, n + 1)) {
            fact[i] = fact[i - 1] * i;
            inv[i] = -inv[mint::mod() % i] * (mint::mod() / i);
            finv[i] = finv[i - 1] * inv[i];
        }
    }
    mint P(int n, int r) { return r < 0 || n < r ? 0 : (fact[n] * finv[n - r]); }
    mint C(int n, int r) { return P(n, r) * finv[r]; }
    mint H(int n, int r) { return C(n + r - 1, r); }
    mint catalan(int n) { return C(2 * n, n) / (n + 1); }
};

template <typename S> struct re_rooting {
    using T = typename S::T;
    using E = typename S::E;
    struct edge {
        int to;
        E cost;
        edge(int to, E cost) : to(to), cost(cost) {}
    };
    int m = 0;
    std::vector<std::vector<edge>> adj;
    re_rooting(int n) : adj(n) {}
    int add_edge(int u, int v, E u2v, E v2u) {
        adj[u].emplace_back(v, u2v), adj[v].emplace_back(u, v2u);
        return m++;
    }
    std::vector<T> get() {
        std::vector<std::vector<T>> dp(adj.size());
        auto dfs0 = [&](auto &&dfs0, int cur, int par) -> T {
            dp[cur].resize(adj[cur].size());
            T cum = S::id();
            for (int i = 0; i < adj[cur].size(); i++) {
                if (adj[cur][i].to == par) { continue; }
                dp[cur][i] = S::op_TE(dfs0(dfs0, adj[cur][i].to, cur), adj[cur][i].cost);
                cum = S::op_TT(cum, dp[cur][i]);
            }
            return cum;
        };
        dfs0(dfs0, 0, -1);
        std::vector<T> ret(adj.size());
        auto dfs1 = [&](auto &&dfs1, int cur, int par, T drop) -> void {
            int k = adj[cur].size();
            std::vector<T> l_cum(k + 1), r_cum(k + 1);
            l_cum[0] = r_cum[k] = S::id();
            for (int i = 0; i < k; i++) {
                if (adj[cur][i].to == par) { dp[cur][i] = S::op_TE(drop, adj[cur][i].cost); }
                l_cum[i + 1] = S::op_TT(l_cum[i], dp[cur][i]);
            }
            for (int i = k - 1; i >= 0; i--) { r_cum[i] = S::op_TT(dp[cur][i], r_cum[i + 1]); }
            for (int i = 0; i < k; i++) {
                if (adj[cur][i].to == par) { continue; }
                dfs1(dfs1, adj[cur][i].to, cur, S::op_TT(l_cum[i], r_cum[i + 1]));
            }
            ret[cur] = l_cum[k];
        };
        dfs1(dfs1, 0, -1, S::id());
        return ret;
    }
};

using mint = modint<998244353>;
struct oupc {
    using T = mint;
    using E = mint;
    static T id() { return 0; }
    static T op_TT(const T &a, const T &b) { return a + b; }
    static T op_TE(const T &a, const E &b) { return a * 2 + 1; }
};

struct hld {
    vector<vector<int>> g;
    vector<int> par, sz, dep, in, out, head;
    hld(int n) : g(n), par(n), sz(n), dep(n), in(n), out(n), head(n) {}
    void add_edge(int u, int v) { g[u].push_back(v), g[v].push_back(u); }
    vector<int> build(int root) {
        auto dfs_sz = [&](auto dfs_sz, int v, int p) -> void {
            sz[v] = 1;
            par[v] = p;
            if (p != -1) dep[v] = dep[p] + 1;
            for (int &u : g[v]) {
                if (u == p) continue;
                dfs_sz(dfs_sz, u, v);
                sz[v] += sz[u];
                if (sz[u] > sz[g[v][0]]) swap(u, g[v][0]);
            }
        };
        int t = 0;
        auto dfs_hld = [&](auto dfs_hld, int v) -> int {
            in[v] = t++;
            for (int i : rep(g[v].size())) {
                int u = g[v][i];
                if (u == par[v]) continue;
                head[u] = (i == 0 ? head[v] : u);
                dfs_hld(dfs_hld, u);
            }
            return out[v] = t;
        };
        dfs_sz(dfs_sz, root, -1);
        head[root] = root;
        dfs_hld(dfs_hld, root);
        return in;
    }
    int lca(int u, int v) const {
        while (true) {
            if (in[u] > in[v]) swap(u, v);
            if (head[u] == head[v]) return u;
            v = par[head[v]];
        }
    }
    int dist(int u, int v) const { return dep[u] + dep[v] - 2 * dep[lca(u, v)]; }
    vector<pair<int, int>> get_path(int u, int v, bool edge) const {
        vector<pair<int, int>> a, b;
        while (true) {
            if (head[u] == head[v]) {
                if (edge) {
                    if (in[u] > in[v]) a.emplace_back(in[u], in[v] + 1);
                    if (in[u] < in[v]) a.emplace_back(in[u] + 1, in[v]);
                } else {
                    a.emplace_back(in[u], in[v]);
                }
                break;
            }
            if (in[u] > in[v]) {
                a.emplace_back(in[u], in[head[u]]);
                u = par[head[u]];
            } else {
                b.emplace_back(in[head[v]], in[v]);
                v = par[head[v]];
            }
        }
        a.insert(a.end(), b.rbegin(), b.rend());
        return a;
    }
    pair<int, int> get_subtree(int v, bool edge) const { return {in[v] + edge, out[v] - 1}; }
};

int main() {
    ll n;
    cin >> n;
    vll a(n - 1), b(n - 1);
    vector g(n, vll());
    re_rooting<oupc> rr(n);
    hld hld(n);
    for (ll i : rep(n - 1)) {
        cin >> a[i] >> b[i], --a[i], --b[i];
        g[a[i]].push_back(b[i]);
        g[b[i]].push_back(a[i]);
        rr.add_edge(a[i], b[i], 1, 1);
        hld.add_edge(a[i], b[i]);
    }
    auto res = rr.get();
    for (ll i : rep(n)) res[i] = res[i] * 2 + 1;
    auto v = hld.build(0);
    vll vinv(n);
    for (ll i : rep(n)) vinv[v[i]] = i;
    ll q;
    cin >> q;
    while (q--) {
        ll x, y;
        cin >> x >> y, --x, --y;
        ll d = hld.dist(x, y);
        auto path = hld.get_path(x, y, false);
        ll w = vinv[path[0].first == path[0].second ? path[1].first
                                                    : path[0].first + sign(path[0].second - path[0].first)];
        ll r = path.size();
        ll z = vinv[path[r - 1].second == path[r - 1].first
                        ? path[r - 2].second
                        : path[r - 1].second + sign(path[r - 1].first - path[r - 1].second)];
        mint s0 = (2 * res[w] - res[x]) / 3;
        mint s1 = (2 * res[z] - res[y]) / 3;
        cout << s0 * s1 * mint(2).pow(d) << endl;
    }
}
