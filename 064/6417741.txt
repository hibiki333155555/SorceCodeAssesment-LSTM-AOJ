#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

class union_find {
  private:
    vector<int> parent;

  public:
    union_find(int n) : parent(n, -1) {}
    bool unite(int x, int y) {
        x = root(x), y = root(y);
        if(x != y) {
            if(size(x) < size(y)) swap(x, y);
            parent[x] += parent[y];
            parent[y] = x;
            return true;
        }
        return false;
    }
    int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }
    int size(int x) { return -parent[root(x)]; }
    bool same(int x, int y) { return root(x) == root(y); }
};

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    int H,W,N; cin >> H >> W >> N;
    int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;
    sx--; sy--; gx--; gy--;

    vector<vector<int>> cnt(H, vector<int>(W, -1));
    using T = tuple<int,int,int>;
    priority_queue<T> q;
    rep(i,N) {
        int x,y,k; cin >> x >> y >> k; x--; y--;
        q.push({k, x, y});
        cnt[x][y] = k;
    }

    int dx[] = {0, 1, 0, -1};
    int dy[] = {1, 0, -1, 0};
    while(!q.empty()) {
        auto [k, x, y] = q.top(); q.pop();
        if(k == 0) continue;
        rep(d,4) {
            int nx = x + dx[d], ny = y + dy[d];
            if(0 <= nx && nx < H && 0 <= ny && ny < W) {
                if(cnt[nx][ny] < k) {
                    cnt[nx][ny] = k - 1;
                    q.push({k - 1, nx, ny});
                }
            }
        } 
    }
    
    union_find uf(H * W);
    auto f = [&](int i, int j){ return i * W + j; };
    rep(i,H)rep(j,W) {
        if(cnt[i][j] == -1) {
            if(i + 1 < H && cnt[i + 1][j] == -1) {
                uf.unite(f(i, j), f(i + 1, j));
            }
            if(j + 1 < W && cnt[i][j + 1] == -1) {
                uf.unite(f(i, j), f(i, j + 1));
            }
        }
    }

    cout << (uf.same(f(sx, sy), f(gx, gy)) ? "Yes" : "No") << endl;
}
