H, W = map(int, input().split())
C = [input() for _ in range(H)]
G = [[] for _ in range(H * W)]
dh = (-1, 1, 0, 0)
dw = (0, 0, -1, 1)
sh, sw = -1, -1
gh, gw = -1, -1
for h in range(H):
    for w in range(W):
        if C[h][w] == '#':
            continue
        if C[h][w] == 'S':
            sh, sw = h, w
        if C[h][w] == 'G':
            gh, gw = h, w
        for i in range(4):
            nh = h + dh[i]
            nw = w + dw[i]
            if 0 <= nh < H and 0 <= nw < W:
                if C[nh][nw] == '#':
                    continue
                if C[h][w] == 'U' and nh - h == -1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] == 'D' and nh - h == 1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] == 'L' and nw - w == -1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] == 'R' and nw - w == 1:
                    G[nh * W + nw].append((h * W + w, 0))
                elif C[h][w] in {'.', 'S', 'G'}:
                    G[nh * W + nw].append((h * W + w, 1))

from heapq import heappop, heappush, heapify

HQ = [(0, gh * W + gw)]
INF = float('inf')
dist = [INF] * (H * W)
dist[gh * W + gw] = 0
while HQ:
    d, now = heappop(HQ)
    for to, c in G[now]:
        if dist[to] > dist[now] + c:
            dist[to] = dist[now] + c
            heappush(HQ, (d + c, to))
print(dist[sh * W + sw])

