#include<bits/stdc++.h> 
using namespace std;


template<typename T1,typename T2> bool chmin(T1 &a,T2 b){if(a<=b)return 0; a=b; return 1;}
template<typename T1,typename T2> bool chmax(T1 &a,T2 b){if(a>=b)return 0; a=b; return 1;}


const int MAX=(1<<30);

using Graph=vector<vector<int>>;

//要素数n 初期値x
template<typename T>
inline vector<T> vmake(size_t n,T x){
	return vector<T>(n,x);
}

//a,b,c,x data[a][b][c] 初期値x
template<typename... Args>
auto vmake(size_t n,Args... args){
	auto v=vmake(args...);
	return vector<decltype(v)>(n,move(v));
}

vector<int> A,B;
Graph g;
int N;
int MAX_B=500;

/*
返り値ret[i] := 
    頂点idxを根とした部分木で、宝をi個掘るとき、
        親に移動させることができる最大値 (ret[i]>0)
        親から移動してもらう最小値*-1 (ret[i]<0)
*/
vector<int> dfs(int idx,int par){
    //dp[下から貰う人数の合計(渡す人数は考えない)][下が掘る宝の数]=下とやり取りする人数の合計
    auto dp=vmake(MAX_B+1,N+1,-MAX);
    dp[0][0]=0;
    int MaxTreasure=0;
    for(int to:g[idx]){
        if(to==par) continue;
        vector<int> child=dfs(to,idx);
        
        vector<vector<int>> nex=vmake(MAX_B+1,N+1,-MAX);

        for(int b=0;b<=MAX_B;b++){
            for(int t0=0;t0<=MaxTreasure;t0++){
                for(int t1=0;t1<child.size();t1++){
                    if(dp[b][t0]==-MAX or child[t1]==-MAX) continue;
                    if(child[t1]>=0){
                        chmax(nex[min(B[idx],child[t1]+b)][t0+t1],dp[b][t0]+child[t1]);
                    }else{
                        chmax(nex[b][t0+t1],dp[b][t0]+child[t1]);                        
                    }
                }
            }
        }
        dp=nex;
        MaxTreasure+=child.size()-1;
    }
    auto ret=vmake(MaxTreasure+2,-MAX);
//ここから頂点idxの宝について考える
    for(int i=0;i<=MaxTreasure;i++){
        for(int b=0;b<=MAX_B;b++){
            if(A[idx]+b>=B[idx]){
                //頂点idxと親のやりとりの内容に関わらず、idxの宝を取れる
                chmax(ret[i+1],dp[b][i]+A[idx]);
            }else{
                chmax(ret[i+1],min(A[idx]+b-B[idx],dp[b][i]+A[idx]));
                chmax(ret[i],dp[b][i]+A[idx]); //idxの宝を諦める
            }
        }
    }
    for(int i=MaxTreasure-1;i>=0;i--){
        chmax(ret[i],ret[i+1]);
    }
    return ret;
}

void solve(){
    cin>>N;
    A.resize(N);
    B.resize(N);
    for(int i=0;i<N;i++){
        cin>>A[i];
    }
    for(int i=0;i<N;i++){
        cin>>B[i];
    }
    g.resize(N);
    for(int i=1;i<N;i++){
        int u,v;
        cin>>u>>v;
        u--; v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    vector<int> ans=dfs(0,-1);
    for(int i=N;i>=0;i--){
        if(ans[i]>=0){
            cout<<i<<endl;
            return;
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout << fixed << setprecision(20);
    int T=1;
    //cin>>T;
    while(T--) solve();
}
