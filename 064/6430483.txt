#ifndef CLASS_MODINT
#define CLASS_MODINT

#include <cstdint>

template <std::uint32_t mod>
class modint {
private:
	std::uint32_t n;
public:
	modint() : n(0) {};
	modint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};
	static constexpr std::uint32_t get_mod() { return mod; }
	std::uint32_t get() const { return n; }
	bool operator==(const modint& m) const { return n == m.n; }
	bool operator!=(const modint& m) const { return n != m.n; }
	modint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }
	modint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }
	modint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }
	modint operator+(const modint& m) const { return modint(*this) += m; }
	modint operator-(const modint& m) const { return modint(*this) -= m; }
	modint operator*(const modint& m) const { return modint(*this) *= m; }
	modint inv() const { return (*this).pow(mod - 2); }
	modint pow(std::uint64_t b) const {
		modint ans = 1, m = modint(*this);
		while (b) {
			if (b & 1) ans *= m;
			m *= m;
			b >>= 1;
		}
		return ans;
	}
};

#endif // CLASS_MODINT

#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;
using mint = modint<998244353>;

mint solve(int N, vector<long long> A) {
	// step #1. DP
	vector<int> L(2 * N), R(2 * N);
	for (int i = N; i < 2 * N; i++) {
		L[i] = i - N;
		R[i] = i - N + 1;
	}
	for (int i = N - 1; i >= 1; i--) {
		A[i] = min(A[i], A[2 * i] + A[2 * i + 1]);
		L[i] = min(L[2 * i], L[2 * i + 1]);
		R[i] = max(R[2 * i], R[2 * i + 1]);
	}

	// step #2. find "all-in" segments
	vector<bool> all_in(2 * N, false);
	for (int i = 1; i < 2 * N; i++) {
		all_in[i] = (L[i] == 0 && R[i] == N);
	}

	// step #3. calculate for each segment
	mint answer = 0;
	for (int i = 2; i < 2 * N; i++) {
		if (all_in[i]) {
			continue;
		}
		if (i % 2 == 0) {
			if (R[i] == N) {
				answer += mint(A[i]) * mint(L[i]);
			}
			else if (all_in[i + 1]) {
				answer += mint(A[i]) * (mint(N - R[i] + 1) * mint(L[i] + 1) - 1);
			}
			else {
				answer += mint(A[i]) * mint(R[i + 1] - L[i + 1]) * mint(L[i] + 1);
			}
		}
		if (i % 2 == 1) {
			if (L[i] == 0) {
				answer += mint(A[i]) * mint(N - R[i]);
			}
			else if (all_in[i - 1]) {
				answer += mint(A[i]) * (mint(L[i] + 1) * mint(N - R[i] + 1) - 1);
			}
			else {
				answer += mint(A[i]) * mint(R[i - 1] - L[i - 1]) * mint(N - R[i] + 1);
			}
		}
	}
	answer += A[1];

	return answer;
}

mint solve_easy(int N, vector<long long> A) {
	mint answer = 0;
	vector<int> bit(2 * N);
	for (int i = N; i < 2 * N; i++) {
		bit[i] = 1 << (i - N);
	}
	for (int i = N - 1; i >= 1; i--) {
		bit[i] = bit[2 * i] | bit[2 * i + 1];
	}
	for (int l = 0; l <= N; l++) {
		for (int r = l + 1; r <= N; r++) {
			int opt = (1 << 30);
			for (int i = 0; i < 1 << (2 * N - 1); i++) {
				int cost = 0, subbit = 0;
				for (int j = 1; j < 2 * N; j++) {
					if (((i >> (j - 1)) & 1) == 1) {
						cost += A[j];
						subbit |= bit[j];
					}
				}
				if (subbit == (1 << r) - (1 << l)) {
					opt = min(opt, cost);
				}
			}
			answer += opt;
		}
	}
	return answer;
}

#include <random>
#include <string>
mt19937_64 mt(1);
long long rand_int(long long l, long long r) {
	return l + mt() % (r - l);
}
string to_string(vector<long long> arr) {
	string res = "[";
	for (int i = 0; i < int(arr.size()); i++) {
		if (i != 0) res += ", ";
		res += to_string(arr[i]);
	}
	res += "]";
	return res;
}
void random_check(int N) {
	const int samples = 1000;
	for (int s = 1; s <= samples; s++) {
		vector<long long> A(2 * N);
		for (int i = 1; i < 2 * N; i++) {
			A[i] = rand_int(1, 3);
		}
		mint res1 = solve(N, A);
		mint res2 = solve_easy(N, A);
		if (res1 != res2) {
			cout << "N = " << N << ", Case #" << s << ":" << endl;
			cout << "A = " << to_string(A) << endl;
			cout << "Returns: " << res1.get() << endl;
			cout << "Answer: " << res2.get() << endl;
		}
	}
}

int main() {
	// random_check(5);
	// return 0;
	cin.tie(0);
	ios_base::sync_with_stdio(false);
	int N;
	cin >> N;
	vector<long long> A(2 * N);
	for (int i = 1; i < 2 * N; i++) {
		cin >> A[i];
	}
	mint answer = solve(N, A);
	cout << (answer * mint(1LL * N * (N + 1) / 2).inv()).get() << endl;
	return 0;
}
