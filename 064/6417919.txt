#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")

#include <bits/stdc++.h>

using namespace std;
#define rep(i,n) for(long long i=0;i<n;++i)
#define rep1(i,n) for(long long i=1;i<=n;++i)
#define rrep(i,n) for(long long i=n-1;i>=0;--i)
#define debug(output) if(debugFlag)cout<<#output<<"= "<<output<<endl
using lint = long long;
typedef pair<int,int> P;
const bool debugFlag=true;
const lint linf=1.1e18;const lint inf=1.01e9;
constexpr int MOD=1000000007;
template<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }

class SegTree{
    private:
    int n;
    vector<int> node;
    public:
    int process(int left,int right){
        if(left==inf)return right;
        if(right==inf)return left;
        int ans=left;
        if(left>right)ans=right;
        return ans;
    }
    void build(vector<int> v){
        int num=1;
        int size=v.size();
        while(num<size){
            num*=2;
        }
        n=num;
        node.resize(2*num-1,0);
        for(int i=0;i<size;i++)node[i+num-1]=v[i];
        for(int i=n-2;i>=0;i--)node[i]=process(node[i*2+1],node[i*2+2]);
    }
    int get(int x){
        x+=(n-1);
        int res=node[x];
        while(x>0){
            x=(x-1)/2;
            res+=node[x];
        }
        res+=node[0];
        return res;
    }
    void add(int a,int b,int value,int k=0,int l=0,int r=-1){
        if(r<0)r=n;
        if(a>=r||b<=l)goto FINE;
        if(a<=l&&b>=r){
            node[k]+=value;
            goto FINE;
        }
        add(a,b,value,k*2+1,l,(l+r)/2);
        add(a,b,value,k*2+2,(l+r)/2,r);
        //return process(vl,vr);
        FINE:;
    }
};

using E=int;

struct DualSegmentTree {
  int sz, height;
  vector<int> lazy;
  const int ei=0;

  void build(int n){
    sz = 1;
    height = 0;
    while(sz < n) sz <<= 1, height++;
    lazy.assign(2 * sz, ei);
  }

  inline void propagate(int k) {
    if(lazy[k] != ei) {
      lazy[2 * k + 0] = lazy[2 * k + 0]+lazy[k];
      lazy[2 * k + 1] =lazy[2 * k + 1]+lazy[k];
      lazy[k] = ei;
    }
  }

  inline void thrust(int k) {
    for(int i = height; i > 0; i--) propagate(k >> i);
  }

  void update(int a, int b, const E &x) {
    thrust(a += sz);
    thrust(b += sz - 1);
    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {
      if(l & 1) lazy[l] = lazy[l]+ x, ++l;
      if(r & 1) --r, lazy[r] = lazy[r]+ x;
    }
  }

  E operator[](int k) {
    thrust(k += sz);
    return lazy[k];
  }
};

signed main(){
  int h,w,n;cin>>h>>w>>n;
  bool hw=h>w;
  P s,g;cin>>s.first>>s.second>>g.first>>g.second;
  if(hw){
    swap(h,w);
    swap(s.first,s.second);
    swap(g.first,g.second);
  }
  vector<int> x(n),y(n),k(n);
  rep(i,n){
    if(hw)cin>>y[i]>>x[i]>>k[i];
    else cin>>x[i]>>y[i]>>k[i];
  }
  vector<DualSegmentTree> tree(h+10);
  rep1(i,h){
    tree[i].build(w+10);
  }
  rep(i,n){
    rep1(j,h){
      int l=y[i]-(k[i]-abs(j-x[i]));
      int r=y[i]+(k[i]-abs(j-x[i]));
      tree[j].update(l,r+1,1);
    }
  }
  vector<vector<int>> dp(h+1,vector<int>(w+1,0));
  queue<P> que;
  que.push(s);
  int dx[]={1,0,-1,0};
  int dy[]={0,1,0,-1};
  while(!que.empty()){
    auto [yy,xx]=que.front();que.pop();
    if(dp[yy][xx])continue;
    dp[yy][xx]=1;
    if(yy==g.first&&xx==g.second)break;
    rep(i,4){
      int xxx=xx+dx[i];
      int yyy=yy+dy[i];
      if(xxx<1||xxx>w)continue;
      if(yyy<1||yyy>h)continue;
      if(tree[yyy][xxx]>0)continue;
      if(dp[yyy][xxx])continue;
      que.push({yyy,xxx});
    }
  }
  if(dp[g.first][g.second]==1){
    cout<<"Yes"<<"\n";
  }
  else cout<<"No"<<"\n";
  return 0;
}
