

#include <bits/stdc++.h>
#include <iostream>
#include <limits>
#include <numeric>
#include <type_traits>
#include <bitset>
#include <map>
#include <unordered_map>
#include <set>

using namespace std;

#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)
#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)
using ll = long long;
const ll mod = 1000000007;//998244353;
const ll inf = 1e9;
const ll INF = 1e18;


void pline(vector<ll> lis){
    rep(i,0,lis.size()){
        printf ("%lld",lis[i]);
        if (i != lis.size()-1) printf(" ");
        else printf("\n");
    }
}

/*
void pmap(map<ll,mint>& lis){
    for (auto p : lis){
        printf ("%lld:%lld ,",p.first,p.second.val());
    }
    printf ("\n");
}*/

/*
void setxor(set<ll>& a,set<ll>& b){ // a ^= b
    for (ll x : b){
        if (a.count(x) > 0) a.erase(x);
        else a.insert(x);
    }
}

set<ll> setmin(set<ll> a,set<ll> b){

    auto aitr = a.begin();
    auto bitr = b.begin();

    while (aitr != a.end() && bitr != b.end()){
        if (*aitr < *bitr) return a;
        else if (*aitr > *bitr) return b;
        aitr++;
        bitr++;
    }

    if (*aitr == a.end()) return a;
    return b;

}
*/

char shift(char c , ll x){
    x %= 26;
    rep(i,0,x){
        if (c == 'z'){
            c = 'a';
        }else{
            c++;
        }
    }
    return c;
}

int main(){

    ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    //ModFac mf(200000);
    ll H,W;
    cin >> H >> W;
    
    vector<string> S(H);
    rep(i,0,H){
        cin >> S[i];
    }

    ll sx,sy;
    ll gx,gy;

    rep(i,0,H){
        rep(j,0,W){
            if (S[i][j] == 'S'){
                sx = i;
                sy = j;
                S[i][j] = '.';
            }
            if (S[i][j] == 'G'){
                gx = i;
                gy = j;
                S[i][j] = '.';
            }
        }
    }

    vector<vector<ll>> d(H,vector<ll> (W,inf));

    list<pair<ll,ll>> q;
    q.push_back( make_pair(sx,sy) );
    d[sx][sy] = 0;

    while (!q.empty()){

        auto xy = q.front(); q.pop_front();
        ll x = xy.first;
        ll y = xy.second;
        if (S[x][y] == '#'){
            continue;
        }else{

            //x-1
            {
                ll nexx = x-1;
                ll nexy = y;
                if ( 0 <= nexx && nexx < H && 0 <= nexy && nexy < W ){
                    if (S[x][y] == '.'){
                        if (d[nexx][nexy] > d[x][y] + 1){
                            d[nexx][nexy] = d[x][y] + 1;
                            q.push_back(make_pair(nexx,nexy));
                        }
                    }else if (S[x][y] == 'U'){
                        if (d[nexx][nexy] > d[x][y]){
                            d[nexx][nexy] = d[x][y];
                            q.push_front(make_pair(nexx,nexy));
                        }
                    }
                }
            }

            //x+1
            {
                ll nexx = x+1;
                ll nexy = y;
                if ( 0 <= nexx && nexx < H && 0 <= nexy && nexy < W ){
                    if (S[x][y] == '.'){
                        if (d[nexx][nexy] > d[x][y] + 1){
                            d[nexx][nexy] = d[x][y] + 1;
                            q.push_back(make_pair(nexx,nexy));
                        }
                    }else if (S[x][y] == 'D'){
                        if (d[nexx][nexy] > d[x][y]){
                            d[nexx][nexy] = d[x][y];
                            q.push_front(make_pair(nexx,nexy));
                        }
                    }
                }
            }

            //y-1
            {
                ll nexx = x;
                ll nexy = y-1;
                if ( 0 <= nexx && nexx < H && 0 <= nexy && nexy < W ){
                    if (S[x][y] == '.'){
                        if (d[nexx][nexy] > d[x][y] + 1){
                            d[nexx][nexy] = d[x][y] + 1;
                            q.push_back(make_pair(nexx,nexy));
                        }
                    }else if (S[x][y] == 'L'){
                        if (d[nexx][nexy] > d[x][y]){
                            d[nexx][nexy] = d[x][y];
                            q.push_front(make_pair(nexx,nexy));
                        }
                    }
                }
            }

            //y+1
            {
                ll nexx = x;
                ll nexy = y+1;
                if ( 0 <= nexx && nexx < H && 0 <= nexy && nexy < W ){
                    if (S[x][y] == '.'){
                        if (d[nexx][nexy] > d[x][y] + 1){
                            d[nexx][nexy] = d[x][y] + 1;
                            q.push_back(make_pair(nexx,nexy));
                        }
                    }else if (S[x][y] == 'R'){
                        if (d[nexx][nexy] > d[x][y]){
                            d[nexx][nexy] = d[x][y];
                            q.push_front(make_pair(nexx,nexy));
                        }
                    }
                }
            }

        }

    }

    ll ans = d[gx][gy];
    if (ans == inf){
        cout << -1 << endl;
    }else{
        cout << ans << endl;
    }

}

/*

G:


*/
