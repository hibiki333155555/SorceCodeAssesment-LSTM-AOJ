#include <bits/stdc++.h>
#define be(v) (v).begin(),(v).end()
#define pb(q) push_back(q)
#define rep(i, n) for(int i=0;i<n;i++)
#define all(i, v) for(auto& i : v)
typedef long long ll;
using namespace std;
const ll mod=998244353, INF=(1LL<<60);
#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;


// Doubling , LCA , dis , Tree
vector<vector<ll> > v;
struct Doubling {
private:
    ll sz;
    vector<vector<ll> > past;
    vector<ll> dis;
    void dfs(int now, int p = -1){
        past[now][0] = p;
        for(auto& to:v[now]){
            if(to == p)continue;
            dis[to] = dis[now] + 1;
            dfs(to, now);
        }
    }
public:
    // これを初めにやる
    void init(){
        sz = v.size();
        dis.resize(sz); dis[0] = 0;
        past.resize(sz, vector<ll> (20, -1));
        dfs(0);
        for(int j=0;j<19;j++)for(int i=0;i<sz;i++){
            if(past[i][j] != -1) past[i][j+1] = past[past[i][j]][j];
        }
    }
    // nowのm個前
    ll par(ll now, ll m){
        for(int i=0,j=1;j<=m;i++,j*=2) if(m&j) now = past[now][i];
        return now;
    }
    // a, bの最小共通祖先
    ll lca(ll a,ll b){
        if(dis[a] < dis[b]) b = par(b, dis[b] - dis[a]);
        else if(dis[a] > dis[b]) a = par(a, dis[a] - dis[b]);
        ll le = -1, ri = dis[a], mid;

        while(ri - le > 1){
            mid = (ri + le) / 2;
            if(par(a, mid) == par(b, mid)) ri = mid;
            else le = mid;
        }
        return par(a, ri);
    }
    // a, bの距離
    ll dist(ll a, ll b){return dis[a] + dis[b] - dis[lca(a,b)] * 2;}
} d;



///////modint
struct mint {
    ll x; // typedef long long ll;
    mint(ll x=0):x((x%mod+mod)%mod){}
    mint operator-() const { return mint(-x);}
    mint& operator+=(const mint a) {
        if ((x += a.x) >= mod) x -= mod;
        return *this;
    }
    mint& operator-=(const mint a) {
        if ((x += mod-a.x) >= mod) x -= mod;
        return *this;
    }
    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}
    mint operator+(const mint a) const { return mint(*this) += a;}
    mint operator-(const mint a) const { return mint(*this) -= a;}
    mint operator*(const mint a) const { return mint(*this) *= a;}
    mint pow(ll t) const {
        if(t < 0) return mint(1) / pow(-t);
        if (!t) return 1;
        mint a = pow(t>>1);
        a *= a;
        if (t&1) a *= *this;
        return a;
    }

    // for prime mod
    mint inv() const { return pow(mod-2);}
    mint& operator/=(const mint a) { return *this *= a.inv();}
    mint operator/(const mint a) const { return mint(*this) /= a;}
};



vector<mint> dp, dpout;
ll n;

void dfs1(int now, int pp = -1) {
    mint ret = mint(1);
    all(e, v[now]) {
        if(pp == e) continue;
        dfs1(e, now);
        ret += dp[e] * mint(2);
    }
    dp[now] = ret;
}

void dfs2(int now, mint p, int pp = -1) {
    int m = v[now].size();
    dpout[now] = p;
    vector<mint> v1(m + 1, mint(0));
    rep(i, m) {
        if(v[now][i] == pp) {
            v1[i + 1] = v1[i];
            continue;
        }
        v1[i + 1] = dp[v[now][i]] + v1[i];
    }
    rep(i, m) {
        if(v[now][i] == pp) {
            continue;
        }
        dfs2(v[now][i], p * mint(2) + mint(1) + (v1[m] - v1[i + 1] + v1[i]) * mint(4), now);
    }
}


int main() {
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    cin >> n;
    ll a, b;
    v.resize(n);
    dp.resize(n, mint(0));
    dpout.resize(n, mint(0));
    rep(i, n - 1) {
        cin >> a >> b;
        a--; b--;
        v[a].pb(b);
        v[b].pb(a);
    }
    d.init();
    dfs1(0);
    dfs2(0, mint(1));
    ll q;
    cin >> q;
    rep(i, q) {

        ll a, b;
        cin >> a >> b ;
        a--; b--;
        ll lc = d.lca(a, b);
        if(lc == a) {
            // cout << mint(2).pow(d.dist(a, b)).x << " " << dp[b].x << " " << dp[a].x << " " << dpout[a].x << " " << dp[b].x << endl;
            cout << (mint(2).pow(d.dist(a, b)) * dp[b] * (dp[a] + dpout[a] - dp[d.par(b, d.dist(a, b) - 1)] * mint(2) - mint(1))).x << endl;
        } else if(lc == b) {
            swap(a, b);
            cout << (mint(2).pow(d.dist(a, b)) * dp[b] * (dp[a] + dpout[a] - dp[d.par(b, d.dist(a, b) - 1)] * mint(2) - mint(1))).x << endl;
        } else {
            cout << (mint(2).pow(d.dist(a, b)) * dp[b] * dp[a]).x << endl;
        }
    }
    // rep(i, n) {
    //     cout << dp[i].x <<" " <<dpout[i].x << endl;
    // }
    return 0;
}
