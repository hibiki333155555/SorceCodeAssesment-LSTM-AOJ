#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>
#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef pair<int, int> pii;
typedef pair<pii, int> ppii;
typedef pair<int, pii> pipi;
typedef pair<ll, ll> pll;
typedef pair<pll, ll> ppll;
typedef pair<ll, pll> plpl;
typedef pair<pii, pii> pippi;
typedef tuple<ll, ll, ll> tl;
typedef pair<double, double> pdd;
typedef vector<vector<ll>> mat;
const ll mod=1000000007;
const ll mod2=998244353;
ll inf =numeric_limits<ll>::max() / 2;
int iinf=numeric_limits<int>::max() / 2;
double pi=3.14159265358979323846;
double eps=1e-10;
#define rep(i,m,n) for(ll i=m;i<n;i++)
#define rrep(i,n,m) for(ll i=n;i>=m;i--)
#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)
#define mrep(itr,mp) for(auto& itr:mp)
#define Max(a,b) a=max(a,b)
#define Min(a,b) a=min(a,b)
int dh[4] = {1,0,-1,0};
int dw[4] = {0,1,0,-1};
int ddh[8] = {-1,-1,-1,0,0,1,1,1 };
int ddw[8] = {-1,0,1,-1,1,-1,0,1 };
ll gcd(ll a,ll b) {
    if (a<0)a=-a;if(b<0)b=-b;if(a<b)swap(a,b);if(b==0)return a; if (a % b == 0)return b; return gcd(b, a % b);
}
ll lcm(ll a,ll b){ll c=gcd(a,b);return a*b/c;}
ll Pow(ll n,ll k) {
    if (k<0)return 0;ll ret=1;ll now=n;while(k>0){if(k&1)ret *= now; now *= now; k /= 2; }return ret;
}
ll beki(ll n,ll k,ll md) {
    ll ret =1;ll now=n;now%=md;
    while (k>0) {
        if (k%2==1){ret*=now;ret%=md;}
        now *= now; now %= md; k /= 2;
    }return ret;
}
ll gyaku(ll n,ll md){return beki(n,md-2,md);}
ll popcount(ll n) { ll ret = 0; ll u = n; while (u > 0) { ret += u % 2; u /= 2; }return ret; }
#ifndef ATCODER_INTERNAL_BITOP_HPP
#define ATCODER_INTERNAL_BITOP_HPP 1
#ifdef _MSC_VER
#include <intrin.h>
#endif
namespace atcoder {
    namespace internal {
        int ceil_pow2(int n) {
            int x = 0; while ((1U << x) < (unsigned int)(n)) x++; return x;
        }
        int bsf(unsigned int n) {
#ifdef _MSC_VER
            unsigned long index;
            _BitScanForward(&index, n);
            return index;
#else
            return __builtin_ctz(n);
#endif
        }
    }
}
#endif
#ifndef ATCODER_INTERNAL_MATH_HPP
#define ATCODER_INTERNAL_MATH_HPP 1
#include <utility>
namespace atcoder {
    namespace internal {
        constexpr long long safe_mod(long long x, long long m) {
            x %= m; if (x < 0)x += m; return x;}
        struct barrett {
            unsigned int _m;
            unsigned long long im;
            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}
            unsigned int umod() const { return _m; }
            unsigned int mul(unsigned int a, unsigned int b) const {
                unsigned long long z = a; z *= b;
#ifdef _MSC_VER
                unsigned long long x;
                _umul128(z, im, &x);
#else
                unsigned long long x =
                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
                unsigned int v = (unsigned int)(z - x * _m);
                if (_m <= v) v += _m;
                return v;
            }
        };
        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
            if (m == 1) return 0;
            unsigned int _m = (unsigned int)(m);
            unsigned long long r = 1;
            unsigned long long y = safe_mod(x, m);
            while (n) {
                if (n & 1) r = (r * y) % _m; y = (y * y) % _m; n >>= 1;
            }
            return r;}
        constexpr bool is_prime_constexpr(int n) {
            if (n <= 1) return false;
            if (n == 2 || n == 7 || n == 61) return true;
            if (n % 2 == 0) return false;
            long long d = n - 1;
            while (d % 2 == 0) d /= 2;
            for (long long a : {2, 7, 61}) {
                long long t = d;
                long long y = pow_mod_constexpr(a, t, n);
                while (t != n - 1 && y != 1 && y != n - 1) {
                    y = y * y % n; t <<= 1;
                }
                if (y != n - 1 && t % 2 == 0) { return false; } }
            return true;
        }
        template <int n> constexpr bool is_prime = is_prime_constexpr(n);
        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
            a = safe_mod(a, b);
            if (a == 0) return { b, 0 };
            long long s = b, t = a;
            long long m0 = 0, m1 = 1;
            while (t) {
                long long u = s / t; s -= t * u;  m0 -= m1 * u;
                auto tmp = s; s = t; t = tmp;
                tmp = m0;m0 = m1;m1 = tmp;}
            if (m0 < 0) m0 += b / s;
            return { s, m0 };
        }
        constexpr int primitive_root_constexpr(int m) {
            if (m == 2) return 1;
            if (m == 167772161) return 3;
            if (m == 469762049) return 3;
            if (m == 754974721) return 11;
            if (m == 998244353) return 3;
            int divs[20] = {};
            divs[0] = 2;
            int cnt = 1;
            int x = (m - 1) / 2;
            while (x % 2 == 0) x /= 2;
            for (int i = 3; (long long)(i)*i <= x; i += 2) {
                if (x % i == 0) {
                    divs[cnt++] = i;
                    while (x % i == 0) {
                        x /= i; } }}
            if (x > 1) { divs[cnt++] = x; }
            for (int g = 2;; g++) {
                bool ok = true;
                for (int i = 0; i < cnt; i++) {
                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
                        ok = false; break;
                    }
                }
                if (ok) return g; } }
        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);
    }
}
#endif
#ifndef ATCODER_INTERNAL_QUEUE_HPP
#define ATCODER_INTERNAL_QUEUE_HPP 1
#include <vector>
namespace atcoder {
    namespace internal {
        template <class T> struct simple_queue {
            std::vector<T> payload;
            int pos = 0;
            void reserve(int n) { payload.reserve(n); }
            int size() const { return int(payload.size()) - pos; }
            bool empty() const { return pos == int(payload.size()); }
            void push(const T& t) { payload.push_back(t); }
            T& front() { return payload[pos]; }
            void clear() {
                payload.clear(); pos = 0; }
            void pop() { pos++; } };}
}
#endif
#ifndef ATCODER_INTERNAL_SCC_HPP
#define ATCODER_INTERNAL_SCC_HPP 1
#include <algorithm>
#include <utility>
#include <vector>
namespace atcoder {
    namespace internal {
        template <class E> struct csr {
            std::vector<int> start;
            std::vector<E> elist;
            csr(int n, const std::vector<std::pair<int, E>>& edges)
                : start(n + 1), elist(edges.size()) {
                for (auto e : edges) { start[e.first + 1]++; }
                for (int i = 1; i <= n; i++) { start[i] += start[i - 1]; }
                auto counter = start;
                for (auto e : edges) { elist[counter[e.first]++] = e.second; } }
        };
        struct scc_graph {
        public:
            scc_graph(int n) : _n(n) {}
            int num_vertices() { return _n; }
            void add_edge(int from, int to) { edges.push_back({ from, {to} }); }
            std::pair<int, std::vector<int>> scc_ids() {
                auto g = csr<edge>(_n, edges);
                int now_ord = 0, group_num = 0;
                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);
                visited.reserve(_n);
                auto dfs = [&](auto self, int v) -> void {
                    low[v] = ord[v] = now_ord++;visited.push_back(v);
                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {
                        auto to = g.elist[i].to;
                        if (ord[to] == -1) {
                            self(self, to); low[v] = std::min(low[v], low[to]);
                        }
                        else { low[v] = std::min(low[v], ord[to]); }
                    }
                    if (low[v] == ord[v]) {
                        while (true) {
                            int u = visited.back();visited.pop_back(); ord[u] = _n; ids[u] = group_num; if (u == v) break;
                        }
                        group_num++;
                    }
                };
                for (int i = 0; i < _n; i++) {
                    if (ord[i] == -1) dfs(dfs, i);}
                for (auto& x : ids) {
                    x = group_num - 1 - x;}
                return { group_num, ids };
            }
            std::vector<std::vector<int>> scc() {
                auto ids = scc_ids();int group_num = ids.first;
                std::vector<int> counts(group_num);
                for (auto x : ids.second) counts[x]++;
                std::vector<std::vector<int>> groups(ids.first);
                for (int i = 0; i < group_num; i++) {
                    groups[i].reserve(counts[i]);
                }
                for (int i = 0; i < _n; i++) {
                    groups[ids.second[i]].push_back(i);
                }
                return groups;}
        private:
            int _n;
            struct edge {
                int to;
            };
            std::vector<std::pair<int, edge>> edges;
        };
    }
}
#endif
#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP
#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1
#include <cassert>
#include <numeric>
#include <type_traits>
namespace atcoder {
    namespace internal {
#ifndef _MSC_VER
        template <class T>
        using is_signed_int128 =
            typename std::conditional<std::is_same<T, __int128_t>::value ||
            std::is_same<T, __int128>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using is_unsigned_int128 =
            typename std::conditional<std::is_same<T, __uint128_t>::value ||
            std::is_same<T, unsigned __int128>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using make_unsigned_int128 =
            typename std::conditional<std::is_same<T, __int128_t>::value,
            __uint128_t,
            unsigned __int128>;
        template <class T>
        using is_integral = typename std::conditional<std::is_integral<T>::value ||
            is_signed_int128<T>::value ||
            is_unsigned_int128<T>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using is_signed_int = typename std::conditional<(is_integral<T>::value&&
            std::is_signed<T>::value) ||
            is_signed_int128<T>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using is_unsigned_int =
            typename std::conditional<(is_integral<T>::value&&
                std::is_unsigned<T>::value) ||
            is_unsigned_int128<T>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using to_unsigned = typename std::conditional<
            is_signed_int128<T>::value,
            make_unsigned_int128<T>,
            typename std::conditional<std::is_signed<T>::value,
            std::make_unsigned<T>,
            std::common_type<T>>::type>::type;
#else
        template <class T> using is_integral = typename std::is_integral<T>;
        template <class T>
        using is_signed_int =
            typename std::conditional<is_integral<T>::value&& std::is_signed<T>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using is_unsigned_int =
            typename std::conditional<is_integral<T>::value&&
            std::is_unsigned<T>::value,
            std::true_type,
            std::false_type>::type;
        template <class T>
        using to_unsigned = typename std::conditional<is_signed_int<T>::value,
            std::make_unsigned<T>,
            std::common_type<T>>::type;
#endif
        template <class T>
        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;
        template <class T>
        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;
        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;
    }
}
#endif

using namespace atcoder;
//#define endl "\n"
using mint = static_modint<mod>;

int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int h,w;cin>>h>>w;
    string s[h];
    rep(i,0,h)cin>>s[i];
    int ans=iinf;
    rep(i,1,h){
        int c0=0,c1=0;
        rep(j,0,i){
            rep(k,0,w){
                if(s[j][k]=='o')c0++;
                else c1++;
            }
        }
        int cc0=0,cc1=0;
        rep(j,i,h){
            rep(k,0,w){
                if(s[j][k]=='o')cc0++;
                else cc1++;
            }
        }
        Min(ans,min(c0+cc1,c1+cc0));
    }
    rep(i,1,w){
        int c0=0,c1=0;
        rep(j,0,i){
            rep(k,0,h){
                if(s[k][j]=='o')c0++;
                else c1++;
            }
        }
        int cc0=0,cc1=0;
        rep(j,i,w){
            rep(k,0,h){
                if(s[k][j]=='o')cc0++;
                else cc1++;
            }
        }
        Min(ans,min(c0+cc1,c1+cc0));
    }
    cout<<ans<<endl;
}

