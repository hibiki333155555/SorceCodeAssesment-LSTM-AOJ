use std::collections::BTreeMap;
use num_bigint::BigUint;
use mod_int::ModInt;

const MOD: i64 = 998244353;
fn main() {
    let (r, w) = (std::io::stdin(), std::io::stdout());
    let mut sc = IO::new(r.lock(), w.lock());

    loop {
        let n: usize = sc.read();
        let m: usize = sc.read();
        if n == 0 && m == 0 {
            break;
        }

        let mut s = Evaluator {
            memory: BTreeMap::new(),
            print: vec![],
        };
        for _ in 0..n {
            let line = sc.read::<String>();
            let statement = parse_line(&line);
            s.eval(&statement);
        }

        let mut t = Evaluator {
            memory: BTreeMap::new(),
            print: vec![],
        };
        for _ in 0..m {
            let line = sc.read::<String>();
            let statement = parse_line(&line);
            t.eval(&statement);
        }

        if s.print != t.print {
            sc.write("No\n");
        } else {
            sc.write("Yes\n");
        }
    }
}

struct Evaluator {
    memory: BTreeMap<String, i64>,
    print: Vec<(i64, i64)>,
}

impl Evaluator {
    fn eval(&mut self, statement: &Statement) {
        match statement {
            Statement::Declare { name } => {
                self.memory.insert(name.to_string(), 0);
            }
            Statement::Assign(assign) => {
                self.eval_assign(assign, 1);
            }
            Statement::Print(print) => {
                self.eval_print(print, 1);
            }
            Statement::For {
                for_elements,
                inner,
            } => {
                self.eval_for(for_elements, inner);
            }
        }
    }

    fn eval_expression(&self, expr: &Expression) -> i64 {
        let mut sum = 0;
        for term in expr.terms.iter() {
            let prefix = term.0;
            match &term.1 {
                Term::Value(var) => {
                    let value = self.memory.get(var).unwrap();
                    sum += prefix * (*value);
                    sum %= MOD;
                }
                Term::Number(v) => {
                    sum += prefix * (*v);
                    sum %= MOD;
                }
            }
        }
        sum
    }

    fn eval_assign(&mut self, assign: &Assignment, count: i64) {
        if count == 0 {
            return;
        }
        let mut x = 0;
        let mut other_terms = vec![];
        for term in assign.expr.terms.iter() {
            if let Term::Value(s) = &term.1 {
                if &assign.name == s {
                    x += term.0;
                } else {
                    other_terms.push(term.clone());
                }
            } else {
                other_terms.push(term.clone());
            }
        }
        let expr = Expression { terms: other_terms };
        let y = self.eval_expression(&expr);

        let c = *self.memory.get(&assign.name).unwrap();
        if x == 1 {
            let y = (y + MOD) % MOD;
            let add = (y * count) % MOD;
            let new_value = (c + add) % MOD;
            self.memory.insert(assign.name.to_string(), new_value);
            return;
        }

        // a <- x * a + y

        let xn = ModInt::from(x).pow(count);
        let an = xn * c * y * (xn - 1i64) / (x - 1);

        self.memory.insert(assign.name.to_string(), an.value());
    }

    fn eval_print(&mut self, print: &Print, count: i64) {
        if count == 0 {
            return;
        }
        let result = self.eval_expression(&print.expr);
        self.print.push((result, count));
    }

    fn eval_for(&mut self, loops: &[Expression], inner: &ForInner) {
        let mut loop_count = 1;
        for expr in loops {
            let result = self.eval_expression(expr);
            loop_count *= result;
            loop_count %= MOD;
        }

        match inner {
            ForInner::Assign(assign) => {
                self.eval_assign(assign, loop_count);
            }
            ForInner::Print(print) => {
                self.eval_print(print, loop_count);
            }
        }
    }
}

#[derive(Debug)]
enum Statement {
    Declare {
        name: String,
    },
    Assign(Assignment),
    Print(Print),
    For {
        for_elements: Vec<Expression>,
        inner: ForInner,
    },
}

#[derive(Debug)]
enum ForInner {
    Assign(Assignment),
    Print(Print),
}

#[derive(Debug)]
struct Assignment {
    name: String,
    expr: Expression,
}

#[derive(Debug)]
struct Print {
    expr: Expression,
}

#[derive(Debug, Clone)]
struct Expression {
    terms: Vec<(i64, Term)>,
}

#[derive(Debug, Clone)]
enum Term {
    Value(String),
    Number(i64),
}

fn parse_line(line: &str) -> Statement {
    if line.starts_with("for(") {
        // for
        let (mut elements, inner) = parse_for(line);
        elements.reverse();
        Statement::For {
            for_elements: elements,
            inner,
        }
    } else if line.starts_with("print(") {
        // print
        Statement::Print(parse_print(line))
    } else if line.contains("<-") {
        // assign
        Statement::Assign(parse_assignment(line))
    } else {
        // declare
        Statement::Declare {
            name: line.to_string(),
        }
    }
}

fn parse_print(line: &str) -> Print {
    let l = line.len();
    let expression = &line[6..(l - 1)];
    let expression = parse_expression(expression);
    Print { expr: expression }
}

fn parse_for(line: &str) -> (Vec<Expression>, ForInner) {
    if line.starts_with("for(") {
        let right = line.find(')').unwrap();
        let expression = &line[4..right];
        let expression = parse_expression(expression);

        let rest = &line[(right + 1)..];
        let (mut elements, inner) = parse_for(rest);
        elements.push(expression);
        (elements, inner)
    } else {
        let inner = parse_for_inner(line);
        (vec![], inner)
    }
}

fn parse_assignment(line: &str) -> Assignment {
    let i = line.find("<-").unwrap();
    let value_name = &line[..i];
    let expression = &line[(i + 2)..];

    Assignment {
        name: value_name.to_string(),
        expr: parse_expression(expression),
    }
}

fn parse_for_inner(for_inner: &str) -> ForInner {
    if for_inner.starts_with("print(") {
        ForInner::Print(parse_print(for_inner))
    } else {
        ForInner::Assign(parse_assignment(for_inner))
    }
}

fn parse_expression(expression: &str) -> Expression {
    let mut q = expression.bytes().collect::<Vec<_>>();
    let head = q[0];
    q.reverse();
    if head != b'-' {
        q.push(b'+');
    }
    q.reverse();

    let mut terms = vec![];
    while !q.is_empty() {
        let mut buf = vec![];
        let mut prefix = 1;
        while let Some(c) = q.pop() {
            if c == b'+' || c == b'-' {
                if c == b'-' {
                    prefix = -1;
                }
                break;
            } else {
                buf.push(c);
            }
        }
        buf.reverse();

        let term = if buf.len() == 1 && buf[0].is_ascii_alphabetic() {
            Term::Value(String::from_utf8(buf).unwrap())
        } else {
            let num = parse_number(&buf);
            Term::Number(num)
        };

        terms.push((prefix, term));
    }
    Expression { terms }
}

fn parse_number(buf: &[u8]) -> i64 {
    let mut x = ModInt::from(0);
    for &b in buf {
        x *= 10;
        x += (b - b'0') as i64;
    }
    x.value()
}

pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);

impl<R: std::io::Read, W: std::io::Write> IO<R, W> {
    pub fn new(r: R, w: W) -> Self {
        Self(r, std::io::BufWriter::new(w))
    }
    pub fn write<S: ToString>(&mut self, s: S) {
        use std::io::Write;
        self.1.write_all(s.to_string().as_bytes()).unwrap();
    }
    pub fn read<T: std::str::FromStr>(&mut self) -> T {
        use std::io::Read;
        let buf = self
            .0
            .by_ref()
            .bytes()
            .map(|b| b.unwrap())
            .skip_while(|&b| b == b' ' || b == b'\n' || b == b'\r' || b == b'\t')
            .take_while(|&b| b != b' ' && b != b'\n' && b != b'\r' && b != b'\t')
            .collect::<Vec<_>>();
        unsafe { std::str::from_utf8_unchecked(&buf) }
            .parse()
            .ok()
            .expect("Parse error.")
    }
    pub fn usize0(&mut self) -> usize {
        self.read::<usize>() - 1
    }
    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {
        (0..n).map(|_| self.read()).collect()
    }
    pub fn chars(&mut self) -> Vec<char> {
        self.read::<String>().chars().collect()
    }
}
pub mod mod_int {
    type ModInternalNum = i64;
    thread_local!(
        static MOD: std::cell::RefCell<ModInternalNum> = std::cell::RefCell::new(0);
    );

    pub fn set_mod_int<T: ToInternalNum>(v: T) {
        MOD.with(|x| x.replace(v.to_internal_num()));
    }
    fn modulo() -> ModInternalNum {
        998244353
    }

    #[derive(Debug)]
    pub struct ModInt(ModInternalNum);
    impl Clone for ModInt {
        fn clone(&self) -> Self {
            Self(self.0)
        }
    }
    impl Copy for ModInt {}

    impl ModInt {
        fn internal_new(mut v: ModInternalNum) -> Self {
            let m = modulo();
            if v >= m {
                v %= m;
            }
            Self(v)
        }

        pub fn internal_pow(&self, mut e: ModInternalNum) -> Self {
            let mut result = 1;
            let mut cur = self.0;
            let modulo = modulo();
            while e > 0 {
                if e & 1 == 1 {
                    result *= cur;
                    result %= modulo;
                }
                e >>= 1;
                cur = (cur * cur) % modulo;
            }
            Self(result)
        }

        pub fn pow<T>(&self, e: T) -> Self
        where
            T: ToInternalNum,
        {
            self.internal_pow(e.to_internal_num())
        }

        pub fn value(&self) -> ModInternalNum {
            self.0
        }
    }

    pub trait ToInternalNum {
        fn to_internal_num(&self) -> ModInternalNum;
    }
    impl ToInternalNum for ModInt {
        fn to_internal_num(&self) -> ModInternalNum {
            self.0
        }
    }
    macro_rules! impl_primitive {
        ($primitive:ident) => {
            impl From<$primitive> for ModInt {
                fn from(v: $primitive) -> Self {
                    let v = v as ModInternalNum;
                    Self::internal_new(v)
                }
            }
            impl ToInternalNum for $primitive {
                fn to_internal_num(&self) -> ModInternalNum {
                    *self as ModInternalNum
                }
            }
        };
    }
    impl_primitive!(u8);
    impl_primitive!(u16);
    impl_primitive!(u32);
    impl_primitive!(u64);
    impl_primitive!(usize);
    impl_primitive!(i8);
    impl_primitive!(i16);
    impl_primitive!(i32);
    impl_primitive!(i64);
    impl_primitive!(isize);

    impl<T: ToInternalNum> std::ops::AddAssign<T> for ModInt {
        fn add_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }

            self.0 += rhs;
            if self.0 >= m {
                self.0 -= m;
            }
        }
    }

    impl<T: ToInternalNum> std::ops::Add<T> for ModInt {
        type Output = ModInt;
        fn add(self, rhs: T) -> Self::Output {
            let mut res = self;
            res += rhs;
            res
        }
    }
    impl<T: ToInternalNum> std::ops::SubAssign<T> for ModInt {
        fn sub_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            if rhs > 0 {
                self.0 += m - rhs;
            }
            if self.0 >= m {
                self.0 -= m;
            }
        }
    }
    impl<T: ToInternalNum> std::ops::Sub<T> for ModInt {
        type Output = Self;
        fn sub(self, rhs: T) -> Self::Output {
            let mut res = self;
            res -= rhs;
            res
        }
    }
    impl<T: ToInternalNum> std::ops::MulAssign<T> for ModInt {
        fn mul_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            self.0 *= rhs;
            self.0 %= m;
        }
    }
    impl<T: ToInternalNum> std::ops::Mul<T> for ModInt {
        type Output = Self;
        fn mul(self, rhs: T) -> Self::Output {
            let mut res = self;
            res *= rhs;
            res
        }
    }

    impl<T: ToInternalNum> std::ops::DivAssign<T> for ModInt {
        fn div_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            let inv = Self(rhs).internal_pow(m - 2);
            self.0 *= inv.value();
            self.0 %= m;
        }
    }

    impl<T: ToInternalNum> std::ops::Div<T> for ModInt {
        type Output = Self;
        fn div(self, rhs: T) -> Self::Output {
            let mut res = self;
            res /= rhs;
            res
        }
    }
}

