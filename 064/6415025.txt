#!usr/bin/env python3
from collections import defaultdict, deque
from heapq import heappush, heappop
from itertools import permutations, accumulate
import sys
import math
import bisect
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def IR(n):
    return [I() for _ in range(n)]
def LIR(n):
    return [LI() for _ in range(n)]

sys.setrecursionlimit(1000000)
mod = 998244353 


mod = 469762049

def ntt(a, mod, n, sig=1):
    fa = a+[0]*(n-len(a))
    h = pow(3, (mod - 1) // n, mod)
    if sig < 0:
        h = pow(h, mod-2, mod)
    i = 0
    m = n >> 1
    for j in range(1, n - 1):
        k = m
        i ^= k
        while i < k:
            k >>= 1
            i ^= k
        if j < i:
            fa[i], fa[j] = fa[j], fa[i]
    m = 1
    while m < n:
        m2 = m << 1
        base = pow(h, n // m2, mod)
        w = 1
        for x in range(m):
            for i in range(x, n, m2):
                j = i + m
                u = fa[i]
                d = fa[j] * w
                if d >= mod:
                    d %= mod
                fai = u + d
                if mod <= fai:
                    fai -= mod
                fa[i] = fai
                faj = u - d
                if faj < 0:
                    faj += mod
                fa[j] = faj
            w *= base
            if w >= base:
                w %= mod
        m = m2

    for i in range(n):
        if fa[i] < 0:
            fa[i] += mod
    return fa


def intt(a, mod, n):
    inv = pow(n, mod-2, mod)
    res = ntt(a, mod, n, -1)
    return [ri*inv%mod for ri in res]


def convolve(a, b, mod):
    l = len(a)+len(b)
    n = 1<<(l-1).bit_length()
    Fa = ntt(a, mod, n)
    Fb = ntt(b, mod, n)
    F = [fa * fb % mod for fa, fb in zip(Fa,Fb)]
    f = intt(F, mod, n)
    return f[:l]


def main():
    def dfs(x):
        d[x] = 0
        ax = a[x]
        if ax <= k:
            dp[x][ax] = 1
        for y in v[x]:
            if d[y]:
                dfs(y)
            dp[x] = convolve(dp[x],dp[y],998244353)[:k+1]
        dp[x][0] = 1
        return 
      
    n,k = LI()
    a = LI()
    p = LI()
    v = [[] for _ in range(n)]
    for i,pi in enumerate(p,1):
        pi -= 1
        v[pi].append(i)
    dp = [[0]*(k+1) for _ in range(n)]
    d = [1]*n
    dfs(0)
    print(dp[0][k])
    return


if __name__ == "__main__":
    main()

