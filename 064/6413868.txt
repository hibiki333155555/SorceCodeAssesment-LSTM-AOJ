class Convolution(private val mod: Long) {
    private val r2: Long = R * R % mod
    private val invMod: Long = invPair(R, mod).second
    private val sumE: LongArray = LongArray(30)
    private val sumIE: LongArray = LongArray(30)
    init {
        val es = LongArray(30)
        val ies = LongArray(30)
        val cnt = Integer.numberOfTrailingZeros(mod.toInt() - 1)
        val root = primitiveRoot(mod)
        val base = powMod(root, (mod - 1) shr cnt, mod)
        var e = reduce(r2 * base)
        var ie = reduce(r2 * inv(base, mod))
        for (i in (2 .. cnt).reversed()) {
            es[i - 2] = e
            ies[i - 2] = ie
            e = reduce(e * e)
            ie = reduce(ie * ie)
        }
        e = R
        ie = R
        for (i in 0 until cnt - 2){
            sumE[i] = reduce(es[i] * e)
            e = reduce(e * ies[i])
            sumIE[i] = reduce(ies[i] * ie)
            ie = reduce(ie * es[i])
        }
    }
    private inline fun reduce(a: Long): Long {
        val a = ((((((a and Mask) * invMod) and Mask) * mod + a) shr Shift))
        return if (a < mod) a else a - mod
    }
    private inline fun modMinus(a: Long): Long {
        return if (0 <= a) a else a + mod
    }
    private inline fun modPlus(a: Long): Long {
        return if (a < mod) a else a - mod
    }
    companion object {
        const val Shift = 31
        const val R = 1L shl Shift
        const val Mask = R - 1
        fun primitiveRoot(mod: Long): Long {
            if (mod == 998244353L) return 3
            if (mod == 167772161L) return 3
            if (mod == 469762049L) return 3
            if (mod == 754974721L) return 11
            val divs = IntArray(20)
            divs[0] = 2
            var cnt = 1
            var x = (mod - 1) shr 1
            while (x and 1 == 1L) x = x shr 1
            var i = 3L
            while (i * i <= x) {
                if (x % i == 0L) {
                    divs[cnt++] = i.toInt()
                    while (x % i == 0L) {
                        x /= i
                    }
                }
                i += 2
            }
            if (x > 1) {
                divs[cnt++] = x.toInt()
            }
            var g = 2L
            while (true) {
                var ok = true
                for (i in 0 until cnt) {
                    if (powMod(g, (mod - 1) / divs[i], mod) == 1L) {
                        ok = false
                        break
                    }
                }
                if (ok) return g
                ++g
            }
        }
        fun powMod(base: Long, exp: Long, mod: Long): Long {
            var result = 1L
            var b = base
            var e = exp
            while (e > 0) {
                if ((e and 1) == 1L) result = result * b % mod
                b = b * b % mod
                e = e shr 1
            }
            return result
        }
        fun inv(value: Long, mod: Long): Long {
            return invPair(value, mod).first.let{if (it >= 0) it else it + mod}
        }
        fun invPair(a: Long, b: Long): Pair<Long, Long> {
            val (x, y) = invGcd(a, b)
            return (if (x < 0) x + b else x) to (if (y < 0) -y else a - y)
        }
        fun gcd(a: Long, b: Long): Long {
            return when (b) {
                0L -> a
                else -> gcd(b, a % b)
            }
        }
        fun invGcd(a: Long, b: Long): Pair<Long, Long> {
            if (b == 0L) return 1L to 0L
            val q = a / b
            val (x, y) = invGcd(b, a % b)
            return y to x - y * q
        }
        private fun ceilPow2(value: Int): Int {
            var r = 0
            while (1L shl r < value) ++r
            return r
        }
    }
    private fun butterfly(a: LongArray) {
        val n = a.size
        val h = ceilPow2(n)
        val se = sumE
        for (ph in 1..h) {
            val w = 1 shl (ph - 1)
            val p = 1 shl (h - ph)
            var now = reduce(r2)
            for (s in 0 until w) {
                val offset = s shl (h - ph + 1)
                for (i in 0 until p) {
                    val left = a[i + offset]
                    val right = reduce(a[i + offset + p] * now)
                    a[i + offset] = modPlus(left + right)
                    a[i + offset + p] = modMinus(left - right)
                }
                now = reduce(now * se[Integer.numberOfTrailingZeros(s.inv())])
            }
        }
    }
    private fun butterflyInv(a: LongArray) {
        val n = a.size
        val h = ceilPow2(n)
        val sie = sumIE
        for (ph in (1 .. h).reversed()) {
            val w = 1 shl (ph - 1)
            val p = 1 shl (h - ph)
            var now = reduce(r2)
            for (s in 0 until w) {
                val offset = s shl (h - ph + 1)
                for (i in 0 until p) {
                    val left = a[i + offset]
                    val right = a[i + offset + p]
                    a[i + offset] = modPlus(left + right)
                    a[i + offset + p] = reduce(now * (left - right + mod))
                }
                now = reduce(now * sie[Integer.numberOfTrailingZeros(s.inv())])
            }
        }
    }
    fun convolution(a: IntArray, b: IntArray): LongArray {
        val n = a.size
        val m = b.size
        if (n == 0 || m == 0) return LongArray(0)
        val z = 1 shl ceilPow2(n + m - 1)
        val ra = LongArray(z)
        val rb = LongArray(z)
        for (i in 0 until n) {
            ra[i] = reduce(r2 * a[i])
        }
        for (i in 0 until m) {
            rb[i] = reduce(r2 * b[i])
        }
        butterfly(ra)
        butterfly(rb)
        for (i in 0 until z) {
            ra[i] = reduce(ra[i] * rb[i])
        }
        butterflyInv(ra)
        val result = ra.copyOf(n + m - 1)
        val invZ = reduce(r2 * inv(z.toLong(), mod))
        for (i in result.indices) {
            result[i] = reduce(reduce(result[i] * invZ))
        }
        return result
    }
    fun convolution(a: LongArray, b: LongArray): LongArray {
        val n = a.size
        val m = b.size
        if (n == 0 || m == 0) return LongArray(0)
        val z = 1 shl ceilPow2(n + m - 1)
        val ra = LongArray(z)
        val rb = LongArray(z)
        for (i in 0 until n) {
            ra[i] = reduce(r2 * a[i])
        }
        for (i in 0 until m) {
            rb[i] = reduce(r2 * b[i])
        }
        butterfly(ra)
        butterfly(rb)
        for (i in 0 until z) {
            ra[i] = reduce(ra[i] * rb[i])
        }
        butterflyInv(ra)
        val result = ra.copyOf(n + m - 1)
        val invZ = reduce(r2 * inv(z.toLong(), mod))
        for (i in result.indices) {
            result[i] = reduce(reduce(result[i] * invZ))
        }
        return result
    }
}
class CRT(val modA: Long, val modB: Long) {
    constructor(modA: Int, modB: Int): this(modA.toLong(), modB.toLong())
    private val x: Long
    private val y: Long
    private val mod: Long = modA * modB
    init {
        val (a, b) = extendedGcd(modA, modB)
        x = (modB + a) % modB
        y = (modA + b) % modA
    }
    fun solve(ra: Int, rb: Int): Long {
        return (rb * x % modB * modA + ra * y % modA * modB) % mod
    }
    companion object {
        tailrec fun gcd(a: Long, b: Long): Long {
            return when(b) {
                0L -> a
                else -> gcd(b, a % b)
            }
        }
        fun extendedGcd(a: Long, b: Long): Pair<Long, Long> {
            var x = 1L
            var y = 0L
            var z = 0L
            var w = 1L
            val g = gcd(a, b)
            while (a * x + b * y > g) {
                val p = (a * x + b * y) / (a * z + b * w)
                val nz = x - z * p
                val nw = y - w * p
                x = z
                y = w
                z = nz
                w = nw
            }
            return x to y
        }
    }
}
fun convolution(a: LongArray, b: LongArray): LongArray {
    val mod1 = 754974721L
    val mod2 = 167772161L
    val c1 = Convolution(mod1).convolution(a, b)
    val c2 = Convolution(mod2).convolution(a, b)
    val crt = CRT(mod1, mod2)
    return LongArray(c1.size){
        crt.solve(c1[it].toInt(), c2[it].toInt())
    }
}

fun solve2(n: Long): Pair<Int, Int> {
    return if (n <= 2) 1 to 1 else 0 to 0

}
fun brute(prime: Int, n: Long): Pair<Int, Int> {
    fun times(left: Pair<Long, Long>, right: Pair<Long, Long>): Pair<Long, Long> {
        return ((left.first * right.first - left.second * right.second) % prime) to ((left.first * right.second + left.second * right.first) % prime)
    }
    fun pow(base: Pair<Long, Long>, exp: Long): Pair<Long, Long> {
        var result = 1L to 0L
        var b = base
        var e = exp
        while (e > 0) {
            if ((e and 1) == 1L) {
                result = times(result, b)
            }
            b = times(b, b)
            e = e shr 1
        }
        return result
    }
    var result = 1L to 0L
    for (i in 0 .. n) {
        for (j in 0 .. n) {
            if (i % prime == 0L && j % prime == 0L) continue
            result = times(result, i to j)
        }
    }
    return result.let { (i, j) -> ((i + prime) % prime).toInt() to ((j + prime) % prime).toInt() }
}
fun solve(prime: Int, n: Long): Pair<Int, Int> {
    if (prime == 2) return solve2(n)
    fun times(left: Pair<Long, Long>, right: Pair<Long, Long>): Pair<Long, Long> {
        return ((left.first * right.first - left.second * right.second) % prime) to ((left.first * right.second + left.second * right.first) % prime)
    }
    fun pow(base: Pair<Long, Long>, exp: Long): Pair<Long, Long> {
        var result = 1L to 0L
        var b = base
        var e = exp
        while (e > 0) {
            if ((e and 1) == 1L) {
                result = times(result, b)
            }
            b = times(b, b)
            e = e shr 1
        }
        return result
    }
    val eMod = (prime - 1) * 4
    val count = LongArray(prime)
    val found = BooleanArray(prime)
    for (a in 0 until prime) {
        val rest = a.toLong() * a % prime
        val c = (n - a + prime) / prime % eMod
        count[rest.toInt()] = (count[rest.toInt()] + c) % eMod
        found[rest.toInt()] = found[rest.toInt()] || (n >= a)
    }
    for (i in 1 until prime) {
        if (found[i] && found[prime - i]) return 0 to 0
    }
    val conv = convolution(count, count)
    var complex = 1L to 0L
    for (a in 0 until prime) {
        val rest = a.toLong() * a % prime
        val c = (n - a + prime) / prime
        conv[2 * rest.toInt()] = (conv[2 * rest.toInt()] - c % eMod + eMod) % eMod
        if (a == 0) continue
        complex = times(complex, pow(a.toLong() to a.toLong(), c))
    }
    for (a in 1 until conv.size) {
        if (a == prime) continue
        val e = conv[a] / 2 % (eMod shr 1)
        val pair = pow(0L to a.toLong(), e)
        complex = times(complex, pair)
    }
    val (real, imag) = complex
    return ((real + prime) % prime).toInt() to ((imag + prime) % prime).toInt()
}
fun test() {
    for (p in 2 until 3) {
        if ((2 until p).any { p % it == 0 }) continue
        for (n in 1L .. 500L) {
            if (temp.brute(p, n) != temp.solve(p, n)) {
                println("wrong")
            }
            println(solve(p, n))
        }
        println("ok: $p")
    }
    println("ok")
}
fun main() {
    val (prime, n) = readLine()!!.split(' ').let { (p, n) -> p.toInt() to n.toLong() }
    val (real, imag) = solve(prime, n)
    println("$real $imag")
}
