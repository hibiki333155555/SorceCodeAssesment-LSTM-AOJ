#include <bits/stdc++.h>
using namespace std;

struct scc_graph {
private:
    int n;
    struct edge {
        int from;
        int to;
    };
    vector<vector<int>> g;
    vector<vector<int>> rg;
    vector<edge> es;

public:
    vector<int> comp;
    scc_graph(int n_) {
        n = n_;
        g.resize(n);
        rg.resize(n);
        comp.resize(n, -1);
    }
    void add_edge(int u, int v) {
        // u -> v
        assert(0 <= u && u < n && 0 <= v && v < n);
        g[u].push_back(v);
        rg[v].push_back(u);
        es.push_back({u, v});
    }
    vector<vector<int>> scc() {
        vector<bool> seen(n);
        vector<int> ord(n);
        int t = 0;  // timer
        int k = 0;  // the number of strongly connected components
        auto dfs1 = [&](auto self, int v) -> void {
            seen[v] = true;
            for (auto nv : g[v]) {
                if (seen[nv]) continue;
                self(self, nv);
            }
            ord[v] = t++;
        };
        auto dfs2 = [&](auto self, int v) -> void {
            comp[v] = k;
            for (auto nv : rg[v]) {
                if (comp[nv] != -1) continue;
                self(self, nv);
            }
        };
        for (int i = 0; i < n; i++) {
            if (!seen[i]) {
                dfs1(dfs1, i);
            }
        }
        vector<int> v(n);
        iota(v.begin(), v.end(), 0);
        sort(v.begin(), v.end(), [&](int i, int j) { return ord[i] > ord[j]; });
        for (int i = 0; i < n; i++) {
            if (comp[i] == -1) {
                dfs2(dfs2, i);
                k++;
            }
        }
        vector<int> sv;
        vector<vector<int>> ng(k);
        vector<int> in(k);
        for (int i = 0; i < int(es.size()); i++) {
            auto [u, v] = es[i];
            u = comp[u];
            v = comp[v];
            if (u == v) continue;
            ng[u].push_back(v);
            in[v]++;
        }
        queue<int> que;
        for (int i = 0; i < k; i++) {
            if (in[i] == 0) {
                que.push(i);
            }
        }
        while (que.size()) {
            int v = que.front();
            que.pop();
            for (auto nv : ng[v]) {
                in[nv]--;
                if (in[nv] == 0) {
                    que.push(nv);
                }
            }
            sv.push_back(v);
        }
        vector<int> idx(k);
        for (int i = 0; i < k; i++) idx[sv[i]] = i;
        vector<vector<int>> ret(k);
        for (int i = 0; i < n; i++) ret[idx[comp[i]]].push_back(i);
        return ret;
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    scc_graph g(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        g.add_edge(u, v);
    }
    vector<vector<int>> scc = g.scc();
    int q;
    cin >> q;
    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << (g.comp[u] == g.comp[v]) << "\n";
    }
}
