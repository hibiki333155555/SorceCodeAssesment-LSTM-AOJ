#include <bits/stdc++.h>

using namespace std;

template<int mod>
class modint{
public:
    int n;
    modint(long long n):n(((n%mod)+mod)%mod){}
    modint():n(0){}

    modint pow(int y){
        modint res(1);
        modint sum = *this;
        while(y){
            if(y&1)res = res * sum;
            y >>= 1;
            sum = sum * sum;
        }
        return res;
    }

    modint inv(){
        return pow(mod-2);
    }

    modint operator+(modint that){return modint(n+that.n);}
    modint operator-(modint that){return modint(n-that.n);}
    modint operator*(modint that){return modint((long long)n*that.n);}
    modint operator/(modint that){return modint((long long)n*(that.inv().n));}
};

template<int mod>
ostream& operator<<(ostream&os,modint<mod> m){
    os << m.n;
    return os;
}

using mint = modint<998244353>;

mint factorial(int n){
    if(n<=1)return 1;
    static vector<mint> dp(2,1);
    while((int)dp.size()<=n){
        mint add = dp.back() * dp.size();
        dp.emplace_back(add);
    }
    return dp[n];
}

mint combination(int n,int m){
    return factorial(n) / (factorial(n-m) * factorial(m));
}

mint func(){
    string N;
    cin >> N;
    int n = N.size();
    int k;
    cin >> k;
    mint res = 0;
    int cnt = 0;
    mint sum = 0;
    for(int i=0;i<n;++i){
        sum = sum * 2;
        if(N[i]=='0'){
            continue;
        }else if(N[i]=='1'){
            int rems = n - i - 1;
            int ones = k - cnt;
            if(0 <= ones and ones <= rems){
                res = res + combination(rems,ones) * ((mint(2).pow(rems)-1) * ones / rems + sum * mint(2).pow(rems));
            }
            ++cnt;
            sum = sum + 1;
        }else{
            exit(1);
        }
    }
    if(cnt == k){
        res = res + sum;
    }
    return res;
}

int main(){
    cout << func() << endl;
}

