#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define X first
#define Y second
using namespace std;

typedef long long int ll;
typedef vector <int> vi;
typedef pair <int,int> pii;
const int Size=1e6+10;
const ll INF=0x3f3f3f3f3f3f3f3f;

inline int read()
{
    int x=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {x=x*10+ch-'0'; ch=getchar();}
    return x*f;
}

//d：维护区间min
//单点修改，区间查询
struct node{
    int l,r;
    ll d;
};
class segmentTree
{
public:
    int *a;
    //node st[4*Size];
    vector<node> st;

    void init(int a[],int n)
    {
        this->a=a;
        st.resize(4*n+10);
    }
    inline void pushup(int x)
    {
        st[x].d=min(st[2*x].d,st[2*x+1].d);
    }

    void build(int l,int r,int x)
    {
        st[x].l=l; st[x].r=r;
        if (l==r) {st[x].d=a[l]; return;}
        int m=(l+r)/2;
        build(l,m,2*x); build(m+1,r,2*x+1);
        pushup(x);
    }

    void point_update(int pos,int k,int x=1)
    {
        if (st[x].l==st[x].r) {st[x].d+=k; return;}

        int m=(st[x].l+st[x].r)/2;
        if (pos<=m) point_update(pos,k,2*x);
        if (pos>m) point_update(pos,k,2*x+1);
        pushup(x);
    }

    ll range_query(int l,int r,int x=1)
    {
        if (l<=st[x].l && st[x].r<=r) return st[x].d;

        int m=(st[x].l+st[x].r)/2;
        ll res=INF;
        if (l<=m) res=min(res,range_query(l,r,2*x));
        if (r>m) res=min(res,range_query(l,r,2*x+1));
        return res;
    }
};

int a[Size];
//segmentTree tree[1010];
vector<segmentTree> tree;

int main()
{
    while (1)
    {
        int r=read(),c=read(),q=read();
        if (!r || !c) break;

        bool _rotate=(c<r);
        int ini_r=r,ini_c=c;
        int mn=min(r,c),mx=max(r,c);
        r=mn; c=mx;

        tree.clear();
        tree.resize(r+10);
        memset(a,0,sizeof(a));
        for (int i=0;i<r;++i)
        {
            tree[i].init(a,c);
            tree[i].build(0,c-1,1);
        }

        int t;
        for (int i=0;i<ini_r;++i)
                for (int j=0;j<ini_c;++j)
                {
                    t=read();
                    if (!_rotate) tree[i].point_update(j,t);
                        else tree[j].point_update(i,t);
                }

        while (q--)
        {
            int r1=read(),c1=read(),r2=read(),c2=read();
            if (_rotate) swap(r1,c1),swap(r2,c2);

            ll mn=INF;
            for (int i=r1;i<=r2;++i)
                mn=min(mn,tree[i].range_query(c1,c2));
            printf("%lld\n",mn);
        }
    }

    return 0;
}

