#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>
#include <queue>
#include <string>
#include <iomanip>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <utility>
#include <stdio.h>
#include <math.h>
#include <assert.h>
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
#endif
using namespace std;
using ll=long long;

int main(){
  ll H,W,N;
  cin>>H>>W>>N;
  vector<vector<int>> d(H,vector<int>(W,0));
  ll sx,sy,gx,gy;
  cin>>sx>>sy>>gx>>gy;
  sx--;sy--;gx--;gy--;
  for(int i=0;i<N;i++){
    ll x,y,k;
    cin>>x>>y>>k;
    x--;y--;
    for(int j=0;j<=k;j++){
      d[x-(k-j)][y+j]=1;
      d[x+(k-j)][y-j]=1;
      d[x+(k-j)][y+j]=1;
      d[x-(k-j)][y-j]=1;
    }
  }
  // for(auto i:d){
  //   for(auto j:i){
  //     cerr<<j<<" ";
  //   }cerr<<endl;
  // }
  deque<pair<ll,ll>> dq;
  dq.push_back(make_pair(sx,sy));
  vector<pair<int,int>> ar={{0,1},{0,-1},{1,0},{-1,0}};
  while(!dq.empty()){
    pair<ll,ll> q=dq.front();dq.pop_front();
    d[q.first][q.second]=-1;
    for(pair<int,int> x:ar){
      int i=x.first;
      int j=x.second;
      if(0<=q.first+i && q.first+i<H && 0<=q.second+j && q.second+j<W && d[q.first+i][q.second+j]==0){
        d[q.first+i][q.second+j]=-1;
        dq.push_back(make_pair(q.first+i,q.second+j));
      }
    }
  }
  if(d[gx][gy]==-1){
    cout<<"Yes"<<endl;
  }else{
    cout<<"No"<<endl;
  }
  // for(auto i:d){
  //   for(auto j:i){
  //     cerr<<j<<" ";
  //   }cerr<<endl;
  // }
}


