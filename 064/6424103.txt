#line 2 "lib/prelude.hpp"
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#endif
#include <bits/stdc++.h>
using namespace std;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
#define rep2(i, m, n) for (auto i = (m); i < (n); i++)
#define rep(i, n) rep2(i, 0, n)
#define repr2(i, m, n) for (auto i = (n); i-- > (m);)
#define repr(i, n) repr2(i, 0, n)
#define all(x) begin(x), end(x)
#line 3 "lib/graph.hpp"

struct unit_edge {
  int v;
  int to() const { return v; }
  operator int() const { return to(); }
  int w() const { return 1; }
};

template <class Weight>
struct weighted_edge {
  int v;
  Weight weight;
  int to() const { return v; }
  operator int() const { return to(); }
  Weight w() const { return weight; }
};

template <class Inner>
struct basic_graph {
  using weight_type = int;
  constexpr static bool weighted = false;
  const Inner& inner;
  basic_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto u : inner[v]) f(unit_edge{u});
  }
};

template <class Inner, class Weight>
struct basic_weighted_graph {
  using weight_type = Weight;
  constexpr static bool weighted = true;
  const Inner& inner;
  basic_weighted_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto [u, w] : inner[v]) f(weighted_edge<weight_type>{u, w});
  }
};

template <class T>
struct graph_trait : public T {
  graph_trait(T t) : T(move(t)) {}
};

template <class T>
using W = typename graph_trait<T>::weight_type;

template <size_t N>
struct graph_trait<vector<int>[N]> : basic_graph<vector<int>[N]> {
  using basic_graph<vector<int>[N]>::basic_graph;
  int size() const { return N; }
};

template <>
struct graph_trait<vector<vector<int>>> : basic_graph<vector<vector<int>>> {
  using basic_graph<vector<vector<int>>>::basic_graph;
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};

template <size_t N, class Weight>
struct graph_trait<vector<pair<int, Weight>>[N]>
    : basic_weighted_graph<vector<pair<int, Weight>>[N], Weight> {
  using basic_weighted_graph<vector<pair<int, Weight>>[N],
                             Weight>::basic_weighted_graph;
  int size() const { return N; }
};

template <class Weight>
struct graph_trait<vector<vector<pair<int, Weight>>>>
    : basic_weighted_graph<vector<vector<pair<int, Weight>>>, Weight> {
  using basic_weighted_graph<vector<vector<pair<int, Weight>>>,
                             Weight>::basic_weighted_graph;
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};
#line 3 "lib/graph/scc.hpp"

template <class G>
class scc {
 public:
  scc(const G& graph) : g(graph), id_(g.size()), n_cpnts(0) {
    vector<char> visited(g.size(), false);
    vector<int> post_ord;
    post_ord.reserve(g.size());
    vector<vector<int>> rev_graph(g.size());
    auto dfs = [&](auto&& f, int v) -> void {
      visited[v] = true;
      g.adj(v, [&](int u) {
        rev_graph[u].push_back(v);
        if (!visited[u]) f(f, u);
      });
      post_ord.push_back(v);
    };
    rep(v, g.size()) if (!visited[v]) dfs(dfs, v);
    reverse(all(post_ord));
    fill(all(visited), false);
    auto dfs2 = [&](auto&& f, int v) -> void {
      visited[v] = true;
      id_[v] = n_cpnts;
      for (auto u : rev_graph[v])
        if (!visited[u]) f(f, u);
    };
    for (auto v : post_ord)
      if (!visited[v]) dfs2(dfs2, v), n_cpnts++;
  }

  int id(int v) const { return id_[v]; }

  vector<vector<int>> groups() const {
    vector<vector<int>> res(n_cpnts);
    rep(v, g.size()) res[id(v)].push_back(v);
    return res;
  }

  template <class G1 = G, enable_if_t<!graph_trait<G1>::weighted>* = nullptr>
  vector<vector<vector<int>>> components() const {
    vector<int> v;
    return components(v);
  }
  template <class G1 = G, enable_if_t<!graph_trait<G1>::weighted>* = nullptr>
  vector<vector<vector<int>>> components(vector<int>& mapping) const {
    vector<int> sizes(n_cpnts, 0);
    mapping.resize(g.size());
    rep(v, g.size()) mapping[v] = sizes[id(v)]++;
    vector<vector<vector<int>>> res(n_cpnts);
    rep(i, n_cpnts) res[i].resize(sizes[i]);
    rep(v, g.size()) g.adj(v, [&](int u) {
      if (id(v) == id(u)) res[id(v)][mapping[v]].push_back(mapping[u]);
    });
    return res;
  }

  template <class G1 = G, enable_if_t<graph_trait<G1>::weighted>* = nullptr>
  vector<vector<vector<pair<int, W<G>>>>> components() const {
    vector<int> v;
    return components(v);
  }
  template <class G1 = G, enable_if_t<graph_trait<G1>::weighted>* = nullptr>
  vector<vector<vector<pair<int, W<G>>>>> components(
      vector<int>& mapping) const {
    vector<int> sizes(n_cpnts, 0);
    mapping.resize(g.size());
    rep(v, g.size()) mapping[v] = sizes[id(v)]++;
    vector<vector<vector<pair<int, W<G>>>>> res(n_cpnts);
    rep(i, n_cpnts) res[i].resize(sizes[i]);
    rep(v, g.size()) g.adj(v, [&](auto&& e) {
      if (id(v) == id(e.to()))
        res[id(v)][mapping[v]].emplace_back(mapping[e.to()], e.w());
    });
    return res;
  }

  template <class G1 = G, enable_if_t<!graph_trait<G1>::weighted>* = nullptr>
  vector<vector<int>> contract() const {
    vector<vector<int>> res(n_cpnts);
    rep(v, g.size()) g.adj(v, [&](int u) {
      if (id(v) != id(u)) res[v].push_back(u);
    });
    return res;
  }

  template <class G1 = G, enable_if_t<graph_trait<G1>::weighted>* = nullptr>
  vector<vector<pair<int, W<G>>>> contract() const {
    vector<vector<pair<int, W<G>>>> res(n_cpnts);
    rep(v, g.size()) g.adj(v, [&](auto&& e) {
      if (id(v) != id(e.to())) res[v].emplace_back(e.to(), e.w());
    });
    return res;
  }

 private:
  graph_trait<G> g;
  vector<int> id_;
  int n_cpnts;
};
#line 2 "main.cpp"

int n, m; vector<int> G[10000];

int main() {
  scanf("%d%d", &n, &m);
  rep(_, m) {
    int u, v; scanf("%d%d", &u, &v);
    G[u].push_back(v);
  }
  scc scc(G);
  int q; scanf("%d", &q);
  while (q--) {
    int u, v; scanf("%d%d", &u, &v);
    printf("%d\n", scc.id(v) == scc.id(u));
  }
}

