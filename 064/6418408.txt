#include<bits/stdc++.h>
#define rep(i,n) for(ll i= 0; i < n ; i++)
#define rep2(i,m,n) for(ll i= (m); i <= (n) ; i++)
static const int WH = 0;
static const int GR = 1;
static const int BL = 2;
using namespace std;
using ll = long long;
using ull = unsigned long long;
static const int INF = numeric_limits<int>::max();//最大値
static const int MIN = numeric_limits<int>::min();//最小値
static const ll mod = 1000000007;

struct edge{
    int from;
    int to;
    int amount;
    int init_amount;
    edge* complement;

    edge(int arg_from, int arg_to, int arg_amount){
        from = arg_from;
        to = arg_to;
        amount = arg_amount;
        init_amount = arg_amount;
    }

    void set_value(int arg_from, int arg_to, int arg_amount, edge* arg_comp){
        from = arg_from;
        to = arg_to;
        amount = arg_amount;
        complement = arg_comp;
    }
};

struct maxflow{
    int Node_num;
    vector<vector<edge*>> edges;

    maxflow(int N){
        Node_num = N;
        edges.resize(N);
    }

    void add_edge(int from, int to, int cost){
        edge* new_edge = new edge(from,to,cost);
        edge* new_complement_edge = new edge(from,to,0);
        new_edge->complement = new_complement_edge;
        new_complement_edge->complement = new_edge;

        edges[from].push_back(new_edge);
        edges[to].push_back(new_complement_edge);
    }

    bool unit_flow(int start_node, int end_node){
        int is_visited[Node_num];
        stack<edge*> st;
        bool is_reached_end_node = false;

        for(int i = 0; i < Node_num; i++) is_visited[i] = WH;

        for(edge* first_edge:edges[start_node]){
            if(first_edge->amount > 0) st.push(first_edge);
        }
        is_visited[start_node] = GR;

        while(st.size() > 0){
            edge* current_edge = st.top();
            int next_node = current_edge->to;
            if(is_visited[next_node] == WH){                
                is_visited[next_node] = GR;
                current_edge->amount -= 1;
                current_edge->complement->amount += 1;

                if(next_node == end_node){
                    is_reached_end_node = true;
                    break;
                }                
                for(edge* edge_candidate: edges[next_node]){
                    if((is_visited[edge_candidate->to] == WH) && (edge_candidate->amount > 0)) st.push(edge_candidate);
                }
            } else if(is_visited[current_edge->to] == GR){
                is_visited[current_edge->to] = BL;
                current_edge->amount += 1;
                current_edge->complement->amount -= 1;
                st.pop();
            } else if(is_visited[current_edge -> to] == BL){
                st.pop();
            }
        }
        return is_reached_end_node;
    }


    int find_maxflow(int start_node, int end_node){
        int ret_flow = 0;
        while(1){
            if(unit_flow(start_node, end_node) ==false) break;
            ret_flow++;
        }
        return ret_flow;
    }
};

int main(){
    int V,E; cin >> V >> E;
    maxflow mf(V);
    for(int i = 0; i < E; i++){
        int u,v,c; cin >> u >> v >> c; 
        mf.add_edge(u,v,c);
    }
    cout << mf.find_maxflow(0,V-1) << endl;
    return 0;
}
