#include<bits/stdc++.h>
#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)
#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)
#define foreach(i, n) for(auto &i:(n))
#define all(x) (x).begin(), (x).end()
#define bit(x) (1ll << (x))
#define lambda(RES_TYPE, ...) (function<RES_TYPE(__VA_ARGS__)>)[&](__VA_ARGS__) -> RES_TYPE
#define method(FUNC_NAME, RES_TYPE, ...) function<RES_TYPE(__VA_ARGS__)> FUNC_NAME = lambda(RES_TYPE, __VA_ARGS__)
using namespace std;
using ll = long long;
using pii = pair<int,int>;
using pll = pair<ll,ll>;
//const ll MOD = (ll)1e9+7;
const ll MOD = 998244353;
const int INF = (ll)1e9+7;
const ll INFLL = (ll)1e18;
template<class t>
using vvector = vector<vector<t>>;
template<class t>
using vvvector = vector<vector<vector<t>>>;
template<class t>
using priority_queuer = priority_queue<t, vector<t>, greater<t>>;
template<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}
template<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}
#ifdef DEBUG
#define debug(x) cout<<"LINE "<<__LINE__<<": "<<#x<<" = "<<x<<endl;
#else
#define debug(x) (void)0
#endif

namespace templates{
    ll modpow(ll x, ll b,ll mod=MOD){
        ll res = 1;
        while(b){
            if(b&1)res = res * x % mod;
            x = x * x % mod;
            b>>=1;
        }
        return res;
    }

    ll modinv(ll x){
        return modpow(x, MOD-2);
    }

    bool was_output = false;

    void print();
    template <class t> void print(const vector<t> &);
    template <class t, class u> void print(const pair<t, u> &);
    template <class t> void print(const t&);
    template <class Head, class... Tail> void print(const Head&, const Tail&...);

    template <class t> void println(const vector<vector<t>>&);
    template <class t> void println(const vector<t>&);
    template <class t> void println(const t&);
    template <class Head, class... Tail> void println(const Head&, const Tail&...);
    void println();
    void newline();

    void print(){
        return;
    }

    template <class t>
    void print(const vector<t>&x){
        for(const t&i:x)print(i);
    }
    template <class t, class u>
    void print(const pair<t,u>&p){
        print(p.first);
        print(p.second);
    }
    template <class t>
    void print(const t&x){
        if(was_output)cout<<" ";
        cout<<x;
        was_output = true;
    }
    template <class Head, class... Tail>
    void print(const Head&head,const Tail&...tail){
        print(head);
        print(tail...);
    }

    template<class t>
    void println(const vector<vector<t>>&x){
        for(vector<t> i:x)println(i);
    }
    template<class t>
    void println(const vector<t>&x){
        for(const t&i:x)print(i);
        println();
    }
    template <class t>
    void println(const t&x){
        print(x);
        println();
    }
    void println(){
        if(was_output){
            cout << endl;
            was_output = false;
        }
    }
    template <class Head, class... Tail>
    void println(const Head&head,const Tail&...tail){
        print(head);
        println(tail...);
    }

    void newline(){
        was_output = true;
        println();
    }

    template<class t>
    istream& operator>>(istream&is, vector<t>&x){
        for(auto &i:x)is >> i;
        return is;
    }

    template<class t, class u>
    istream& operator>>(istream&is, pair<t, u>&x){
        is >> x.first >> x.second;
        return is;
    }

    template<class t>
    ostream& operator<<(ostream&os, vector<t> &v){
        os << "{";
        for(t &i:v){
            os << i << ", ";
        }
        os << "}";
        return os;
    }

    template<class t = long long>
    t in(){
        t res; cin >> res; return res;
    }

    template<class t>
    vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){
        sort(line.begin(),line.end(),comp);
        return line;
    }

    template<class t>
    vector<t> reversed(vector<t> line){
        reverse(line.begin(),line.end());
        return line;
    }
    string reversed(string str){
        reverse(str.begin(),str.end());
        return str;
    }

    long long gcd(long long a,long long b){
        while(b){
            a %= b;
            swap(a,b);
        }
        return a;
    }

    long long lcm(long long a,long long b){
        return a / gcd(a,b) * b;
    }

    class output_initializer{
    public:
        output_initializer(){
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
            cout << setprecision(20);
        }
    };output_initializer OUTPUT_INITIALIZER_INSTANCE = output_initializer();
}

using namespace templates;

template <typename monoid>
struct segment_tree {
    using M = monoid;
    using T = typename M::value_type;

    std::size_t sz;
    std::vector<T> x;

    segment_tree(std::size_t n = 0) {
        sz = 1;
        while (sz < n) sz *= 2;
        x.assign(sz * 2, M::id());
        initialize();
    }

    template <typename iterator>
    segment_tree(iterator first, iterator last) {
        sz = 1;
        std::size_t n = std::distance(first, last);
        while (sz < n) sz *= 2;
        x.assign(sz * 2, M::id());
        std::copy(first, last, x.begin() + sz);
        initialize();
    }

    void fill(const T &val) {
        std::fill(x.begin() + sz, x.end(), val);
        initialize();
    }

    void initialize() {
        for (int i = (int)sz - 1; i >= 1; --i) {
            x[i] = M::op(x[i * 2 + 0], x[i * 2 + 1]);
        }
    }

    T accumulate(std::size_t l, std::size_t r) const {
        T al = M::id(), ar = M::id();
        for (l += sz, r += sz; l < r; l /= 2, r /= 2) {
            if (l & 1) al = M::op(al, x[l++]);
            if (r & 1) ar = M::op(x[--r], ar);
        }
        return M::op(al, ar);
    }

    void update(std::size_t i, const T &val) {
        x[i += sz] = val;
        while (i > 1) {
            x[i / 2] = M::op(x[i], x[i ^ 1]);
            i /= 2;
        }
    }

    T operator[](std::size_t i) const { return x[sz + i]; }
};

template <typename T>
struct min_monoid {
    using value_type = T;
    static constexpr T id() { return std::numeric_limits<T>::max(); }
    static T op(const T &a, const T &b) { return std::min(a, b); }
};

template <typename T>
struct max_monoid {
    using value_type = T;
    static constexpr value_type id() { return std::numeric_limits<value_type>::min(); }
    static value_type op(const value_type &a, const value_type &b) { return std::max(a, b); }
};

template <typename T>
struct sum_monoid {
    using value_type = T;
    static constexpr value_type id() { return 0; }
    static value_type op(const value_type &a, const value_type &b) { return a + b; }
};

template <typename value_type>
using rminq = segment_tree<min_monoid<value_type>>;
template <typename value_type>
using rmaxq = segment_tree<max_monoid<value_type>>;

template <typename value_type>
using rsq = segment_tree<sum_monoid<value_type>>;

int n;

vector<pii> slide(vector<pii> line){
    sort(all(line));
    vector<pii> res;
    foreach(i,line){
        while(res.size() and res.back().second < i.second)res.pop_back();
        res.emplace_back(i);
    }
    return res;
}

vector<pii> compress(vector<pii> line){
    method(compress,void,function<int&(pii&)> f){
        map<int,int> m;
        foreach(i,line)m[f(i)];
        int cnt = 0;
        foreach(i,m)i.second = ++cnt;
        foreach(i,line)f(i) = m[f(i)];
    };
    compress(lambda(int&,pii &x){return x.first;});
    compress(lambda(int&,pii &x){return x.second;});
    return line;
}

ll solve(vector<pii> line) {
    line = compress(line);
    int n = line.size();
    sort(all(line));
    vector<pii> slides = slide(line);
    set<pii> isSlide;
    foreach(i,slides)isSlide.emplace(i);
    rsq<int> cnts(n+10);
    rmaxq<int> rights(n+10);
    rminq<int> lefts(n+10);
    rep(i,n+5)lefts.update(i,n);
    rep(i,n+5)rights.update(i,0);
    rep(i,n+5)cnts.update(i,0);
    foreach(i,slides)cnts.update(i.first,1);
    foreach(i,line){
        rights.update(i.second,i.first);
        lefts.update(i.second,i.first);
    }
    ll res = 0;
    int maxs = 0;
    foreach(p,line){
        chmax(maxs,p.second);
        while(isSlide.size() and isSlide.rbegin()->second <= maxs){
            pii i = *isSlide.rbegin();
            cnts.update(i.first,0);
            isSlide.erase(i);
        }
        int x = p.first;
        int y = p.second;
        int right = rights.accumulate(0,y);
        int left = lefts.accumulate(0,y);
        if(x < left){
            res += cnts.accumulate(right,n+5);
        }
    }
    return res;
}

ll func(){
    int n = in();
    vector<pii> line(n);
    vector<pii> line2;
    foreach(i,line)i=in<pii>();
    foreach(i,line)line2.emplace_back(-i.second,i.first);
    return solve(line) + solve(line2);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    println(func());
    return 0;
}

