// no spaces due to the limit
static_assert(R"("
using fp=atcoder::modint998244353;
void main(int){
int n,k;
scan(n,k);
vector<int>a(n);
scan(a);
vector<basic_string<int>>g(n);
for(int v:rep(1,n)){
int p;
scan(p);
--p;
g[p]+=v;
}
vector f(n,vector<fp>(2001));
fix([&](auto self,int v)->void{
f[v][0]=1;
for(int u:g[v]){
self(u);
f[v]=atcoder::convolution(f[v],f[u]);
f[v].resize(2001);
}
for(int i:rev(rep1(2000))){f[v][i]=a[v]<=i?f[v][i-a[v]]:0;}
f[v][0]=1;
})(0);
println(f[0][k].val());
}
")");
#define MULTI_CASES 0
#define INTERACTIVE 0
#ifndef LOCAL
#define LOCAL 0
#endif
#if!LOCAL
#define NDEBUG
#endif
#ifndef __GLIBCXX_TYPE_INT_N_0
#define __GLIBCXX_TYPE_INT_N_0 __int128
#endif
#include<bits/stdc++.h>
#include<unistd.h>
#include<x86intrin.h>
namespace r7h{
using namespace std;
void main(int);
}
#if LOCAL
#include<utility/dump.hpp>
#else
#define DUMP(...)void(0)
#endif
#define LIFT(FN)\
[]<class...Ts_>(Ts_&&...xs_)->decltype(auto){return FN(static_cast<Ts_&&>(xs_)...);}
#define LAMBDA(...)\
[&]<class T1_=void*,class T2_=void*>([[maybe_unused]]T1_&&_1=nullptr,[[maybe_unused]]T2_&&_2=nullptr)\
->decltype(auto){\
return __VA_ARGS__;\
}
namespace r7h{
template<class F>
class fix:F{
public:
explicit fix(F f):F(move(f)){}
template<class...Ts>
decltype(auto)operator()(Ts&&...xs)const{
return F::operator()(ref(*this),forward<Ts>(xs)...);
}
};
template<class T>
decay_t<T>decay_copy(T&&x){
return forward<T>(x);
}
template<class T>
auto ref_or_move(remove_reference_t<T>&x){
if constexpr(is_reference_v<T>&&!is_placeholder_v<decay_t<T>>){
return ref(x);
}else{
return move(x);
}
}
template<class T,class D=decay_t<T>>
bool const is_lambda_expr=is_placeholder_v<D>||is_bind_expression_v<D>;
#define UNARY_LAMBDA(OP)\
template<class T,enable_if_t<is_lambda_expr<T>>* =nullptr>\
auto operator OP(T&&x){\
return bind([]<class T_>(T_&&x_)->decltype(auto){return OP forward<T_>(x_);},ref_or_move<T>(x));\
}
#define BINARY_LAMBDA(OP)\
template<class T1,class T2,enable_if_t<is_lambda_expr<T1>||is_lambda_expr<T2>>* =nullptr>\
auto operator OP(T1&&x,T2&&y){\
auto f=[]<class T1_,class T2_>(T1_&&x_,T2_&&y_)->decltype(auto){\
return forward<T1_>(x_)OP forward<T2_>(y_);\
};\
return bind(move(f),ref_or_move<T1>(x),ref_or_move<T2>(y));\
}
BINARY_LAMBDA(+=)
BINARY_LAMBDA(-=)
BINARY_LAMBDA(*=)
BINARY_LAMBDA(/=)
BINARY_LAMBDA(%=)
BINARY_LAMBDA(&=)
BINARY_LAMBDA(|=)
BINARY_LAMBDA(^=)
BINARY_LAMBDA(<<=)
BINARY_LAMBDA(>>=)
UNARY_LAMBDA(++)
UNARY_LAMBDA(--)
UNARY_LAMBDA(+)
UNARY_LAMBDA(-)
BINARY_LAMBDA(+)
BINARY_LAMBDA(-)
BINARY_LAMBDA(*)
BINARY_LAMBDA(/)
BINARY_LAMBDA(%)
UNARY_LAMBDA(~)
BINARY_LAMBDA(&)
BINARY_LAMBDA(|)
BINARY_LAMBDA(^)
BINARY_LAMBDA(<<)
BINARY_LAMBDA(>>)
BINARY_LAMBDA(==)
BINARY_LAMBDA(!=)
BINARY_LAMBDA(<)
BINARY_LAMBDA(>)
BINARY_LAMBDA(<=)
BINARY_LAMBDA(>=)
UNARY_LAMBDA(!)
BINARY_LAMBDA(&&)
BINARY_LAMBDA(||)
#undef UNARY_LAMBDA
#undef BINARY_LAMBDA
using namespace placeholders;
using i8=signed char;
using u8=unsigned char;
using i16=short;
using u16=unsigned short;
using i32=int;
using u32=unsigned;
using i64=long long;
using u64=unsigned long long;
using i128=__int128;
using u128=unsigned __int128;
template<int>struct signed_int;
template<int>struct unsigned_int;
#define INT_TYPE(N)\
template<>struct signed_int<N>{using type=i##N;};\
template<>struct unsigned_int<N>{using type=u##N;};
INT_TYPE(8)
INT_TYPE(16)
INT_TYPE(32)
INT_TYPE(64)
INT_TYPE(128)
#undef INT_TYPE
template<int N>using signed_int_t=typename signed_int<N>::type;
template<int N>using unsigned_int_t=typename unsigned_int<N>::type;
namespace scan_impl{
#if INTERACTIVE||LOCAL
bool scan(char&c){return scanf(" %c",&c)!=EOF;}
bool scan(string&s){
char c;
if(!scan(c)){return false;}
for(s=c;;s+=c){
c=char(getchar());
if(c<= ' '){
ungetc(c,stdin);
break;
}
}
return true;
}
template<class T>
enable_if_t<is_integral_v<T>,bool>scan(T&x){
char c;
if(!scan(c)){return false;}
make_unsigned_t<decltype(+x)>u=(c== '-' ?getchar():c)&15;
while(true){
if(int t=getchar(); '0' <=t&&t<= '9'){
(u*=10)+=t&15;
}else{
ungetc(t,stdin);
break;
}
}
x=T(c== '-' ?-u:u);
return true;
}
template<class T>
enable_if_t<is_floating_point_v<T>,bool>scan(T&x){
return scanf(is_same_v<T,float>? "%f" :is_same_v<T,double>? "%lf" : "%Lf",&x)!=EOF;
}
#else
char buf[1<<15];
char*ptr=buf;
char*last=buf;
bool scan(char&c){
for(;;++ptr){
if(last-ptr<64){
last=move(ptr,last,buf);
ptr=buf;
last+=read(STDIN_FILENO,last,end(buf)-last-1);
*last= '\0';
}
if(ptr==last){return false;}
if(' ' <*ptr){
c=*ptr++;
return true;
}
}
}
bool scan(string&s){
char c;
if(!scan(c)){return false;}
for(s=c; ' ' <*ptr;s+=c){scan(c);}
return true;
}
template<class T>
enable_if_t<is_integral_v<T>,bool>scan(T&x){
char c;
if(!scan(c)){return false;}
make_unsigned_t<decltype(+x)>u=(c== '-' ?*ptr++:c)&15;
while('0' <=*ptr&&*ptr<= '9'){(u*=10)+=*ptr++&15;}
x=T(c== '-' ?-u:u);
return true;
}
template<class T>
enable_if_t<is_floating_point_v<T>,bool>scan(T&x){
char c;
if(!scan(c)){return false;}
int n;
sscanf(--ptr,is_same_v<T,float>? "%f%n" :is_same_v<T,double>? "%lf%n" : "%Lf%n",&x,&n);
ptr+=n;
return true;
}
#endif
template<class R>
auto scan(R&&r)->decltype(begin(r),end(r),true){
return all_of(begin(r),end(r),LIFT(scan));
}
template<class...Ts>
enable_if_t<sizeof...(Ts)!=1,bool>scan(Ts&&...xs){
return(...&&scan(forward<Ts>(xs)));
}
}
using scan_impl::scan;
namespace print_impl{
#if INTERACTIVE||LOCAL
template<char=0>
void print(char c){
if(c){putchar(c);}
if(c== '\n'){fflush(stdout);}
}
template<char=0,class T>
enable_if_t<is_integral_v<T>>print(T x){
char buf[64];
char*ptr=to_chars(buf,end(buf),+x).ptr;
for_each(buf,ptr,LIFT(print));
}
template<char=0,class T>
enable_if_t<is_floating_point_v<T>>print(T x){
printf(is_same_v<T,float>? "%.6f" :is_same_v<T,double>? "%.15f" : "%.18Lf",x);
}
#else
char buf[1<<15];
char*ptr=buf;
__attribute__((destructor))void flush(){
if(write(STDOUT_FILENO,buf,ptr-buf)==-1){abort();}
ptr=buf;
}
template<char=0>
void print(char c){
if(end(buf)-ptr<64){flush();}
if(c){*ptr++=c;}
}
template<char=0,class T>
enable_if_t<is_integral_v<T>>print(T x){
print('\0');
ptr=to_chars(ptr,end(buf),+x).ptr;
}
template<char=0,class T>
enable_if_t<is_floating_point_v<T>>print(T x){
print('\0');
ptr+=snprintf(ptr,end(buf)-ptr,is_same_v<T,float>? "%.6f" :is_same_v<T,double>? "%.15f" : "%.18Lf",x);
}
#endif
template<char=0>
void print(char const*);
template<char Sep= ' ',class R>
auto print(R&&r)->void_t<decltype(begin(r),end(r))>{
[[maybe_unused]]char c= '\0';
for(auto&&e:r){
if constexpr(!is_same_v<decay_t<decltype(e)>,char>){print(exchange(c,Sep));}
print(e);
}
}
template<char=0>
void print(char const*s){
print(string_view(s));
}
template<char Sep= ' ',class...Ts>
enable_if_t<sizeof...(Ts)!=1>print(Ts&&...xs){
[[maybe_unused]]char c= '\0';
(...,(print(exchange(c,Sep)),print(forward<Ts>(xs))));
}
}
using print_impl::print;
template<char Sep= ' ',char End= '\n',class...Ts>
void println(Ts&&...xs){
print<Sep>(forward<Ts>(xs)...);
print(End);
}
template<class T>
auto operator++(T&x,int)->decltype(++x,T(x)){
T ret=x;
++x;
return ret;
}
template<class T>
auto operator--(T&x,int)->decltype(--x,T(x)){
T ret=x;
--x;
return ret;
}
#define BINARY_ARITH_OP(OP)\
template<class T1,class T2,class T=common_type_t<T1,T2>>\
auto operator OP(T1 const&x,T2 const&y)->decltype(declval<T&>()OP##=y,T(x)){\
T ret=T(x);\
ret OP##=y;\
return ret;\
}
BINARY_ARITH_OP(+)
BINARY_ARITH_OP(-)
BINARY_ARITH_OP(*)
BINARY_ARITH_OP(/)
BINARY_ARITH_OP(%)
BINARY_ARITH_OP(&)
BINARY_ARITH_OP(|)
BINARY_ARITH_OP(^)
BINARY_ARITH_OP(<<)
BINARY_ARITH_OP(>>)
#undef BINARY_ARITH_OP
#define COMPARISON_OP(OP,E)\
template<class T1,class T2>\
auto operator OP(T1 const&x,T2 const&y)->decltype(E){\
return E;\
}
COMPARISON_OP(!=,!(x==y))
COMPARISON_OP(>,y<x)
COMPARISON_OP(<=,!(y<x))
COMPARISON_OP(>=,!(x<y))
#undef COMPARISON_OP
template<class D,class C,class R>
class iter_base{
D&derived(){return static_cast<D&>(*this);}
D const&derived()const{return static_cast<D const&>(*this);}
public:
using iterator_category=C;
using value_type=decay_t<R>;
using difference_type=int;
using pointer=void;
using reference=R;
#define REQUIRE(CAT)template<class C_=C,enable_if_t<is_convertible_v<C_,CAT##_iterator_tag>>* =nullptr>
R operator*()const{return derived().deref();}
REQUIRE(random_access)R operator[](int n)const{return*(derived()+n);}
D&operator++()&{
derived().inc();
return derived();
}
REQUIRE(bidirectional)D&operator--()&{
derived().dec();
return derived();
}
REQUIRE(random_access)D&operator+=(int n)&{
derived().adv(n);
return derived();
}
REQUIRE(random_access)D&operator-=(int n)&{
derived().adv(-n);
return derived();
}
REQUIRE(random_access)friend D operator+(D const&x,int n){
D ret=x;
ret+=n;
return ret;
}
REQUIRE(random_access)friend D operator+(int n,D const&x){return x+n;}
REQUIRE(random_access)friend D operator-(D const&x,int n){
D ret=x;
ret-=n;
return ret;
}
REQUIRE(random_access)friend int operator-(D const&x,D const&y){return y.dist_to(x);}
friend bool operator==(D const&x,D const&y){return x.eq(y);}
REQUIRE(random_access)friend bool operator<(D const&x,D const&y){return x-y<0;}
#undef REQUIRE
};
struct int_iter:iter_base<int_iter,random_access_iterator_tag,int>{
int v;
int_iter()=default;
int_iter(int v):v(v){}
int deref()const{return v;}
bool eq(int_iter const&x)const{return v==x.v;}
void inc(){++v;}
void dec(){--v;}
void adv(int n){v+=n;}
int dist_to(int_iter const&x)const{return x.v-v;}
};
template<class I>
class range{
I b,e;
public:
explicit range(I first,I last):b(move(first)),e(move(last)){}
I begin()const{return b;}
I end()const{return e;}
};
auto rep(int l,int r){return range<int_iter>(min(l,r),r);}
auto rep(int n){return rep(0,n);}
auto rep1(int l,int r){return rep(l,r+1);}
auto rep1(int n){return rep(1,n+1);}
template<class R>
auto rev(R&&r){
return range(make_reverse_iterator(end(r)),make_reverse_iterator(begin(r)));
}
template<class R>
auto sz(R&&r)->decltype(int(size(forward<R>(r)))){
return int(size(forward<R>(r)));
}
template<class T,class N,class Op>
T power1(T x,N n,Op op){
assert(1<=n);
for(;~n&1;n>>=1){x=op(x,x);}
T ret=x;
while(n>>=1){
x=op(x,x);
if(n&1){ret=op(move(ret),x);}
}
return ret;
}
template<class T,class N>
T power(T x,N n){
if(n==0){return T{1};}
if(n<0){return T{1}/power1(move(x),-n,multiplies{});}
return power1(move(x),n,multiplies{});
}
template<class T>
T div_floor(T x,T y){
return T(x/y-((x^y)<0&&x%y));
}
template<class T>
T div_ceil(T x,T y){
return T(x/y+(0<=(x^y)&&x%y));
}
template<class T,class U=T>
bool chmin(T&x,U&&y){
return y<x?x=forward<U>(y),true:false;
}
template<class T,class U=T>
bool chmax(T&x,U&&y){
return x<y?x=forward<U>(y),true:false;
}
template<class T>
T const inf_v=numeric_limits<T>::max()/2;
int const inf=inf_v<int>;
mt19937_64 mt(_rdtsc());
template<class T>
T rand(T a,T b){
if constexpr(is_integral_v<T>){
return uniform_int_distribution(a,b)(mt);
}else{
return uniform_real_distribution(a,b)(mt);
}
}
}
int main(){
int t=1;
if(MULTI_CASES){r7h::scan(t);}
for(int i:r7h::rep(t)){r7h::main(i);}
assert(!r7h::scan(t));
}
#ifdef _MSC_VER
#include<intrin.h>
#endif
namespace atcoder{
namespace internal{
int ceil_pow2(int n){
int x=0;
while((1U<<x)<(unsigned int)(n))x++;
return x;
}
constexpr int bsf_constexpr(unsigned int n){
int x=0;
while(!(n&(1<<x)))x++;
return x;
}
int bsf(unsigned int n){
#ifdef _MSC_VER
unsigned long index;
_BitScanForward(&index,n);
return index;
#else
return __builtin_ctz(n);
#endif
}
}
}
#ifdef _MSC_VER
#include<intrin.h>
#endif
#ifdef _MSC_VER
#include<intrin.h>
#endif
namespace atcoder{
namespace internal{
constexpr long long safe_mod(long long x,long long m){
x%=m;
if(x<0)x+=m;
return x;
}
struct barrett{
unsigned int _m;
unsigned long long im;
explicit barrett(unsigned int m):_m(m),im((unsigned long long)(-1)/m+1){}
unsigned int umod()const{return _m;}
unsigned int mul(unsigned int a,unsigned int b)const{
unsigned long long z=a;
z*=b;
#ifdef _MSC_VER
unsigned long long x;
_umul128(z,im,&x);
#else
unsigned long long x=
(unsigned long long)(((unsigned __int128)(z)*im)>>64);
#endif
unsigned int v=(unsigned int)(z-x*_m);
if(_m<=v)v+=_m;
return v;
}
};
constexpr long long pow_mod_constexpr(long long x,long long n,int m){
if(m==1)return 0;
unsigned int _m=(unsigned int)(m);
unsigned long long r=1;
unsigned long long y=safe_mod(x,m);
while(n){
if(n&1)r=(r*y)%_m;
y=(y*y)%_m;
n>>=1;
}
return r;
}
constexpr bool is_prime_constexpr(int n){
if(n<=1)return false;
if(n==2||n==7||n==61)return true;
if(n%2==0)return false;
long long d=n-1;
while(d%2==0)d/=2;
constexpr long long bases[3]={2,7,61};
for(long long a:bases){
long long t=d;
long long y=pow_mod_constexpr(a,t,n);
while(t!=n-1&&y!=1&&y!=n-1){
y=y*y%n;
t<<=1;
}
if(y!=n-1&&t%2==0){
return false;
}
}
return true;
}
template<int n>constexpr bool is_prime=is_prime_constexpr(n);
constexpr std::pair<long long,long long>inv_gcd(long long a,long long b){
a=safe_mod(a,b);
if(a==0)return{b,0};
long long s=b,t=a;
long long m0=0,m1=1;
while(t){
long long u=s/t;
s-=t*u;
m0-=m1*u;
auto tmp=s;
s=t;
t=tmp;
tmp=m0;
m0=m1;
m1=tmp;
}
if(m0<0)m0+=b/s;
return{s,m0};
}
constexpr int primitive_root_constexpr(int m){
if(m==2)return 1;
if(m==167772161)return 3;
if(m==469762049)return 3;
if(m==754974721)return 11;
if(m==998244353)return 3;
int divs[20]={};
divs[0]=2;
int cnt=1;
int x=(m-1)/2;
while(x%2==0)x/=2;
for(int i=3;(long long)(i)*i<=x;i+=2){
if(x%i==0){
divs[cnt++]=i;
while(x%i==0){
x/=i;
}
}
}
if(x>1){
divs[cnt++]=x;
}
for(int g=2;;g++){
bool ok=true;
for(int i=0;i<cnt;i++){
if(pow_mod_constexpr(g,(m-1)/divs[i],m)==1){
ok=false;
break;
}
}
if(ok)return g;
}
}
template<int m>constexpr int primitive_root=primitive_root_constexpr(m);
unsigned long long floor_sum_unsigned(unsigned long long n,
unsigned long long m,
unsigned long long a,
unsigned long long b){
unsigned long long ans=0;
while(true){
if(a>=m){
ans+=n*(n-1)/2*(a/m);
a%=m;
}
if(b>=m){
ans+=n*(b/m);
b%=m;
}
unsigned long long y_max=a*n+b;
if(y_max<m)break;
n=(unsigned long long)(y_max/m);
b=(unsigned long long)(y_max%m);
std::swap(m,a);
}
return ans;
}
#ifndef _MSC_VER
template<class T>
using is_signed_int128=
typename std::conditional<std::is_same<T,__int128_t>::value||
std::is_same<T,__int128>::value,
std::true_type,
std::false_type>::type;
template<class T>
using is_unsigned_int128=
typename std::conditional<std::is_same<T,__uint128_t>::value||
std::is_same<T,unsigned __int128>::value,
std::true_type,
std::false_type>::type;
template<class T>
using make_unsigned_int128=
typename std::conditional<std::is_same<T,__int128_t>::value,
__uint128_t,
unsigned __int128>;
template<class T>
using is_integral=typename std::conditional<std::is_integral<T>::value||
is_signed_int128<T>::value||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;
template<class T>
using is_signed_int=typename std::conditional<(is_integral<T>::value&&
std::is_signed<T>::value)||
is_signed_int128<T>::value,
std::true_type,
std::false_type>::type;
template<class T>
using is_unsigned_int=
typename std::conditional<(is_integral<T>::value&&
std::is_unsigned<T>::value)||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;
template<class T>
using to_unsigned=typename std::conditional<
is_signed_int128<T>::value,
make_unsigned_int128<T>,
typename std::conditional<std::is_signed<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type>::type;
#else
template<class T>using is_integral=typename std::is_integral<T>;
template<class T>
using is_signed_int=
typename std::conditional<is_integral<T>::value&&std::is_signed<T>::value,
std::true_type,
std::false_type>::type;
template<class T>
using is_unsigned_int=
typename std::conditional<is_integral<T>::value&&
std::is_unsigned<T>::value,
std::true_type,
std::false_type>::type;
template<class T>
using to_unsigned=typename std::conditional<is_signed_int<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type;
#endif
template<class T>
using is_signed_int_t=std::enable_if_t<is_signed_int<T>::value>;
template<class T>
using is_unsigned_int_t=std::enable_if_t<is_unsigned_int<T>::value>;
template<class T>using to_unsigned_t=typename to_unsigned<T>::type;
struct modint_base{};
struct static_modint_base:modint_base{};
template<class T>using is_modint=std::is_base_of<modint_base,T>;
template<class T>using is_modint_t=std::enable_if_t<is_modint<T>::value>;
}
template<int m,std::enable_if_t<(1<=m)>* =nullptr>
struct static_modint:internal::static_modint_base{
using mint=static_modint;
public:
static constexpr int mod(){return m;}
static mint raw(int v){
mint x;
x._v=v;
return x;
}
static_modint():_v(0){}
template<class T,internal::is_signed_int_t<T>* =nullptr>
static_modint(T v){
long long x=(long long)(v%(long long)(umod()));
if(x<0)x+=umod();
_v=(unsigned int)(x);
}
template<class T,internal::is_unsigned_int_t<T>* =nullptr>
static_modint(T v){
_v=(unsigned int)(v%umod());
}
unsigned int val()const{return _v;}
mint&operator++(){
_v++;
if(_v==umod())_v=0;
return*this;
}
mint&operator--(){
if(_v==0)_v=umod();
_v--;
return*this;
}
mint operator++(int){
mint result=*this;
++*this;
return result;
}
mint operator--(int){
mint result=*this;
--*this;
return result;
}
mint&operator+=(const mint&rhs){
_v+=rhs._v;
if(_v>=umod())_v-=umod();
return*this;
}
mint&operator-=(const mint&rhs){
_v-=rhs._v;
if(_v>=umod())_v+=umod();
return*this;
}
mint&operator*=(const mint&rhs){
unsigned long long z=_v;
z*=rhs._v;
_v=(unsigned int)(z%umod());
return*this;
}
mint&operator/=(const mint&rhs){return*this=*this*rhs.inv();}
mint operator+()const{return*this;}
mint operator-()const{return mint()-*this;}
mint pow(long long n)const{
assert(0<=n);
mint x=*this,r=1;
while(n){
if(n&1)r*=x;
x*=x;
n>>=1;
}
return r;
}
mint inv()const{
if(prime){
assert(_v);
return pow(umod()-2);
}else{
auto eg=internal::inv_gcd(_v,m);
assert(eg.first==1);
return eg.second;
}
}
friend mint operator+(const mint&lhs,const mint&rhs){
return mint(lhs)+=rhs;
}
friend mint operator-(const mint&lhs,const mint&rhs){
return mint(lhs)-=rhs;
}
friend mint operator*(const mint&lhs,const mint&rhs){
return mint(lhs)*=rhs;
}
friend mint operator/(const mint&lhs,const mint&rhs){
return mint(lhs)/=rhs;
}
friend bool operator==(const mint&lhs,const mint&rhs){
return lhs._v==rhs._v;
}
friend bool operator!=(const mint&lhs,const mint&rhs){
return lhs._v!=rhs._v;
}
private:
unsigned int _v;
static constexpr unsigned int umod(){return m;}
static constexpr bool prime=internal::is_prime<m>;
};
template<int id>struct dynamic_modint:internal::modint_base{
using mint=dynamic_modint;
public:
static int mod(){return(int)(bt.umod());}
static void set_mod(int m){
assert(1<=m);
bt=internal::barrett(m);
}
static mint raw(int v){
mint x;
x._v=v;
return x;
}
dynamic_modint():_v(0){}
template<class T,internal::is_signed_int_t<T>* =nullptr>
dynamic_modint(T v){
long long x=(long long)(v%(long long)(mod()));
if(x<0)x+=mod();
_v=(unsigned int)(x);
}
template<class T,internal::is_unsigned_int_t<T>* =nullptr>
dynamic_modint(T v){
_v=(unsigned int)(v%mod());
}
unsigned int val()const{return _v;}
mint&operator++(){
_v++;
if(_v==umod())_v=0;
return*this;
}
mint&operator--(){
if(_v==0)_v=umod();
_v--;
return*this;
}
mint operator++(int){
mint result=*this;
++*this;
return result;
}
mint operator--(int){
mint result=*this;
--*this;
return result;
}
mint&operator+=(const mint&rhs){
_v+=rhs._v;
if(_v>=umod())_v-=umod();
return*this;
}
mint&operator-=(const mint&rhs){
_v+=mod()-rhs._v;
if(_v>=umod())_v-=umod();
return*this;
}
mint&operator*=(const mint&rhs){
_v=bt.mul(_v,rhs._v);
return*this;
}
mint&operator/=(const mint&rhs){return*this=*this*rhs.inv();}
mint operator+()const{return*this;}
mint operator-()const{return mint()-*this;}
mint pow(long long n)const{
assert(0<=n);
mint x=*this,r=1;
while(n){
if(n&1)r*=x;
x*=x;
n>>=1;
}
return r;
}
mint inv()const{
auto eg=internal::inv_gcd(_v,mod());
assert(eg.first==1);
return eg.second;
}
friend mint operator+(const mint&lhs,const mint&rhs){
return mint(lhs)+=rhs;
}
friend mint operator-(const mint&lhs,const mint&rhs){
return mint(lhs)-=rhs;
}
friend mint operator*(const mint&lhs,const mint&rhs){
return mint(lhs)*=rhs;
}
friend mint operator/(const mint&lhs,const mint&rhs){
return mint(lhs)/=rhs;
}
friend bool operator==(const mint&lhs,const mint&rhs){
return lhs._v==rhs._v;
}
friend bool operator!=(const mint&lhs,const mint&rhs){
return lhs._v!=rhs._v;
}
private:
unsigned int _v;
static internal::barrett bt;
static unsigned int umod(){return bt.umod();}
};
template<int id>internal::barrett dynamic_modint<id>::bt(998244353);
using modint998244353=static_modint<998244353>;
using modint1000000007=static_modint<1000000007>;
using modint=dynamic_modint<-1>;
namespace internal{
template<class T>
using is_static_modint=std::is_base_of<internal::static_modint_base,T>;
template<class T>
using is_static_modint_t=std::enable_if_t<is_static_modint<T>::value>;
template<class>struct is_dynamic_modint:public std::false_type{};
template<int id>
struct is_dynamic_modint<dynamic_modint<id>>:public std::true_type{};
template<class T>
using is_dynamic_modint_t=std::enable_if_t<is_dynamic_modint<T>::value>;
template<class mint,
int g=internal::primitive_root<mint::mod()>,
internal::is_static_modint_t<mint>* =nullptr>
struct fft_info{
static constexpr int rank2=bsf_constexpr(mint::mod()-1);
std::array<mint,rank2+1>root;
std::array<mint,rank2+1>iroot;
std::array<mint,std::max(0,rank2-2+1)>rate2;
std::array<mint,std::max(0,rank2-2+1)>irate2;
std::array<mint,std::max(0,rank2-3+1)>rate3;
std::array<mint,std::max(0,rank2-3+1)>irate3;
fft_info(){
root[rank2]=mint(g).pow((mint::mod()-1)>>rank2);
iroot[rank2]=root[rank2].inv();
for(int i=rank2-1;i>=0;i--){
root[i]=root[i+1]*root[i+1];
iroot[i]=iroot[i+1]*iroot[i+1];
}
{
mint prod=1,iprod=1;
for(int i=0;i<=rank2-2;i++){
rate2[i]=root[i+2]*prod;
irate2[i]=iroot[i+2]*iprod;
prod*=iroot[i+2];
iprod*=root[i+2];
}
}
{
mint prod=1,iprod=1;
for(int i=0;i<=rank2-3;i++){
rate3[i]=root[i+3]*prod;
irate3[i]=iroot[i+3]*iprod;
prod*=iroot[i+3];
iprod*=root[i+3];
}
}
}
};
template<class mint,internal::is_static_modint_t<mint>* =nullptr>
void butterfly(std::vector<mint>&a){
int n=int(a.size());
int h=internal::ceil_pow2(n);
static const fft_info<mint>info;
int len=0;
while(len<h){
if(h-len==1){
int p=1<<(h-len-1);
mint rot=1;
for(int s=0;s<(1<<len);s++){
int offset=s<<(h-len);
for(int i=0;i<p;i++){
auto l=a[i+offset];
auto r=a[i+offset+p]*rot;
a[i+offset]=l+r;
a[i+offset+p]=l-r;
}
if(s+1!=(1<<len))
rot*=info.rate2[bsf(~(unsigned int)(s))];
}
len++;
}else{
int p=1<<(h-len-2);
mint rot=1,imag=info.root[2];
for(int s=0;s<(1<<len);s++){
mint rot2=rot*rot;
mint rot3=rot2*rot;
int offset=s<<(h-len);
for(int i=0;i<p;i++){
auto mod2=1ULL*mint::mod()*mint::mod();
auto a0=1ULL*a[i+offset].val();
auto a1=1ULL*a[i+offset+p].val()*rot.val();
auto a2=1ULL*a[i+offset+2*p].val()*rot2.val();
auto a3=1ULL*a[i+offset+3*p].val()*rot3.val();
auto a1na3imag=
1ULL*mint(a1+mod2-a3).val()*imag.val();
auto na2=mod2-a2;
a[i+offset]=a0+a2+a1+a3;
a[i+offset+1*p]=a0+a2+(2*mod2-(a1+a3));
a[i+offset+2*p]=a0+na2+a1na3imag;
a[i+offset+3*p]=a0+na2+(mod2-a1na3imag);
}
if(s+1!=(1<<len))
rot*=info.rate3[bsf(~(unsigned int)(s))];
}
len+=2;
}
}
}
template<class mint,internal::is_static_modint_t<mint>* =nullptr>
void butterfly_inv(std::vector<mint>&a){
int n=int(a.size());
int h=internal::ceil_pow2(n);
static const fft_info<mint>info;
int len=h;
while(len){
if(len==1){
int p=1<<(h-len);
mint irot=1;
for(int s=0;s<(1<<(len-1));s++){
int offset=s<<(h-len+1);
for(int i=0;i<p;i++){
auto l=a[i+offset];
auto r=a[i+offset+p];
a[i+offset]=l+r;
a[i+offset+p]=
(unsigned long long)(mint::mod()+l.val()-r.val())*
irot.val();
;
}
if(s+1!=(1<<(len-1)))
irot*=info.irate2[bsf(~(unsigned int)(s))];
}
len--;
}else{
int p=1<<(h-len);
mint irot=1,iimag=info.iroot[2];
for(int s=0;s<(1<<(len-2));s++){
mint irot2=irot*irot;
mint irot3=irot2*irot;
int offset=s<<(h-len+2);
for(int i=0;i<p;i++){
auto a0=1ULL*a[i+offset+0*p].val();
auto a1=1ULL*a[i+offset+1*p].val();
auto a2=1ULL*a[i+offset+2*p].val();
auto a3=1ULL*a[i+offset+3*p].val();
auto a2na3iimag=
1ULL*
mint((mint::mod()+a2-a3)*iimag.val()).val();
a[i+offset]=a0+a1+a2+a3;
a[i+offset+1*p]=
(a0+(mint::mod()-a1)+a2na3iimag)*irot.val();
a[i+offset+2*p]=
(a0+a1+(mint::mod()-a2)+(mint::mod()-a3))*
irot2.val();
a[i+offset+3*p]=
(a0+(mint::mod()-a1)+(mint::mod()-a2na3iimag))*
irot3.val();
}
if(s+1!=(1<<(len-2)))
irot*=info.irate3[bsf(~(unsigned int)(s))];
}
len-=2;
}
}
}
template<class mint,internal::is_static_modint_t<mint>* =nullptr>
std::vector<mint>convolution_naive(const std::vector<mint>&a,
const std::vector<mint>&b){
int n=int(a.size()),m=int(b.size());
std::vector<mint>ans(n+m-1);
if(n<m){
for(int j=0;j<m;j++){
for(int i=0;i<n;i++){
ans[i+j]+=a[i]*b[j];
}
}
}else{
for(int i=0;i<n;i++){
for(int j=0;j<m;j++){
ans[i+j]+=a[i]*b[j];
}
}
}
return ans;
}
template<class mint,internal::is_static_modint_t<mint>* =nullptr>
std::vector<mint>convolution_fft(std::vector<mint>a,std::vector<mint>b){
int n=int(a.size()),m=int(b.size());
int z=1<<internal::ceil_pow2(n+m-1);
a.resize(z);
internal::butterfly(a);
b.resize(z);
internal::butterfly(b);
for(int i=0;i<z;i++){
a[i]*=b[i];
}
internal::butterfly_inv(a);
a.resize(n+m-1);
mint iz=mint(z).inv();
for(int i=0;i<n+m-1;i++)a[i]*=iz;
return a;
}
}
template<class mint,internal::is_static_modint_t<mint>* =nullptr>
std::vector<mint>convolution(std::vector<mint>&&a,std::vector<mint>&&b){
int n=int(a.size()),m=int(b.size());
if(!n||!m)return{};
if(std::min(n,m)<=60)return convolution_naive(a,b);
return internal::convolution_fft(a,b);
}
template<class mint,internal::is_static_modint_t<mint>* =nullptr>
std::vector<mint>convolution(const std::vector<mint>&a,
const std::vector<mint>&b){
int n=int(a.size()),m=int(b.size());
if(!n||!m)return{};
if(std::min(n,m)<=60)return convolution_naive(a,b);
return internal::convolution_fft(a,b);
}
template<unsigned int mod=998244353,
class T,
std::enable_if_t<internal::is_integral<T>::value>* =nullptr>
std::vector<T>convolution(const std::vector<T>&a,const std::vector<T>&b){
int n=int(a.size()),m=int(b.size());
if(!n||!m)return{};
using mint=static_modint<mod>;
std::vector<mint>a2(n),b2(m);
for(int i=0;i<n;i++){
a2[i]=mint(a[i]);
}
for(int i=0;i<m;i++){
b2[i]=mint(b[i]);
}
auto c2=convolution(move(a2),move(b2));
std::vector<T>c(n+m-1);
for(int i=0;i<n+m-1;i++){
c[i]=c2[i].val();
}
return c;
}
std::vector<long long>convolution_ll(const std::vector<long long>&a,
const std::vector<long long>&b){
int n=int(a.size()),m=int(b.size());
if(!n||!m)return{};
static constexpr unsigned long long MOD1=754974721;
static constexpr unsigned long long MOD2=167772161;
static constexpr unsigned long long MOD3=469762049;
static constexpr unsigned long long M2M3=MOD2*MOD3;
static constexpr unsigned long long M1M3=MOD1*MOD3;
static constexpr unsigned long long M1M2=MOD1*MOD2;
static constexpr unsigned long long M1M2M3=MOD1*MOD2*MOD3;
static constexpr unsigned long long i1=
internal::inv_gcd(MOD2*MOD3,MOD1).second;
static constexpr unsigned long long i2=
internal::inv_gcd(MOD1*MOD3,MOD2).second;
static constexpr unsigned long long i3=
internal::inv_gcd(MOD1*MOD2,MOD3).second;
auto c1=convolution<MOD1>(a,b);
auto c2=convolution<MOD2>(a,b);
auto c3=convolution<MOD3>(a,b);
std::vector<long long>c(n+m-1);
for(int i=0;i<n+m-1;i++){
unsigned long long x=0;
x+=(c1[i]*i1)%MOD1*M2M3;
x+=(c2[i]*i2)%MOD2*M1M3;
x+=(c3[i]*i3)%MOD3*M1M2;
long long diff=
c1[i]-internal::safe_mod((long long)(x),(long long)(MOD1));
if(diff<0)diff+=MOD1;
static constexpr unsigned long long offset[5]={
0,0,M1M2M3,2*M1M2M3,3*M1M2M3};
x-=offset[diff%5];
c[i]=x;
}
return c;
}
}
#define all(c)begin(c),end(c)
namespace r7h{
using fp=atcoder::modint998244353;
void main(int){
int n,k;
scan(n,k);
vector<int>a(n);
scan(a);
vector<basic_string<int>>g(n);
for(int v:rep(1,n)){
int p;
scan(p);
--p;
g[p]+=v;
}
vector f(n,vector<fp>(2001));
fix([&](auto self,int v)->void{
f[v][0]=1;
for(int u:g[v]){
self(u);
f[v]=atcoder::convolution(f[v],f[u]);
f[v].resize(2001);
}
for(int i:rev(rep1(2000))){f[v][i]=a[v]<=i?f[v][i-a[v]]:0;}
f[v][0]=1;
})(0);
println(f[0][k].val());
}
}

