#include <stdio.h>
#include <cmath>
#include <algorithm>
#include <cfloat>
#include <stack>
#include <queue>
#include <vector>
#include <string>
#include <iostream>
#include <set>
#include <map>
#include <time.h>
typedef long long int ll;
typedef unsigned long long int ull;
#define BIG_NUM 2000000000
#define MOD 1000000007
#define EPS 0.000000001
using namespace std;


#define NUM 100005

int height[NUM]; //同じグループに属しているかどうかだけを調べるために使用
int calc_parent[NUM];
int relative_weight[NUM]; //自分のボスとの相対的な重さの差を持つ配列

struct Info{
	void set(int arg_parent_id,int arg_weight_sum){
		parent_id = arg_parent_id;
		weight_sum = arg_weight_sum;
	}
	int parent_id,weight_sum;
};

Info find_parent_and_calc_weight(int id){
	if(calc_parent[id] == id){
		Info ret;
		ret.set(id,0); //大ボスの相対的重さは必ず0
		return ret;
	}
	else{
		Info ret = find_parent_and_calc_weight(calc_parent[id]); //大ボスのidと、自分より上の相対的重さの総和を取得
		calc_parent[id] = ret.parent_id;
		relative_weight[id] += ret.weight_sum; //自分より上の相対的重さを足す
		ret.weight_sum = relative_weight[id];

		return ret;
	}
}


//グループの統合、および相対的重さ木の統合を行う
void unite(int a,int b,int w){

	//まずは
	Info a_info = find_parent_and_calc_weight(a);
	Info b_info = find_parent_and_calc_weight(b);

	if(a_info.parent_id == b_info.parent_id)return; //大ボスが同じならreturn

	//統合処理
	if(height[a_info.parent_id] == height[b_info.parent_id]){ //木の高さが同じ場合はaに併合する

		relative_weight[b_info.parent_id] = w-(relative_weight[b]-relative_weight[a]);
		calc_parent[b_info.parent_id] = a_info.parent_id;

	}else if(height[a_info.parent_id] == height[b_info.parent_id]){ //木の高さが高い方に併合する
		relative_weight[b_info.parent_id] = w-(relative_weight[b]-relative_weight[a]);
		calc_parent[b_info.parent_id] = a_info.parent_id;
		height[a_info.parent_id]++;
	}else{

		relative_weight[a_info.parent_id] = (relative_weight[b]-relative_weight[a])-w;
		calc_parent[a_info.parent_id] = b_info.parent_id;
	}
}

bool isSame(int a,int b){
	Info left = find_parent_and_calc_weight(a);
	Info right = find_parent_and_calc_weight(b);

	return left.parent_id == right.parent_id;
}

int main(){

	int N,Q;
	scanf("%d %d",&N,&Q);

	for(int i = 0; i <= N; i++){
		height[i] = 0;
		calc_parent[i] = i;
		relative_weight[i] = 0; //初期値は0にしておく
	}

	int command,A,B,value;
	for(int loop = 0; loop < Q; loop++){
		scanf("%d",&command);

		if(command == 0){
			scanf("%d %d %d",&A,&B,&value);
			unite(A,B,value);
		}else{
			scanf("%d %d",&A,&B);
			if(!isSame(A,B)){ //★ここでそれぞれの経路圧縮&weight計算が行われる★
				printf("?\n");
			}else{
				printf("%d\n",relative_weight[B]-relative_weight[A]);
			}
		}
	}

	return 0;
}


