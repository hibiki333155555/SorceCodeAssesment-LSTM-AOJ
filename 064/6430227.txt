#ifndef CLASS_MODINT
#define CLASS_MODINT

#include <cstdint>

template <std::uint32_t mod>
class modint {
private:
	std::uint32_t n;
public:
	modint() : n(0) {};
	modint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};
	static constexpr std::uint32_t get_mod() { return mod; }
	std::uint32_t get() const { return n; }
	bool operator==(const modint& m) const { return n == m.n; }
	bool operator!=(const modint& m) const { return n != m.n; }
	modint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }
	modint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }
	modint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }
	modint operator+(const modint& m) const { return modint(*this) += m; }
	modint operator-(const modint& m) const { return modint(*this) -= m; }
	modint operator*(const modint& m) const { return modint(*this) *= m; }
	modint inv() const { return (*this).pow(mod - 2); }
	modint pow(std::uint64_t b) const {
		modint ans = 1, m = modint(*this);
		while (b) {
			if (b & 1) ans *= m;
			m *= m;
			b >>= 1;
		}
		return ans;
	}
};

#endif // CLASS_MODINT

#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;
using mint = modint<998244353>;

int main() {
	// step #1. read input
	cin.tie(0);
	ios_base::sync_with_stdio(false);
	int N;
	cin >> N;
	vector<long long> A(2 * N);
	for (int i = 1; i < 2 * N; i++) {
		cin >> A[i];
	}

	// step #2. DP
	vector<int> L(2 * N), R(2 * N);
	for (int i = N; i < 2 * N; i++) {
		L[i] = i - N;
		R[i] = i - N + 1;
	}
	for (int i = N - 1; i >= 1; i--) {
		A[i] = min(A[i], A[2 * i] + A[2 * i + 1]);
		L[i] = L[2 * i];
		R[i] = R[2 * i + 1];
	}

	// step #3. calculate for each segment
	function<long long(int, int, int)> calc = [&](int pos, int l, int r) {
		if (l <= L[pos] && R[pos] <= r) {
			return A[pos];
		}
		if (r <= L[pos] || R[pos] <= l) {
			return 0LL;
		}
		long long lc = calc(pos * 2, l, r);
		long long rc = calc(pos * 2 + 1, l, r);
		return lc + rc;
	};
	mint answer = 0;
	for (int i = N; i < 2 * N; i++) {
		answer += A[i];
	}
	for (int i = 1; i < N; i++) {
		int l = L[i], m = R[2 * i], r = R[i];
		for (int j = 0; j < m - l; j++) {
			answer += mint(calc(2 * i, m - j - 1, m) * (r - m));
		}
		for (int j = 0; j < r - m; j++) {
			answer += mint(calc(2 * i + 1, m, m + j + 1) * (m - l));
		}
		answer -= A[2 * i] + A[2 * i + 1] - A[i];
	}

	// step #4. output the answer
	cout << answer.get() << endl;

	return 0;
}
