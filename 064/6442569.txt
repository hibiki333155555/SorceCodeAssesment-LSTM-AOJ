#include <bits/stdc++.h>

// compress 1
template<typename T>
std::vector<T> compress(std::vector<T> &a) {
    std::vector<T> val = a;
    int n = (int)a.size();
    sort(val.begin(), val.end());
    val.erase(std::unique(val.begin(), val.end()), val.end());
    for(int i = 0;i < n; i++) {
        a[i] = std::lower_bound(val.begin(), val.end(), a[i]) - val.begin();
    }
    return val;
}

// compress 2
template<typename T>
std::vector<T> compress(std::vector<T> &p1, std::vector<T> &p2) {
    std::vector<T> vals;
    for(int i = 0;i < (int)p1.size(); i++) {
        vals.push_back(p1[i]);
        vals.push_back(p1[i] + 1);
    }
    for(int i = 0;i < (int)p2.size(); i++) {
        vals.push_back(p2[i]); 
        vals.push_back(p2[i] + 1);
    }
    sort(vals.begin(), vals.end());
    vals.erase(std::unique(vals.begin(), vals.end()), vals.end());
    for(int i = 0;i < (int)p1.size(); i++) {
        p1[i] = std::lower_bound(vals.begin(), vals.end(), p1[i]) - vals.begin();
    }
    for(int i = 0;i < (int)p2.size(); i++) {
        p2[i] = std::lower_bound(vals.begin(), vals.end(), p2[i]) - vals.begin();
    }
    return vals;
}

// p1 & p2 change into compress point 
// vals means original point before compressed
// so vals[p1[i]] & vals[p2[i]] means original points

int main(){
    using namespace std;
    using ll = long long;
    #define rep(i,n) for (int i = 0;i < (int)(n); i++)
    int n;
    cin >> n;
    vector<ll> x1(n),x2(n),y1(n),y2(n);
    rep(i,n){
        cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];
    }
    vector<ll> x = compress(x1,x2);
    vector<ll> y = compress(y1,y2);
    int w = (int)x.size();
    int h = (int)y.size();
    vector<vector<int>> maze(h+1,vector<int>(w+1,0));
    rep(i,n){
        maze[y1[i]][x1[i]] ++;
        maze[y2[i]][x2[i]] ++;
        maze[y1[i]][x2[i]] --;
        maze[y2[i]][x1[i]] --;
    }
    rep(i,h+1){
        rep(j,w){
            maze[i][j+1]+=maze[i][j];
        }
    }
    rep(j,w+1){
        rep(i,h){
            maze[i+1][j]+=maze[i][j];
        }
    }
    ll ans = 0;
    rep(i,h-1)rep(j,w-1){
        if(maze[i][j]>0){
            ans += (y[i+1]-y[i])*(x[j+1]-x[j]);
        }
    }
    cout << ans << endl;
    return 0;
}
