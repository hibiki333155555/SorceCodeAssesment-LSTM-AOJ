#include <bits/stdc++.h>

using coordinate_t = long double;
const coordinate_t PI = std::acos(-1);
const coordinate_t EPS = 1e-9;
int sgn(coordinate_t a) {
    return (a < -EPS) ? -1 : (a > EPS) ? 1 : 0;
};
struct Point {
    coordinate_t x, y;
    Point() {
    }
    Point(coordinate_t _x, coordinate_t _y) : x(_x), y(_y) {
    }
    Point operator+(const Point &rhs) {
        Point res(*this);
        return res += rhs;
    }
    Point operator-(const Point &rhs) {
        Point res(*this);
        return res -= rhs;
    }
    Point operator*(const coordinate_t &rhs) {
        Point res(*this);
        return res *= rhs;
    }
    Point operator/(const coordinate_t &rhs) {
        Point res(*this);
        return res /= rhs;
    }
    inline bool operator<(const Point &b) {
        if (sgn(x - b.x)) return sgn(x - b.x) < 0;
        return sgn(y - b.y) < 0;
    }
    Point operator+=(const Point &rhs) {
        x += rhs.x, y += rhs.y;
        return *this;
    }
    Point operator-=(const Point &rhs) {
        x -= rhs.x, y -= rhs.y;
        return *this;
    }
    Point operator*=(const coordinate_t &rhs) {
        x *= rhs, y *= rhs;
        return *this;
    }
    Point operator/=(const coordinate_t &rhs) {
        x /= rhs, y /= rhs;
        return *this;
    }
    Point rotate(const coordinate_t &theta) {
        coordinate_t px = x, py = y;
        x = px * cos(theta) - py * sin(theta);
        y = px * sin(theta) + py * cos(theta);
        return *this;
    }
    coordinate_t abs() {
        return std::sqrt(x * x + y * y);
    }
    coordinate_t dot(const Point &rhs) {
        return x * rhs.x + y * rhs.y;
    }
    coordinate_t det(const Point &rhs) {
        return x * rhs.y - y * rhs.x;
    }
    coordinate_t arg() {
        return std::atan2(y, x);
    }
};
inline bool operator<(const Point &a, const Point &b) {
    if (sgn(a.x - b.x)) return sgn(a.x - b.x) < 0;
    return sgn(a.y - b.y) < 0;
}
inline bool operator==(const Point &a, const Point &b) {
    return sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0;
}
coordinate_t det(const Point &a, const Point &b) {
    return a.x * b.y - a.y * b.x;
}

std::istream &operator>>(std::istream &is, Point &p) {
    coordinate_t x, y;
    is >> x >> y;
    p = {x, y};
    return is;
}
std::ostream &operator<<(std::ostream &os, const Point &p) {
    return os << std::fixed << std::setprecision(10) << p.x << ' ' << p.y;
}

std::pair<coordinate_t, std::pair<Point, Point>> closest_pair(
    std::vector<Point> ps) {
    std::sort(ps.begin(), ps.end(),
              [](Point a, Point b) { return sgn(a.x - b.x) < 0; });
    std::vector<Point> memo(ps.size());
    auto dfs = [&](auto dfs, int l,
                   int r) -> std::pair<coordinate_t, std::pair<Point, Point>> {
        if (r - l < 2) return {1e18, {Point(), Point()}};
        int m = (r + l) / 2;
        coordinate_t x = ps[m].x;
        auto l_res = dfs(dfs, l, m), r_res = dfs(dfs, m, r);
        auto [d, p] = (l_res.first < r_res.first ? l_res : r_res);
        std::inplace_merge(ps.begin() + l, ps.begin() + m, ps.begin() + r,
                           [](Point a, Point b) { return sgn(a.y - b.y) < 0; });

        int cur = 0;
        for (int i = l; i < r; i++) {
            if (std::fabs(ps[i].x - x) >= d) continue;
            for (int j = cur - 1; j >= 0; j--) {
                if (ps[i].y - memo[j].y >= d) break;
                coordinate_t new_d = (ps[i] - memo[j]).abs();
                if (new_d < d) {
                    d = new_d;
                    p = {ps[i], memo[j]};
                }
            }
            memo[cur++] = ps[i];
        }
        return {d, p};
    };
    return dfs(dfs, 0, (int)ps.size());
}

const int COUNTER_CLOCKWISE = 1;
const int CLOCKWISE = -1;
const int ONLINE_BACK = -2;
const int ONLINE_FRONT = 2;
const int ON_SEGMENT = 0;
int ccw(Point a, Point b, Point c) {
    if (sgn((b - a).det(c - a)) > 0) {
        return COUNTER_CLOCKWISE;  // counter clockwise
    }
    if (sgn((b - a).det(c - a)) < 0) {
        return CLOCKWISE;  // clockwise
    }
    if (sgn((b - a).dot(c - a)) < 0) {
        return ONLINE_BACK;  // c - a - b
    }
    if (sgn((a - b).dot(c - b)) < 0) {
        return ONLINE_FRONT;  // a - b - c
    }
    return ON_SEGMENT;  // a - c - b
}

struct Line {
    Point a, b;
    Line() {
    }
    Line(Point _a, Point _b) : a(_a), b(_b) {
    }
    bool is_orthogonal(Line l) {
        return sgn((b - a).x * (l.b - l.a).x + (b - a).y * (l.b - l.a).y) == 0;
    }
    bool is_parallel(Line l) {
        return sgn((b - a).x * (l.b - l.a).y - (b - a).y * (l.b - l.a).x) == 0;
    }
};
std::istream &operator>>(std::istream &is, Line &l) {
    Point a, b;
    is >> a >> b;
    l = {a, b};
    return is;
};
struct Segment {
    Point a, b;
    Segment() {
    }
    Segment(Point _a, Point _b) : a(_a), b(_b) {
    }
    bool intersect(Segment s) {
        Point c = s.a, d = s.b;
        return sgn(ccw(a, b, c) * ccw(a, b, d)) <= 0 &&
               sgn(ccw(c, d, a) * ccw(c, d, b)) <= 0;
    }
    Point intersection(Segment s) {
        assert(intersect(s));
        Point c = s.a, d = s.b;
        return a + (b - a) * ((c - a).det(d - c) / (b - a).det(d - c));
    }

    bool intersect(Line l) {
        Point c = l.a, d = l.b;
        return ccw(c, d, a) * ccw(c, d, b) == -1;
    }
    Point intersection(Line l) {
        assert(intersect(l));
        Point c = l.a, d = l.b;
        return a + (b - a) * ((c - a).det(d - c) / (b - a).det(d - c));
    }

    coordinate_t dist(Point c) {
        if (sgn((b - a).dot(c - a)) < 0) {
            return (c - a).abs();
        }
        if (sgn((a - b).dot(c - b)) < 0) {
            return (c - b).abs();
        }
        return std::fabs((c - a).det(b - a)) / (b - a).abs();
    }
    coordinate_t dist(Segment p) {
        if (intersect(p)) return 0;
        return std::min({dist(p.a), dist(p.b), p.dist(a), p.dist(b)});
    }
};
std::istream &operator>>(std::istream &is, Segment &s) {
    Point a, b;
    is >> a >> b;
    s = {a, b};
    return is;
};
struct Polygon : std::vector<Point> {
    Polygon(int n = 0) : std::vector<Point>(n) {
    }
    coordinate_t area() {
        coordinate_t ret = 0;
        for (int i = 0; i < (int)size(); i++) {
            ret += det((*this)[i], (*this)[(i + 1) % (int)size()]);
        }
        ret /= 2.0;
        return ret;
    }
    bool is_convex() {
        for (int i = 0; i < (int)size(); i++) {
            if (ccw((*this)[i], (*this)[(i + 1) % (int)size()],
                    (*this)[(i + 2) % (int)size()]) == CLOCKWISE) {
                return false;
            }
        }
        return true;
    }
    int contain(const Point &p) {
        bool is_in = false;
        for (int i = 0; i < (int)size(); i++) {
            int ccw_ = ccw((*this)[i], (*this)[(i + 1) % (int)size()], p);
            if (ccw_ == ON_SEGMENT) {
                return 1;  // p is on a segment of polygon
            }
            Point a = (*this)[i] - p, b = (*this)[(i + 1) % (int)size()] - p;
            if (b < a) std::swap(a, b);
            if (sgn(a.x) <= 0 && sgn(b.x) > 0 && sgn(a.det(b)) < 0)
                is_in ^= true;
        }
        return is_in ? 2 /* polygon contains p */ : 0;
    }
    coordinate_t diameter() {
        assert(is_convex());
        coordinate_t ret = 0;
        int r = 0;
        for (int l = 0; l < (int)size(); l++) {
            while (sgn(((*this)[l] - (*this)[r]).abs() -
                       ((*this)[l] - (*this)[(r + 1) % (int)size()]).abs()) <
                   0) {
                r++;
                if (r == (int)size()) r = 0;
            }
            ret = std::max(ret, ((*this)[l] - (*this)[r]).abs());
        }
        return ret;
    }
    Polygon convex_cut_left(Line l) {
        Polygon ret;
        for (int i = 0; i < (int)size(); i++) {
            if (ccw(l.a, l.b, (*this)[i]) != CLOCKWISE) {
                ret.push_back((*this)[i]);
            }
            Segment s((*this)[i], (*this)[(i + 1) % (int)size()]);
            if (s.intersect(l)) {
                ret.push_back(s.intersection(l));
            }
        }
        return ret;
    }
    Polygon convex_cut_right(Line l) {
        Polygon ret;
        for (int i = 0; i < (int)size(); i++) {
            if (ccw(l.a, l.b, (*this)[i]) != COUNTER_CLOCKWISE) {
                ret.push_back((*this)[i]);
            }
            Segment s((*this)[i], (*this)[(i + 1) % (int)size()]);
            if (s.intersect(l)) {
                ret.push_back(s.intersection(l));
            }
        }
        return ret;
    }
};
Polygon convex_hull(std::vector<Point> ps) {
    int n = int(ps.size());
    std::sort(ps.begin(), ps.end());
    Polygon ret(2 * n);
    int k = 0;
    for (int i = 0; i < n; ret[k++] = ps[i++]) {
        while (k >= 2 &&
               sgn((ret[k - 1] - ret[k - 2]).det(ps[i] - ret[k - 2])) < 0) {
            k--;
        }
    }
    for (int i = n - 2, t = k + 1; i >= 0; ret[k++] = ps[i--]) {
        while (k >= t &&
               sgn((ret[k - 1] - ret[k - 2]).det(ps[i] - ret[k - 2])) < 0) {
            k--;
        }
    }
    ret.resize(k - 1);
    return ret;
}

struct Circle {
    Point p;
    coordinate_t r;
    Circle() {
    }
    Circle(Point _p, coordinate_t _r) : p(_p), r(_r) {
    }
};
int common_tangent_lines(Circle c1, Circle c2) {
    if (sgn((c1.p - c2.p).abs() - (c1.r + c2.r)) > 0) {
        return 4;  // do not cross
    }
    if (sgn((c1.p - c2.p).abs() - (c1.r + c2.r)) == 0) {
        return 3;  // circumscribed
    }
    if (sgn((c1.p - c2.p).abs() - std::fabs(c1.r - c2.r)) > 0) {
        return 2;  // intersects
    }
    if (sgn((c1.p - c2.p).abs() - std::fabs(c1.r - c2.r)) == 0) {
        return 1;  // inscribed
    }
    return 0;
}

using namespace std;
int main() {
    Point p1, p2;
    coordinate_t r1, r2;
    cin >> p1 >> r1 >> p2 >> r2;
    Circle c1(p1, r1), c2(p2, r2);
    cout << common_tangent_lines(c1, c2) << '\n';
}

