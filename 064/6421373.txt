#define READ_FROM_FILE 0

#if READ_FROM_FILE
#include <fstream>
#endif

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;


const int dim = 2;

class PointInfo {
public:
	int coord[dim];
	int idx;

public:
	PointInfo() : idx(-1) {
		return;
	}

	~PointInfo() {
		return;
	}
};

class Node {
public:
	int location;
	int left;
	int right;

public:
	Node() : location(-1), left(-1), right(-1) {
		return;
	}

	~Node() {
		return;
	}
};

const int max_num_points = 500001;
PointInfo points[max_num_points];
Node nodes[max_num_points];
int num_nodes = 0;


int make_kd_tree(int left, int right, int depth) {
	if (left >= right) {
		return -1;
	}

	int mid = (left + right) / 2;
	int axis = depth % dim;
	int n_depth = depth + 1;
	int node_idx = num_nodes++;

	sort(points + left, points + right, [&axis](const PointInfo& lh, const PointInfo& rh) { return lh.coord[axis] < rh.coord[axis]; });
	nodes[node_idx].location = mid;
	nodes[node_idx].left = make_kd_tree(left, mid, n_depth);
	nodes[node_idx].right = make_kd_tree(mid + 1, right, n_depth);

	return node_idx;
}

bool is_contained(const int cp[], const int s_coord[], const int t_coord[]) {
	for (int i = 0; i < dim; i++) {
		if (!(s_coord[i] <= cp[i] && cp[i] <= t_coord[i])) {
			return false;
		}
	}
	return true;
}

void search_kd_tree(int node_idx, const int s_coord[], const int t_coord[], int depth, vector<int>& idx_vec) {
	const PointInfo& cp = points[nodes[node_idx].location];
	int idx = cp.idx;
	int left = nodes[node_idx].left;
	int right = nodes[node_idx].right;
	int axis = depth % dim;
	int n_depth = depth + 1;

	if (is_contained(cp.coord, s_coord, t_coord)) {
		idx_vec.push_back(idx);
	}

	if (left >= 0) {
		if (s_coord[axis] <= cp.coord[axis]) {
			search_kd_tree(left, s_coord, t_coord, n_depth, idx_vec);
		}
	}
	if (right >= 0) {
		if (cp.coord[axis] <= t_coord[axis]) {
			search_kd_tree(right, s_coord, t_coord, n_depth, idx_vec);
		}
	}
	return;
}

int main(int argc, char** argv) {
#if READ_FROM_FILE
	ifstream ifs("test0.txt");
	cin.rdbuf(ifs.rdbuf());
#endif
	int n = -1;
	int k = 2;
	int x = 0;
	int y = 0;
	int q = -1;
	int root = -1;

	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> points[i].coord[0] >> points[i].coord[1];
		points[i].idx = i;
	}

	root = make_kd_tree(0, n, 0);

	cin >> q;
	for (int i = 0; i < q; i++) {
		vector<int> idx_vec;
		int s_coord[dim];
		int t_coord[dim];

		cin >> s_coord[0] >> t_coord[0] >> s_coord[1] >> t_coord[1];
		search_kd_tree(root, s_coord, t_coord, 0, idx_vec);
		sort(idx_vec.begin(), idx_vec.end());
		for (const int& idx : idx_vec) {
			cout << idx << endl;
		}
		cout << endl;
	}
	return 0;
}

