#pragma region Macros
#include <bits/stdc++.h>
using namespace std;
template <class T> inline bool chmax(T &a, T b) {
    if(a < b) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T> inline bool chmin(T &a, T b) {
    if(a > b) {
        a = b;
        return 1;
    }
    return 0;
}
#ifdef DEBUG
template <class T, class U>
ostream &operator<<(ostream &os, const pair<T, U> &p) {
    os << '(' << p.first << ',' << p.second << ')';
    return os;
}
template <class T> ostream &operator<<(ostream &os, const vector<T> &v) {
    os << '{';
    for(int i = 0; i < (int)v.size(); i++) {
        if(i) { os << ','; }
        os << v[i];
    }
    os << '}';
    return os;
}
void debugg() { cerr << endl; }
template <class T, class... Args>
void debugg(const T &x, const Args &... args) {
    cerr << " " << x;
    debugg(args...);
}
#define debug(...)                                                             \
    cerr << __LINE__ << " [" << #__VA_ARGS__ << "]: ", debugg(__VA_ARGS__)
#define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
#else
#define debug(...) (void(0))
#define dump(x) (void(0))
#endif

struct Setup {
    Setup() {
        cin.tie(0);
        ios::sync_with_stdio(false);
        cout << fixed << setprecision(15);
    }
} __Setup;

using ll = long long;
#define OVERLOAD3(_1, _2, _3, name, ...) name
#define ALL(v) (v).begin(), (v).end()
#define RALL(v) (v).rbegin(), (v).rend()
#define REP1(i, n) for(int i = 0; i < int(n); i++)
#define REP2(i, a, b) for(int i = (a); i < int(b); i++)
#define REP(...) OVERLOAD3(__VA_ARGS__, REP2, REP1)(__VA_ARGS__)
#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())
#define SZ(v) ((int)(v).size())
const int INF = 1 << 30;
const ll LLINF = 1LL << 60;
constexpr int MOD = 1000000007;
constexpr int MOD2 = 998244353;
const int dx[4] = {1, 0, -1, 0};
const int dy[4] = {0, 1, 0, -1};

void Case(int i) { cout << "Case #" << i << ": "; }
int popcount(int x) { return __builtin_popcount(x); }
ll popcount(ll x) { return __builtin_popcountll(x); }
#pragma endregion Macros

#include "math/modint.hpp"
using mint = ModInt<MOD2>;
#include "math/matrix.hpp"
using matrix = Matrix<mint>;
using Array = array<mint, 26>;
using Data = pair<ll, mint>;

int N, M;
int n;
vector<string> s;
vector<Data> v;
ll nowl;
Array vals;

void program(int& i, int& j);
void declaration(int& i, int& j);
void assignment(int& i, int& j);
mint print(int& i, int& j);
void For(int& i, int& j);
// void for_element(int& i, int& j);
pair<array<int, 26>, mint> expression(int& i, int& j);
void term1(int& i, int& j);
void term2(int& i, int& j);
mint number(int& i, int& j);
int value_name(int& i, int& j);

int main() {
    while(1) {
        cin >> N >> M;
        if(N == M and M == 0) break;
        vector<string> S(N), T(M);
        REP(i, N) cin >> S[i];
        REP(i, M) cin >> T[i];
        // S
        n = N;
        s = S;
        v.clear();
        REP(i, 26) vals[i] = 0;
        int ii = 0, jj = 0;
        program(ii, jj);
        auto vs = v;
        // T
        n = M;
        s = T;
        v.clear();
        REP(i, 26) vals[i] = 0;
        ii = 0, jj = 0;
        program(ii, jj);
        auto vt = v;
        // 一致判定
        auto compress = [&](vector<Data>& a) {
            vector<Data> res;
            res.push_back(a[0]);
            REP(i, 1, SZ(a)) {
                if(a[i].second == res.back().second) res.back().first += a[i].first;
                else res.emplace_back(a[i]);
            }
            a = res;
        };
        compress(vs);
        compress(vt);
        if(vs == vt) cout << "Yes\n";
        else cout << "No\n";
    }
}

mint number(int& i, int& j) {
    mint res = 0;
    while(j < SZ(s[i]) and isdigit(s[i][j])) {
        res = res * 10 + (s[i][j] - '0');
        j++;
    }
    return res;
}

void program(int& i, int& j) {
    while(i < n) {
        if(s[i][j] == 'p') {
            if(j + 1 < SZ(s[i])) {
                if(s[i][j+1] == 'r') {
                    v.emplace_back(1, print(i, j));
                }
                else {
                    assert(s[i][j+1] == '<');
                    assignment(i, j);
                }
            } else {
                declaration(i, j);
            }
        } else if(s[i][j] == 'f') {
            if(j + 1 < SZ(s[i])) {
                if(s[i][j+1] == 'o') For(i, j);
                else {
                    assert(s[i][j+1] == '<');
                    assignment(i, j);
                }
            } else {
                declaration(i, j);
            }
        } else {
            if(j + 1 < SZ(s[i]) and s[i][j+1] == '<') {
                assignment(i, j);
            } else {
                debug(i, j);
                declaration(i, j);
            }
        }
    }
}

void declaration(int& i, int& j) {
    i++;
}

int value_name(int& i, int& j) {
    int res = s[i][j++] - 'a';
    return res;
}

void assignment(int& i, int& j) {
    int l = value_name(i, j);
    j += 2;
    auto [cntr, cons] = expression(i, j); // 文字が何回たされたかの配列
    
    mint x = 0, y = cons;
    REP(i, 26) {
        if(i == l) x += cntr[i];
        else y += vals[i] * cntr[i];
    }

    vals[l] = vals[l] * x + y;
    i++;
}

mint print(int& i, int& j) {
    j += 6;
    auto [cntr, cons] = expression(i, j);
    mint res = cons;
    REP(i, 26) res += vals[i] * cntr[i];
    i++;
    return res;
}

void For(int& i, int& j) {
    int L = 1;
    debug(i, j, L);
    while(j+1 < SZ(s[i]) and s[i][j] == 'f' and s[i][j+1] == 'o') {
        debug(i, j, L);
        j += 4;
        auto [cntr, cons] = expression(i, j);
        int tmp = cons.x;
        REP(i, 26) tmp += vals[i].x * cntr[i];
        j += 1;
        L *= tmp;
    }
    debug(i, j, L);
    if(j + 1 < SZ(s[i]) and s[i][j] == 'p' and s[i][j+1] == 'r') {
        mint printValue = print(i, j);
        v.emplace_back(L, printValue);
        nowl += L;
    } else {
        int l = value_name(i, j);
        j += 2;
        auto [cntr, cons] = expression(i, j); // 文字が何回たされたかの配列
        
        mint x = 0, y = cons;
        REP(i, 26) {
            if(i == l) x += cntr[i];
            else y += vals[i] * cntr[i];
        }

        matrix A(2, 2);
        A[0][0] = x, A[0][1] = y, A[1][0] = 0, A[1][1] = 1;
        matrix init(2, 1);
        init[0][0] = vals[l], init[0][1] = 1;
        A ^= L;
        auto res = A * init;
        vals[l] = res[0][0];
        i++;
    }
}

pair<array<int, 26>, mint> expression(int& i, int& j) {
    array<int, 26> cnt;
    REP(i, 26) cnt[i] = 0;
    mint cons = 0;
    int firstSgn = 1;
    if(s[i][j] == '-') {
        firstSgn = -1;
        j++;
    }
    if(isdigit(s[i][j])) cons += number(i, j) * firstSgn;
    else cnt[value_name(i, j)] += firstSgn;
    while(j < SZ(s[i]) and s[i][j] == '-' or s[i][j] == '+') {
        int sgn = 1;
        if(s[i][j] == '-') sgn = -1;
        j++;
        if(isdigit(s[i][j])) cons += number(i, j) * sgn;
        else cnt[value_name(i, j)] += sgn;
    }
    return {cnt, cons};
}

あああああ
