#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

template <class S, S (*op)(S, S), S (*e)()> struct segtree {
    public:
        segtree() : segtree(0) {}
        segtree(int n) : segtree(std::vector<S>(n, e())) {}
        segtree(const std::vector<S>& v) : _n(int(v.size())) {
            log = ceil_pow2(_n);
            size = 1 << log;
            d = std::vector<S>(2 * size, e());
            for (int i = 0; i < _n; i++) d[size + i] = v[i];
            for (int i = size - 1; i >= 1; i--) {
                update(i);
            }
        }

        int ceil_pow2(int n) {
            int x = 0;
            while ((1U << x) < (unsigned int)(n)) x++;
            return x;
        }

    // a[p] <- x
    void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        d[p] = x;
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    // a[p]
    S get(int p) {
        assert(0 <= p && p < _n);
        return d[p + size];
    }

    // [l, r)
    S prod(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        S sml = e(), smr = e();
        l += size;
        r += size;

        while (l < r) {
            if (l & 1) sml = op(sml, d[l++]);
            if (r & 1) smr = op(d[--r], smr);
            l >>= 1;
            r >>= 1;
        }
        return op(sml, smr);
    }

    S all_prod() { return d[1]; }

    template <bool (*f)(S)> int max_right(int l) {
        return max_right(l, [](S x) { return f(x); });
    }
    template <class F> int max_right(int l, F f) {
        assert(0 <= l && l <= _n);
        assert(f(e()));
        if (l == _n) return _n;
        l += size;
        S sm = e();
        do {
            while (l % 2 == 0) l >>= 1;
            if (!f(op(sm, d[l]))) {
                while (l < size) {
                    l = (2 * l);
                    if (f(op(sm, d[l]))) {
                    sm = op(sm, d[l]);
                    l++;
                }
            }
            return l - size;
        }
            sm = op(sm, d[l]);
        l++;
        } while ((l & -l) != l);
        return _n;
    }

    template <bool (*f)(S)> int min_left(int r) {
        return min_left(r, [](S x) { return f(x); });
    }
    template <class F> int min_left(int r, F f) {
        assert(0 <= r && r <= _n);
        assert(f(e()));
        if (r == 0) return 0;
        r += size;
        S sm = e();
        do {
            r--;
            while (r > 1 && (r % 2)) r >>= 1;
            if (!f(op(d[r], sm))) {
                while (r < size) {
                r = (2 * r + 1);
                    if (f(op(d[r], sm))) {
                        sm = op(d[r], sm);
                        r--;
                    }
                }
                return r + 1 - size;
            }
            sm = op(d[r], sm);
        } while ((r & -r) != r);
        return 0;
    }

    private:
        int _n, size, log;
        std::vector<S> d;

    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
};

int op(int a, int b) { return max(a, b); }

int e() { return -1; }

int n;
vector<int> h;
segtree<int,op,e> st;
vector<int> id;
const ll C = 1000000;

int height(int l, int r) {
    if(l == r) return -1;
    if(l + 1 == r) return 0;
    int m = id[st.prod(l, r)];
    int L = height(l, m);
    int R = height(m + 1, r);
    return max(L, R) + 1;
};

int diameter(int l, int r) {
    if(l == r) return -1;
    if(l + 1 == r) return 0;
    int m = id[st.prod(l, r)];
    int L = diameter(l, m);
    int R = diameter(m + 1, r);
    int M = height(l, m) + height(m + 1, r) + 1;
    return max({L, M, R}) + 1;
};

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    cin >> n;
    h.resize(n);
    rep(i,n) cin >> h[i], h[i]--;

    // diamet[l][r] := max diameter in [l, r)
    // height[l][r] := height of tree has max diameter
    
    // m <- max h[l, r)
    // diamet[l][r] <- 1 + max( diamet[l][m], 
    //                          diamet[m + 1][r],
    //                          height[l][m] + height[m][r] + 1 )

    id.resize(n);
    rep(i,n) id[h[i]] = i;
    st = segtree<int,op,e>(h);
    cout << diameter(0, n) << endl;
    return 0;
}
