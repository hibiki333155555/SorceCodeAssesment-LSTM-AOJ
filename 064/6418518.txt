#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <cmath>
#include <iomanip>
#include <stack>
#include <queue>
#include <numeric>
#include <map>
#include <unordered_map>
#include <set>
#include <fstream>
#include <chrono>
#include <random>
#include <bitset>
//#include <atcoder/all>
#define rep(i,n) for(int i=0;i<(n);i++)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define sz(x) ((int)(x).size())
#define pb push_back
using ll = long long;
using namespace std;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
ll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}
ll lcm(ll a, ll b) {return a/gcd(a,b)*b;}

const ll mod = 998244353;

ll mpow(ll a, ll x){
  ll res = 1;
  while(x > 0){
    if(x & 1) res = (res * a) % mod;
    a = (a * a) % mod;
    x >>= 1;
  }
  return res;
}

ll minv(ll x){
  ll res = 1, k = mod - 2;
  while(k){
    if(k&1) res = (res * x) % mod;
    x = (x * x) % mod;
    k >>= 1;
  }
  return res;
}

int isc(char x){
  return 'a'<=x && x<='z';
}
int isd(char x){
  return '0'<=x && x<='9';
}

ll cdtd(char x){
  return (ll)(x-'0');
}

int cctd(char x){
  return (int)(x-'a');
}

pair<ll,int> readnum(const string& s, int idx){
  ll res = 0;
  for(int i=idx;i<sz(s);i++){
    if(!isd(s[i])){
      return {res,i-1};
    }
    res *= 10;
    res += cdtd(s[i]);
    res %= mod;
  }
  return {res,sz(s)-1};
}

pair<ll,ll> ex(char c, const string& s, int idx, const vector<ll>& v){
  int minusflag = 0;
  pair<ll,ll> res = {0,0};
  for(int i=idx;i<sz(s);i++){
    if(s[i]=='-') minusflag=1;
    else if(s[i]=='+') minusflag=0;
    else if(isc(s[i])){
      if(s[i]==c){
        if(minusflag) res.first--;
        else res.first++;
      }
      else{
        res.second += v[cctd(s[i])]%mod * (minusflag?-1:1);
        res.second += mod * 2;
        res.second %= mod;
      }
    }
    else if(isd(s[i])){
      auto p = readnum(s,i);
      res.second += p.first%mod * (minusflag?-1:1);
      res.second += mod * 2;
      res.second %= mod;
      i = p.second;
    }
  }
  return res;
}


pair<ll,ll> modparen(const string& s,int idx, const vector<ll>& v){
  ll res = 0;
  int minusflag = 0;
  for(int i=idx+1;i<sz(s);i++){
    if(s[i]==')'){
      return {res,i};
    }
    if(s[i]=='-') minusflag=1;
    else if(s[i]=='+') minusflag=0;
    else if(isc(s[i])){
      res+=v[cctd(s[i])]%mod*(minusflag?-1:1);
      res+=mod*2;
      res%=mod;
    }
    else if(isd(s[i])){
      auto p = readnum(s,i);
      res += p.first%mod * (minusflag?-1:1);
      res += mod*2;
      res %= mod;
      i = p.second;
    }
  }
  return {res,sz(s)};
}

ll f(ll a, pair<ll,ll> asn, ll t){
  if(a<0) a+=mod;
  a %= mod;
  ll r = asn.first;
  if(r<0) r+=mod;
  r %= mod;
  ll b = asn.second;
  if(b<0) b+=mod;
  b%=mod;
  ll n = t;
  ll ada = a * mpow(r,n) % mod;
  ll adb;
  if(r==1){
    adb = n * b % mod;
  }
  else{
    adb = b * (mpow(r,n)+mod-1)%mod * minv(r+mod-1);
  }
  return (ada+adb)%mod;
}

vector<pair<ll,ll>> calc(const vector<string>& P){
  int N = sz(P);
  vector<ll> val(26,-1);
  vector<pair<ll,ll>> OA;
  rep(i,N){
    if(sz(P[i])==1){
      // 変数定義
      char c = P[i][0];
      val[cctd(c)]=0;
    }
    else{
      ll donum = 1;
      for(int j=0;j<sz(P[i]);j++){
        // 代入
        if(j+2<sz(P[i]) && P[i].substr(j+1,2)=="<-"){
          char c = P[i][j];
          int idx = cctd(c);
          pair<ll,ll> asn = ex(c,P[i],j+3,val);
          val[idx] = f(val[idx],asn,donum);
          break;
        }
        // for
        else if(P[i].substr(j,3)=="for"){
          auto p = modparen(P[i],j+3,val);
          donum *= p.first;
          j = p.second;
        }
        // print
        else if(P[i].substr(j,5)=="print"){
          auto p = modparen(P[i],j+5,val);
          if(donum) OA.pb({p.first,donum});
          j = p.second;
        }
      }
    }
  }
  vector<pair<ll,ll>> OA2;
  rep(i,sz(OA)){
    if(i){
      if(OA2.back().first==OA[i].first){
        OA2.back().second+=OA[i].second;
      }
      else OA2.pb(OA[i]);
    }
    else OA2.pb(OA[i]);
  }
  return OA2;
}

void solve(int N,int M){
  vector<string> PA(N), PB(M);
  rep(i,N) cin >> PA[i];
  rep(i,M) cin >> PB[i];
  auto OA = calc(PA);
  auto OB = calc(PB);
  if(OA==OB) cout << "Yes" << '\n';
  else cout << "No" << '\n';
}

int main(){
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  while(1){
    int N,M; cin >> N >> M;
    if(N==0 && M==0) break;
    solve(N,M);
  }
  return 0;
}

