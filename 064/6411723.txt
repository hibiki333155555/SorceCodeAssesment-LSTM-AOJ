#pragma GCC diagnostic ignored "-Wmisleading-indentation"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wunused-parameter" 
#pragma GCC diagnostic ignored "-Wunused-variable"
#include <bits/stdc++.h>
using namespace std;
//#include <atcoder/all>
//using namespace atcoder;

//#define BOOST
#ifdef BOOST
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/integer/extended_euclidean.hpp>
using mpi = boost::multiprecision::cpp_int;
using mpf = boost::multiprecision::cpp_dec_float_100;
#endif

//#define LONG_LONG_INT
#ifdef LONG_LONG_INT
using ll = int; using ld = double;
using ull = unsigned int;
const ll inf = 1000000000;
#else
using ll = long long; using ld = long double;
using ull = unsigned long long;
const ll inf = 2000000000000000000;
#endif

/***** type *****/
template <class T> using vec = vector<T>;
template <class T> using vvec = vector<vector<T>>;
using pll = pair<ll, ll>; using plb = pair<ll, bool>; using pcl = pair<char, ll>; using psl = pair<string, ll>;
using vl = vec<ll>; using vb = vec<bool>; using vc = vec<char>; using vs = vec<string>;
using vpll = vec<pll>; using vpsl = vec<psl>;
using vvl = vvec<ll>; using vvb = vvec<bool>; using vvc = vvec<char>; using vvpll = vec<vec<pll>>;
using dl = deque<ll>; using dc = deque<char>; using dpll = deque<pll>;
using sl = set<ll>; using sc = set<char>; using spll = set<pll>;
using mll = map<ll, ll>; using mlb = map<ll, bool>; using mcl = map<char, ll>; using msl = map<string, ll>;
using graph = vvl; using wgraph = vvpll;
/***** define *****/
#define all(c) (c).begin(), (c).end()            // begin to end
#define allr(c) (c).rbegin(), (c).rend()         // rbegin to rend
#define coutld cout << fixed << setprecision(10) // cout double
#define pf first																 // pair::first
#define ps second																 // pair::second
#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat
#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse
#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)
#define each(i, e, c) fori (i, auto&& e: c)      // for each
/***** const value *****/
const long long llong_max = 9223372036854775807; // 9 * 10^18
const long double pi = 3.1415926535897932384626; // 3.14 ...
const long double eps = LDBL_EPSILON;            // 2.22e-016
const size_t not_find = string::npos;            // string::find()

/**
* 関数宣言
**/

template <class ... T> void bug(T ... args); // debug
// 入力（fixは入力値の調整）
template <class T> void inc(ll xs, T& c); // 一次元コンテナ入力
template <class T> void inc(ll xs, T& c, ll fix); // 一次元コンテナ入力
template <class T> void incc(ll ys, ll xs, T& cc); // 二次元コンテナ入力
template <class T> void incc(ll ys, ll xs, T& cc, ll fix); // 二次元コンテナ入力
void in_graph(ll v, ll e, graph& g, ll vfix = 0); // 頂点数v辺数eのグラフ入力
void in_graph(ll v, ll e, wgraph& g, ll vfix = 0); // 頂点数v辺数eのグラフ入力
void in_directed_graph(ll v, ll e, graph& g, ll vfix = 0); // 頂点数v辺数eの有向グラフ入力
void in_directed_graph(ll v, ll e, wgraph& g, ll vfix = 0);  // 頂点数v辺数eの重み付き有向グラフ入力
// 出力（ex=trueなら出力後にプログラムを終了する）
template <class T> void outc(T& c, bool ex = true); // コンテナを直接出力
template <class T> void outc(T& c, ll fix, bool ex = true); // コンテナを直接出力
template <class T> void outcc(T& cc); // 二次元コンテナを直接出力
template <class T> void outcc(T& cc, ll fix); // 二次元コンテナを直接出力
template <class ... T> void outl(T ... args); // 可変引数を改行区切りで出力
template <class T> void outlc(T& c, bool ex = true); // コンテナを改行区切りで出力
template <class T> void outlc(T& c, ll fix, bool ex = true); // コンテナを改行区切りで出力
template <class ... T> void outs(T ... args); // 可変引数をスペース区切りで出力
template <class T> void outsc(T& c, bool ex = true); // コンテナをスペース区切りで出力
template <class T> void outsc(T& c, ll fix, bool ex = true); // コンテナをスペース区切りで出力
template <class T> void outscc(T& cc); // 二次元コンテナをスペース区切りで出力
template <class T> void outscc(T& cc, ll fix = 0); // 二次元コンテナをスペース区切りで出力
// 変換
char lton(ll x); // ll -> char (number)
char ltoc(ll x); // ll -> char (lower case)
char ltouc(ll x); // ll -> char (upper case)
ll ntol(char c); // char (number) -> ll
ll ctol(char c); // char (lower case) -> ll
ll uctol(char c); // char (upper case) -> ll
graph tolg(wgraph& g); // wgraph -> graph
wgraph towlg(graph& g, ll c); // graph -> wgraph
string tolower(string& s); // 文字列を小文字に変換
string toupper(string& s); // 文字列を大文字に変換
// ビット演算
void bit_set(ll& x, ll i, ll b); // 整数xのi番目ビットをbに設定
ll bit_cnt(ll x); // C++20 popcount
ll bit_size(ll x); // 2進数にしたときのサイズを取得
ll bit_test(ll x, ll i); // 整数xのi番目ビットが0か1か返す
string bit_tostr(ll x); // 整数xをstringに変換
// long long 型
template <class C> ll cntll(C& c); // c.count()をllで返す
template <class C, class X> ll cntll(C& c, X x); // c.count(x)をllで返す
ll logll(ll a, ll b, bool u = false); // 底aのlog(b)切り捨て（u = trueならa進数bの桁数と同値）
ll powll(ll x, ll n); // xのy乗をllで返す
template <class T> ll sizell(T& c); // c.size()をllで返す
// 範囲チェック
template <class T> bool range(ll x, vec<T>& v); // 配列の範囲内チェック
template <class T> bool range(ll y, ll x, vvec<T>& v); // 二次元配列の範囲内チェック
template <class T> bool orange(ll x, vec<T>& v); // 配列の範囲外チェック
template <class T> bool orange(ll y, ll x, vvec<T>& v); // 二次元配列の範囲外チェック
// その他
template <class T> void itnext(T& it, ll INF = inf); // イテレータのインクリメント
template <class T> void itprev(T& it, ll INF = -inf); // イテレータのデクリメント
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc); // 二次元配列生成
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc, T fill); // 二次元配列生成（fillは初期値）
template <class T1, class ... T2> bool umax(T1& x, T2 ... args); // xを最大値に更新
template <class T1, class ... T2> bool umin(T1& x, T2 ... args); // xを最小値に更新
ll ceil_div(ll x, ll y); // 除算の天井関数 ceil(x / y)
template <ll i, class T> void ptsort(T b, T e); // pairやtupleをi番目の要素でソート

/**
* 関数定義
**/

template <class ... T> void bug(T ... args) { for (auto e : { args ... }) cerr << " " << e; cerr << endl; }
// 入力
template <class T> void in(T& x) { cin >> x; }
template <> void in<pll>(pll& x) { cin >> x.first >> x.second; }
template <class T> void in(T& x, ll fix) { cin >> x; x += fix; }
template <> void in<pll>(pll& x, ll fix) { cin >> x.first >> x.second; x.first += fix, x.second += fix; }
template <class T> void inc(ll xs, T& c) { c.resize(xs); each(i, e, c) in(e); }
template <class T> void inc(ll xs, T& c, ll fix) { c.resize(xs); each(i, e, c) in(e, fix); }
template <class T> void incc(ll ys, ll xs, T& cc) { makecc(ys, xs, cc); rep(y, 0, ys) rep(x, 0, xs) in(cc[y][x]); }
template <class T> void incc(ll ys, ll xs, T& cc, ll fix) { makecc(ys, xs, cc); rep(y, 0, ys) rep(x, 0, xs) in(cc[y][x], fix); }
void in_graph(ll v, ll e, graph& g, ll vfix) { ll a, b; g.resize(v); rep(i, 0, e) cin >> a >> b, a += vfix, b += vfix, g[a].push_back(b), g[b].push_back(a); }
void in_graph(ll v, ll e, wgraph& g, ll vfix) { ll a, b, w; g.resize(v); rep(i, 0, e) cin >> a >> b >> w, a += vfix, b += vfix, g[a].push_back({ b,w }), g[b].push_back({ a,w }); }
void in_directed_graph(ll v, ll e, graph& g, ll vfix) { ll a, b; g.resize(v); rep(i, 0, e) cin >> a >> b, a += vfix, b += vfix, g[a].push_back(b); }
void in_directed_graph(ll v, ll e, wgraph& g, ll vfix) { ll a, b, w; g.resize(v); rep(i, 0, e) cin >> a >> b >> w, a += vfix, b += vfix, g[a].push_back({ b,w }); }
// 出力
template <class T> void out(T x, bool s) { (s) ? cout << " " << x : cout << x; }
template <> void out<pll>(pll x, bool s) { cout << x.first << " " << x.second; }
template <class T> void outc(T& c, bool ex) { for (auto e : c) cout << e; cout << endl; if (ex) exit(0); }
template <class T> void outc(T& c, ll fix, bool ex) { for (auto e : c) cout << e + fix; cout << endl; if (ex) exit(0); }
template <class T> void outcc(T& cc) { for (auto e : cc) outc(e, false); exit(0); }
template <class T> void outcc(T& cc, ll fix) { for (auto e : cc) outc(e, fix, false); exit(0); }
template <class ... T> void outl(T ... args) { each(i, e, { args ... }) out(e, false), cout << endl; exit(0); }
template <class T> void outlc(T& c, bool ex) { for (auto e : c) out(e, false), cout << endl; if (ex) exit(0); }
template <class T> void outlc(T& c, ll fix, bool ex) { for (auto e : c) out(e + fix, false), cout << endl; if (ex) exit(0); }
template <class ... T> void outs(T ... args) { each(i, e, { args ... }) out(e, i); cout << endl; exit(0); }
template <class T> void outsc(T& c, bool ex) { each(i, e, c) out(e, i); cout << endl; if (ex) exit(0); }
template <class T> void outsc(T& c, ll fix, bool ex) { each(i, e, c) out(e + fix, i); cout << endl; if (ex) exit(0); }
template <class T> void outscc(T& cc) { for (auto e : cc) outcs(e, false); exit(0); }
template <class T> void outscc(T& cc, ll fix) { for (auto e : cc) outcs(e + fix, false); exit(0); }
// 変換
char lton(ll x) { return char('0' + x); }
char ltoc(ll x) { return char('a' + x); }
char ltouc(ll x) { return char('A' + x); }
ll ntol(char c) { return ll(c) - ll('0'); }
ll ctol(char c) { return ll(c) - ll('a'); }
ll uctol(char c) { return ll(c) - ll('A'); }
graph tolg(wgraph& g) { graph res(size(g)); each(i, e, g) for (auto [af, c] : e) res[i].push_back(af); return res; }
wgraph towlg(graph& g, ll c) { wgraph res(size(g)); each(i, e, g) for (auto af : e) res[i].push_back({ af,c }); return res; }
string tolower(string& s) { string res; for (auto e : s) if ('a' <= e && e <= 'z') res.push_back(tolower(e)); return res; }
string toupper(string& s) { string res; for (auto e : s) if ('a' <= e && e <= 'z') res.push_back(toupper(e)); return res; }
// ビット演算
void bit_set(ll& x, ll i, ll b) { (b) ? x |= (1ll << i) : x &= ~(1ll << i); }
ll bit_cnt(ll x) { bitset<64> b(x); return b.count(); }
ll bit_size(ll x) { return logll(2, x, true); }
ll bit_test(ll x, ll i) { return (i <= 62 && (x & (1ll << i)) != 0) ? 1 : 0; }
string bit_tostr(ll x) { string res; do { res += lton(x % 2), x /= 2; } while (x); reverse(all(res)); return res; }
// long long 型
template <class C> ll cntll(C& c) { return ll(c.count()); }
template <class C, class X> ll cntll(C& c, X x) { return ll(count(all(c), x)); }
ll logll(ll a, ll b, bool u) { ll now = 1, res = (u) ? 1 : 0; while (now < b) res++, now *= a; return (now != b) ? res - 1 : res; }
ll powll(ll x, ll n) { if (x == 2) return (1ll << n); ll z = 1; rep(i, 0, n) z *= x; return z; }
template <class T> ll sizell(T& c) { return ll(c.size()); }
// 範囲チェック
template <class T> bool range(ll x, vec<T>& v) { return !orange(x, v); }
template <class T> bool range(ll y, ll x, vvec<T>& v) { return !orange(y, x, v); }
template <class T> bool orange(ll x, vec<T>& v) { return (x < 0 || ll(v.size()) <= x); }
template <class T> bool orange(ll y, ll x, vvec<T>& v) { return (y < 0 || ll(v.size()) <= y || x < 0 || ll(v[y].size()) <= x); }
// その他
template <class T> void itnext(T& it, ll INF) { if (*it != INF) ++it; }
template <class T> void itprev(T& it, ll INF) { if (*it != INF) --it; }
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc) { cc.resize(ys); rep(y, 0, ys) cc[y].resize(xs); }
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc, T fill) { cc.resize(ys); rep(y, 0, ys) cc[y].resize(xs, fill); }
template <class T1, class ... T2> bool umax(T1& x, T2 ... args) { if (max({ args ... }) <= x) return false; x = max({ args ... }); return true; }
template <class T1, class ... T2> bool umin(T1& x, T2 ... args) { if (x <= min({ args ... })) return false; x = min({ args ... }); return true; }
ll ceil_div(ll x, ll y) { return (x % y == 0) ? x / y : x / y + 1; }
template <ll i, class T> void ptsort(T b, T e) { sort(b, e, [&](const auto& l, const auto& r) { return get<i>(l) < get<i>(r); }); }

/**
* @brief 欲張りセット
* @note
* 標準コンテナの頻出関数を全部定義したセット
**/

template <class T = long long, class U = std::less<T>> struct DS_AhriSet
{	// 降順は DS_NyaaAhriSet<greater<ll>> （デフォルトは昇順）
	using ll = long long;
	using it = typename std::set<T>::iterator;
	std::set<T> s;
	DS_AhriSet() {}
	DS_AhriSet(std::vector<T>& v) { for (auto e : v) s.insert(v); }
	// set interface
	it begin() { return s.begin(); }
	void clear() { s.clear(); }
	bool empty() { return s.empty(); }
	it end() { return s.end(); }
	std::pair<it, it> equal_range(T x) { return s.equal_range(); }
	void erase(T x) { s.erase(x); }
	bool find(T x) { return s.find(x) != s.end(); }
	void insert(T x) { s.insert(x); }
	it lower_bound(T x) { return s.lower_bound(x); }
	ll size() { return ll(s.size()); }
	it upper_bound(T x) { return s.upper_bound(x); }
	// deque interface
	T back() { return *s.rbegin(); }
	T front() { return *s.begin(); }
	T pop_back() { T res = *s.rbegin(); s.erase(res); return res; }
	T pop_front() { T res = *s.begin(); s.erase(res); return res; }
	void push_back(T x) { s.insert(x); }
	void push_front(T x) { s.insert(x); }
	// priority queue interface
	T pop() { T res = *s.begin(); s.erase(res); return res; }
	void push(T x) { s.insert(x); }
	T top() { *s.begin(); }
	// original interface
	T lower_bound_val(T x) { return *s.lower_bound(x); }
	T upper_bound_val(T x) { return *s.upper_bound(x); }
};

/**
* @brief 欲張りマルチセット
* @note
* 内部にunorderd_mapを持つことでcount(x)を定数時間に高速化
* 標準コンテナの頻出関数を全部定義したマルチセット
**/

template <class T = long long, class U = std::less<T>, class F = std::hash<T>> struct DS_GwenSet
{	// 降順は DS_NyaaPQMset<ll, greater<ll>> （デフォルトは昇順）
	using ll = long long;
	using it = typename std::multiset<T>::iterator;
	std::multiset<T, U> s;
	std::unordered_map<T, ll, F> m;
	DS_GwenSet() {}
	DS_GwenSet(std::vector<ll>& v) { for (auto e : v) push(e); }
	// multiset interface
	it begin() { return s.begin(); }
	void clear(void) { s.clear(), m.clear(); }
	ll count(T x) { return ((m.count(x) == 0) ? 0 : m[x]); }
	bool empty(void) { return s.empty(); }
	it end() { return s.end(); }
	ll erase(T x) { m.erase(); return s.erase(x); }
	bool find(T x) { return s.find(x); }
	void insert(T x) { m[x]++, s.insert(x); }
	it lower_bound(T x) { return s.lower_bound(x); }
	ll size() { return ll(s.size()); }
	it upper_bound(T x) { return s.upper_bound(x); }
	bool operator == (const DS_GwenSet& gs) { return (s == gs.s); }
	// deque interface
	T back() { return *s.rbegin(); }
	T front() { return *s.begin(); }
	void push_back(T x) { m[x]++, s.insert(x); }
	void push_front(T x) { m[x]++, s.insert(x); }
	T pop_back()
	{
		auto res = *s.rbegin();
		if (--m[res] == 0) m.erase(res);
		s.erase(s.find(res));
		return res;
	}
	T pop_front()
	{
		auto res = *s.begin();
		if (--m[res] == 0) m.erase(res);
		s.erase(s.find(res));
		return res;
	}
	// priority queue interface
	void push(T x) { m[x]++, s.insert(x); }
	T top(void) { return *s.begin(); }
	T pop(void)
	{
		T res = *s.begin();
		if (--m[res] == 0) m.erase(res);
		s.erase(s.find(res));
		return res;
	}
	// original interface
	ll lower_bound_val(T x) { return *s.lower_bound(x); }
	ll unique_size() { return ll(m.size()); }
	ll upper_bound_val(T x) { return *s.upper_bound(x); }
	ll erase1(T x)
	{
		if (m.count(x) == 0) return 0;
		if (m[x] == 1) s.erase(x), m.erase(x);
		else s.erase(s.find(x)), m[x]--;
		return 1;
	}
};

/***************************************/
/********** BEGIN OF NYAA LIB **********/
/***************************************/

namespace NyaaLIB {}

namespace NyaaLIB
{
	/*
	* 遅延評価セグメント木ライブラリ
	* 色々な区間クエリをO(log N)で処理する
	*/

	template <class S, S(*op)(S, S), S(*e)(), class F, S(*mapping)(F, S), F(*composition)(F, F), F(*id)()> struct DS_LazySegmentTree
	{
		using ll = long long;
		using ull = unsigned long long;
		DS_LazySegmentTree() : DS_LazySegmentTree(0) {}
		DS_LazySegmentTree(ll n) : DS_LazySegmentTree(std::vector<S>(n, e())) {}
		DS_LazySegmentTree(ll n, S init) : DS_LazySegmentTree(std::vector<S>(n, init)) {}
		DS_LazySegmentTree(const std::vector<S>& v) : _n((ll)v.size())
		{
			log = ceil_pow2(_n);
			size = 1LL << log;
			d = std::vector<S>((ll)2 * size, e());
			lz = std::vector<F>(size, id());
			for (auto i = 0LL; i < _n; i++) d[size + i] = v[i];
			for (auto i = size - 1; i >= 1; i--) update(i);
		}

		void set(ll p, S x)
		{
			assert(0 <= p && p < _n);
			p += size;
			for (ll i = log; i >= 1; i--) push(p >> i);
			d[p] = x;
			for (ll i = 1; i <= log; i++) update(p >> i);
		}

		S get(ll p)
		{
			assert(0 <= p && p < _n);
			p += size;
			for (ll i = log; i >= 1; i--) push(p >> i);
			return d[p];
		}

		S prod(ll l, ll r)
		{
			assert(0 <= l && l <= r && r <= _n);
			if (l == r) return e();
			l += size;
			r += size;
			for (ll i = log; i >= 1; i--)
			{
				if (((l >> i) << i) != l) push(l >> i);
				if (((r >> i) << i) != r) push(r >> i);
			}
			S sml = e(), smr = e();
			while (l < r)
			{
				if (l & 1) sml = op(sml, d[l++]);
				if (r & 1) smr = op(d[--r], smr);
				l >>= 1;
				r >>= 1;
			}
			return op(sml, smr);
		}

		S all_prod() { return d[1]; }

		void apply(ll p, F f)
		{
			assert(0 <= p && p < _n);
			p += size;
			for (ll i = log; i >= 1; i--) push(p >> i);
			d[p] = mapping(f, d[p]);
			for (ll i = 1; i <= log; i++) update(p >> i);
		}

		void apply(ll l, ll r, F f)
		{
			assert(0 <= l && l <= r && r <= _n);
			if (l == r) return;
			l += size;
			r += size;
			for (ll i = log; i >= 1; i--)
			{
				if (((l >> i) << i) != l) push(l >> i);
				if (((r >> i) << i) != r) push((r - 1) >> i);
			}
			{
				ll l2 = l, r2 = r;
				while (l < r)
				{
					if (l & 1) all_apply(l++, f);
					if (r & 1) all_apply(--r, f);
					l >>= 1;
					r >>= 1;
				}
				l = l2;
				r = r2;
			}
			for (ll i = 1; i <= log; i++)
			{
				if (((l >> i) << i) != l) update(l >> i);
				if (((r >> i) << i) != r) update((r - 1) >> i);
			}
		}

		template <bool (*g)(S)> ll max_right(ll l) { return max_right(l, [](S x) { return g(x); }); }

		template <class G> ll max_right(ll l, G g)
		{
			assert(0 <= l && l <= _n);
			assert(g(e()));
			if (l == _n) return _n;
			l += size;
			for (ll i = log; i >= 1; i--) push(l >> i);
			S sm = e();
			do {
				while (l % 2 == 0) l >>= 1;
				if (!g(op(sm, d[l])))
				{
					while (l < size)
					{
						push(l);
						l = (2 * l);
						if (g(op(sm, d[l]))) sm = op(sm, d[l]), l++;
					}
					return l - size;
				}
				sm = op(sm, d[l]), l++;
			} while ((l & -l) != l);
			return _n;
		}

		template <bool (*g)(S)> ll min_left(ll r) { return min_left(r, [](S x) { return g(x); }); }

		template <class G> ll min_left(ll r, G g) {
			assert(0 <= r && r <= _n);
			assert(g(e()));
			if (r == 0) return 0;
			r += size;
			for (ll i = log; i >= 1; i--) push((r - 1) >> i);
			S sm = e();
			do {
				r--;
				while (r > 1 && (r % 2)) r >>= 1;
				if (!g(op(d[r], sm)))
				{
					while (r < size)
					{
						push(r);
						r = (2 * r + 1);
						if (g(op(d[r], sm))) sm = op(d[r], sm), r--;
					}
					return r + 1 - size;
				}
				sm = op(d[r], sm);
			} while ((r & -r) != r);
			return 0;
		}
	private:
		ll _n, size, log;
		std::vector<S> d;
		std::vector<F> lz;
		void update(ll k) { d[k] = op(d[2LL * k], d[2LL * k + 1]); }
		void all_apply(ll k, F f)
		{
			d[k] = mapping(f, d[k]);
			if (k < size) lz[k] = composition(f, lz[k]);
		}
		void push(ll k)
		{
			all_apply(2 * k, lz[k]);
			all_apply(2 * k + 1, lz[k]);
			lz[k] = id();
		}
		// @param n `0 <= n`
		// @return minimum non-negative `x` s.t. `n <= 2**x`
		ll ceil_pow2(ll n)
		{
			ll x = 0;
			while ((1LLU << x) < ull(n)) x++;
			return x;
		}
	};
}

/***************************************/
/*********** END OF NYAA LIB ***********/
/***************************************/

using namespace NyaaLIB;
//using mint = NT_ModINT< 998244353 >;
//using mint = NT_ModINT< 1000000007 >;

// LST定義（範囲更新RUQ、範囲合計取得RSQ）
// 半開区間[0, N)の遅延セグメント木 (単位元{0,1})
// DS_LST_USUM lst(std::vector<DataUSUM>(N, { 0,1 }));
// apply(l, r, x); 半開区間[l,r)をxに更新
// prod(l, r).value; 半開区間[l,r)の合計を取得
using LazyUSUM = long long;
struct DataUSUM { long long value; long long size; };
const long long ID_USUM = (long long)(2e9);
DataUSUM op_usum(DataUSUM a, DataUSUM b) { return { a.value + b.value, a.size + b.size }; }
DataUSUM el_usum() { return { 0, 0 }; }
DataUSUM mapping_usum(LazyUSUM f, DataUSUM x) { if (f != ID_USUM) x.value = (long long)x.size * f; return x; }
LazyUSUM composition_usum(LazyUSUM f, LazyUSUM g) { return (f == ID_USUM ? g : f); }
LazyUSUM id_usum() { return ID_USUM; }
using DS_LST_USUM = DS_LazySegmentTree<DataUSUM, op_usum, el_usum, LazyUSUM, mapping_usum, composition_usum, id_usum>;

int main()
{
	ll N, Q; cin >> N >> Q;
	DS_LST_USUM lst(std::vector<DataUSUM>(N, { 0,1 }));

	vl ans;
	while (Q--)
	{
		ll t; cin >> t;
		if (t == 0)
		{
			ll s, t, x; cin >> s >> t >> x;
			lst.apply(s, t + 1, x);
		}
		else
		{
			ll s, t; cin >> s >> t;
			ans.push_back(lst.prod(s, t + 1).value);
		}
	}
	outlc(ans);
	return 0;
}
