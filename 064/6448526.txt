#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

#define rep(i,n) for(ll (i)=0; (i)<(ll)(n); (i)++)
#define FOR(i, b, e) for(ll (i)=(b); (i)<=(ll)(e); (i)++)
#define ALL(x) (x).begin(), (x).end()

const ll INF = 100100100100100100;

const ll TREE_SIZE = 100100;
class Unionfind {
  public:
    vector<ll> par, siz, rank;
    Unionfind();
    ll root(ll x);
    void merge(ll x, ll y);
    bool issame(ll x, ll y);
    ll size(ll x);
};
Unionfind::Unionfind() {
  par.resize(TREE_SIZE);
  siz.resize(TREE_SIZE);
  rank.resize(TREE_SIZE);
  rep(i, TREE_SIZE) {
    par[i] = i;
    siz[i] = 1;
    rank[i] = 0;
  }
}
ll Unionfind::root(ll x) {
  if(par[x] == x) return x;
  else {
    return par[x] = root(par[x]);
  }
}
void Unionfind::merge(ll x, ll y) {
  x = root(x);
  y = root(y);
  if(x == y) return;
  if(rank[x] < rank[y]) {
    par[x] = y;
    siz[y] += siz[x];
  }
  else {
    par[y] = x;
    siz[x] += siz[y];
    if(rank[x] == rank[y]) rank[x]++;
  }
}
bool Unionfind::issame(ll x, ll y) {
  return root(x) == root(y);
}
ll Unionfind::size(ll x) {
  return siz[root(x)];
}

ll V, E; // 頂点数、辺数
struct edge {ll u, v, cost;};
bool comp(edge& e1, edge& e2) {
  return e1.cost < e2.cost;
}
vector<edge> es(0), tree(0);
ll kruskal() {
  sort(ALL(es), comp);
  Unionfind uf;
  ll res = 0;
  rep(i, E) {
    edge e = es[i];
    if(!uf.issame(e.u, e.v)) {
      tree.push_back(e);
      uf.merge(e.u, e.v);
      res += e.cost;
    }
  }
  return res;
}

int main() {
  cin >> V >> E;
  rep(i, E) {
    ll s, t, w;
    cin >> s >> t >> w;
    es.push_back({s, t, w});
  }
  cout << kruskal() << endl;
  return 0;
}

