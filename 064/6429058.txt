#include<iostream>
#include<iomanip>
#include<cmath>
#include<vector>
using namespace std;
#define EPS (1e-10)
#define equal(a,b) (fabs(a-b)<EPS)

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE = -1;
static const int ON_SEGMENT = 0;
static const int ONLINE_FRONT = 2;
static const int ONLINE_BACK = -2;
class Point {
public:
	double x, y;
	/*构造函数*/
	Point() {}
	Point(double x, double y) :x(x), y(y) {}
	/*针对加法的重载*/
	Point operator + (Point& p) { return Point(x + p.x, y + p.y); }
	Point operator - (Point& p) { return Point(x - p.x, y - p.y); }
	Point operator * (double a) { return Point(a * x, a * y); }
	Point operator / (double a) { return Point(x / a, y / a); }

	/*返回向量的模*/
	double abs() { return(sqrt(x * x + y * y)); }
};

/*写成大写防止和vector冲突*/
typedef Point Vector;

/*这里用Line表示线段*/
class Line {
public:
	Point p1, p2;
	Line() {}
	Line(Point p1, Point p2) :p1(p1), p2(p2) {}
	/*获取直线的方向向量*/
	Vector GetVector() { return Point(p2.x - p1.x, p2.y - p1.y); }
};

/*用来表示多边形的动态数组*/
vector<Point> Po;

/*计算两个向量的内积*/
double dot(Vector v1, Vector v2)
{
	return v1.x * v2.x + v1.y * v2.y;
}

/*计算两个向量的外积 v1积v2*/
double cross(Vector v1, Vector v2)
{
	return v1.x * v2.y - v1.y * v2.x;
}


/*判断要断定的点是否内包*/
int contain(vector<Point> Po, Point p)
{
	/*用来统计点p向x轴正方向引出的射线与多边形边的交点*/
	int count = 0;
	for (int i = 0; i < Po.size(); i++)
	{
		Vector a = Po[i] - p;
		Vector b = Po[(i + 1) % Po.size()] - p;
		/*选取y值小的做向量积第一项，这样都在点p右侧时向量积为正*/
		if (b.y < a.y)
		{
			b = Po[i] - p;
			a = Po[(i + 1) % Po.size()] - p;;
		}
		/*先判断向量积是否为0*/
		if (cross(a, b) == 0)
		{
			/*说明点P在边上*/
			if (dot(a, b) <= 0)
				return 1;
			/*但注意反面并不说明这个点一定在多边形外*/
		}
		/*接下来用x是否均大于0判断是否两个点均位于右侧*/
		else if (a.x>=0&&b.x>0||a.x > 0 && b.x >= 0)
		{
			if (a.y <= 0 && b.y >= 0)
			{
				if(Po[i].y!=Po[(i-1+Po.size())%Po.size()].y&&Po[i].x!=Po[(i-1+Po.size())%Po.size()].x) 
					count++;
			}
			
		}
	}
	if (count % 2 == 1)
		return 2;
	else
		return 0;
}

int main()
{
	int n = 0;
	Point temp;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> temp.x >> temp.y;
		Po.push_back(temp);
	}
	int q = 0; cin >> q;
	for (int i = 0; i < q; i++)
	{
		cin >> temp.x >> temp.y;
		cout << contain(Po, temp) << endl;
	}
	return 0;
}
