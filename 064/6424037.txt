#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

template < class T >
pair< vector<vector<int>>, int > cartesian_tree(vector< T > &a) {
    int n = a.size();
    vector<vector<int>> graph(n);
    vector<int> p(n, -1), st;
    st.reserve(n);
    for(int i = 0; i < n; i++) {
        int prev = -1;
        while(!st.empty() && a[i] < a[st.back()]) {
            prev = st.back();
            st.pop_back();
        }
        if(prev != -1) p[prev] = i;
        if(!st.empty()) p[i] = st.back();
        st.push_back(i);
    }

    int root = -1;
    for(int i = 0; i < n; i++) {
        if(p[i] == -1) root = i;
        else graph[p[i]].push_back(i);
    }
    return {graph, root};
}

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    int n; cin >> n;
    vector<int> h(n);
    rep(i,n) cin >> h[i], h[i]--;
    vector<int> g = h;
    rep(i,n) g[i] = (n - 1) - g[i];
    auto [tree, root] = cartesian_tree(g);

    vector<int> memo_height(n, -1), memo_diameter(n, -1);
    function<int(int)> height = [&](int v) -> int {
        if(memo_height[v] != -1) return memo_height[v];
        int res = 0;
        for(int to : tree[v]) {
            res = max(res, height(to) + 1);
        }
        return memo_height[v] = res;
    };

    function<int(int)> diameter = [&](int v) -> int {
        if(memo_diameter[v] != -1) return memo_diameter[v];
        if(tree[v].size() == 0) return 0;
        int res = 0;
        int M = 1;
        for(int to : tree[v]) {
            res = max(res, diameter(to));
            M += height(to);
        }
        res = max(res, M);
        return memo_diameter[v] = res + 1;
    };

    cout << diameter(root) << endl;
}
