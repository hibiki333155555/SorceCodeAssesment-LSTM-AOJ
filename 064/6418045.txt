#![allow(unused_imports)]
use std::cmp::*;
use std::collections::*;
use std::io::Write;
use std::ops::Bound::*;

#[allow(unused_macros)]
macro_rules! debug {
    ($($e:expr),*) => {
        #[cfg(debug_assertions)]
        $({
            let (e, mut err) = (stringify!($e), std::io::stderr());
            writeln!(err, "{} = {:?}", e, $e).unwrap()
        })*
    };
}

fn main() {
    let v = read_vec::<usize>();
    let (w, h, n) = (v[0], v[1], v[2]);
    let v = read_vec::<usize>();
    let (sx, sy, gx, gy) = (v[0] - 1, v[1] - 1, v[2] - 1, v[3] - 1);

    let mut guards = vec![];
    for i in 0..n {
        let v = read_vec::<usize>();
        let (x, y, k) = (v[0] - 1, v[1] - 1, v[2]);
        guards.push((x, y, k));
    }

    let mut tiles = vec![vec![0i64; 2 * w + 2]; 2 * h + 2];

    for (x, y, k) in guards {
        if k == 0 {
            inc(x, y, w, h, &mut tiles);
            dec(x + 1, y + 1, w, h, &mut tiles);
            dec(x - 1, y + 1, w, h, &mut tiles);
            inc(x, y + 2, w, h, &mut tiles);
            continue;
        }
        inc(x, y - k, w, h, &mut tiles);
        dec(x + k + 1, y + 1, w, h, &mut tiles);
        dec2(x as i64 - k as i64 - 1, y as i64 + 1, w, h, &mut tiles);
        inc(x, y + k + 2, w, h, &mut tiles);

        inc(x, y - k + 1, w, h, &mut tiles);
        dec(x + k, y + 1, w, h, &mut tiles);
        dec(x - k, y + 1, w, h, &mut tiles);
        inc(x, y + k + 1, w, h, &mut tiles);
    }
    debug!(tiles);

    for y in 1..tiles.len() {
        for x in 1..tiles[0].len() {
            tiles[y][x] += tiles[y - 1][x - 1];
        }
    }

    for y in 1..tiles.len() {
        for x in (0..tiles[0].len() - 1).rev() {
            tiles[y][x] += tiles[y - 1][x + 1];
        }
    }

    debug!(tiles);

    let get_idx = |x, y| x + y * w;
    let mut uft = UnionFindTree::new(h * w);
    for y in 0..h {
        for x in 0..w {
            if tiles[y + h][x + w] > 0 {
                continue;
            }
            let cur = get_idx(x, y);
            for (adj_x, adj_y) in get_adjacents(x, y, w, h) {
                if tiles[adj_y + h][adj_x + w] > 0 {
                    continue;
                }
                let adj = get_idx(adj_x, adj_y);
                uft.unite(cur, adj);
            }
        }
    }

    if uft.same(get_idx(sx, sy), get_idx(gx, gy)) {
        println!("Yes");
    } else {
        println!("No");
    }
}

fn inc(x: usize, y: usize, w: usize, h: usize, tiles: &mut Vec<Vec<i64>>) {
    tiles[y + h][x + w] += 1;
}
fn dec(x: usize, y: usize, w: usize, h: usize, tiles: &mut Vec<Vec<i64>>) {
    tiles[y + h][x + w] -= 1;
}

fn dec2(x: i64, y: i64, w: usize, h: usize, tiles: &mut Vec<Vec<i64>>) {
    tiles[(y + h as i64) as usize][(x + w as i64) as usize] -= 1;
}

fn read<T: std::str::FromStr>() -> T {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    s.trim().parse().ok().unwrap()
}

fn read_vec<T: std::str::FromStr>() -> Vec<T> {
    read::<String>()
        .split_whitespace()
        .map(|e| e.parse().ok().unwrap())
        .collect()
}

fn get_adjacents(x: usize, y: usize, w: usize, h: usize) -> Vec<(usize, usize)> {
    let mut adjacents = vec![];
    if x > 0 {
        adjacents.push((x - 1, y));
    }
    if y > 0 {
        adjacents.push((x, y - 1));
    }
    if y < h - 1 {
        adjacents.push((x, y + 1));
    }
    if x < w - 1 {
        adjacents.push((x + 1, y));
    }
    adjacents
}

#[derive(Debug, Clone)]
struct UnionFindTree {
    parent: Vec<isize>,
    size: Vec<usize>,
    height: Vec<u64>,
}

impl UnionFindTree {
    fn new(n: usize) -> UnionFindTree {
        UnionFindTree {
            parent: vec![-1; n],
            size: vec![1usize; n],
            height: vec![0u64; n],
        }
    }

    fn find(&mut self, index: usize) -> usize {
        if self.parent[index] == -1 {
            return index;
        }
        let idx = self.parent[index] as usize;
        let ret = self.find(idx);
        self.parent[index] = ret as isize;
        ret
    }

    fn same(&mut self, x: usize, y: usize) -> bool {
        self.find(x) == self.find(y)
    }

    fn get_size(&mut self, x: usize) -> usize {
        let idx = self.find(x);
        self.size[idx]
    }

    fn unite(&mut self, index0: usize, index1: usize) -> bool {
        let a = self.find(index0);
        let b = self.find(index1);
        if a == b {
            false
        } else {
            if self.height[a] > self.height[b] {
                self.parent[b] = a as isize;
                self.size[a] += self.size[b];
            } else if self.height[a] < self.height[b] {
                self.parent[a] = b as isize;
                self.size[b] += self.size[a];
            } else {
                self.parent[b] = a as isize;
                self.size[a] += self.size[b];
                self.height[a] += 1;
            }
            true
        }
    }
}

