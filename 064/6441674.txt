#line 1 "main.cpp"
#define PROBLEM "https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_C"

#line 2 "lib/prelude.hpp"
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#endif
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep2(i, m, n) for (auto i = (m); i < (n); i++)
#define rep(i, n) rep2(i, 0, n)
#define repr2(i, m, n) for (auto i = (n); i-- > (m);)
#define repr(i, n) repr2(i, 0, n)
#define all(x) begin(x), end(x)
#line 3 "lib/graph.hpp"

struct unit_edge {
  int v;
  int to() const { return v; }
  operator int() const { return to(); }
  int w() const { return 1; }
};

template <class Weight>
struct weighted_edge {
  int v;
  Weight weight;
  int to() const { return v; }
  operator int() const { return to(); }
  Weight w() const { return weight; }
};

template <class Inner>
struct basic_graph {
  using weight_type = int;
  constexpr static bool weighted = false;
  const Inner& inner;
  basic_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto u : inner[v]) f(unit_edge{u});
  }
};

template <class Inner, class Weight>
struct basic_weighted_graph {
  using weight_type = Weight;
  constexpr static bool weighted = true;
  const Inner& inner;
  basic_weighted_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto [u, w] : inner[v]) f(weighted_edge<weight_type>{u, w});
  }
};

template <class T>
struct graph_trait : public T {
  graph_trait(T t) : T(move(t)) {}
};

template <class T>
using W = typename graph_trait<T>::weight_type;

template <size_t N>
struct graph_trait<vector<int>[N]> : basic_graph<vector<int>[N]> {
  using basic_graph<vector<int>[N]>::basic_graph;
  int size() const { return N; }
};

template <>
struct graph_trait<vector<vector<int>>> : basic_graph<vector<vector<int>>> {
  using basic_graph<vector<vector<int>>>::basic_graph;
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};

template <size_t N, class Weight>
struct graph_trait<vector<pair<int, Weight>>[N]>
    : basic_weighted_graph<vector<pair<int, Weight>>[N], Weight> {
  using basic_weighted_graph<vector<pair<int, Weight>>[N],
                             Weight>::basic_weighted_graph;
  int size() const { return N; }
};

template <class Weight>
struct graph_trait<vector<vector<pair<int, Weight>>>>
    : basic_weighted_graph<vector<vector<pair<int, Weight>>>, Weight> {
  using basic_weighted_graph<vector<vector<pair<int, Weight>>>,
                             Weight>::basic_weighted_graph;
  int size() const { return basic_graph<vector<vector<int>>>::inner.size(); }
};
#line 3 "lib/graph/bellman_ford.hpp"

// (fail, dist)
template <class G>
pair<bool, vector<W<G>>> bellman_ford(G& graph, int s) {
  const W<G> inf = numeric_limits<W<G>>::max();
  graph_trait<G> g(graph);
  vector<W<G>> dist(g.size(), inf);
  dist[s] = 0;
  bool success = false;
  rep(t, g.size()) {
    bool updated = false;
    rep(v, g.size()) if (dist[v] != inf) g.adj(v, [&](auto&& e) {
      if (dist[e.to()] > dist[v] + e.w())
        updated = true,
        dist[e.to()] = dist[v] + e.w();
    });
    if (!updated) {
      success = true;
      break;
    }
  }
  for (auto& d : dist) if (d >= inf / 2) d = numeric_limits<W<G>>::max();
  return {!success, move(dist)};
}
#line 3 "lib/graph/ford_fulkerson.hpp"

template <class G>
vector<vector<W<G>>> ford_fulkerson(const G& graph) {
  const W<G> inf = numeric_limits<W<G>>::max();
  graph_trait<G> g(graph);
  vector<vector<W<G>>> res(g.size(), vector<W<G>>(g.size(), inf / 2));
  rep(v, g.size()) {
    res[v][v] = W<G>(0);
    g.adj(v, [&](auto&& e) { res[v][e.to()] = e.w(); });
  }
  rep(k, g.size()) rep(u, g.size()) rep(v, g.size())
    res[u][v] = min(res[u][v], res[u][k] + res[k][v]);
  rep(u, g.size()) rep(v, g.size())
    res[u][v] = res[u][v] == inf / 2 ? inf : res[u][v];
  return res;
}
#line 6 "main.cpp"

int n, m;
vector<pair<int, int>> G[100];

int main() {
  scanf("%d%d", &n, &m);
  rep(_, m) {
    int u, v; int w; scanf("%d%d%d", &u, &v, &w);
    G[u].emplace_back(v, w);
  }
  if (bellman_ford(G, 0).first) return printf("NEGATIVE CYCLE\n"), 0;
  auto d = ford_fulkerson(G);
  rep(v, n) rep(i, n) printf("%s%c", d[v][i] == INT_MAX ? "INF" : to_string(d[v][i]).c_str(), " \n"[i==n-1]);
}

