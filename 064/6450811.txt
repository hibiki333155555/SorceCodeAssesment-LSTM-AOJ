import sys
import bisect
sys.setrecursionlimit(10**6)
class RangeMinQuery():
    def __init__(self,n,o=float('inf')):
        self.o=o
        t=1
        while t<n:
            t*=2
        self.n=t
        self.arr=[o for i in range(2*t-1)]
    def update(self):
        for x in reversed(range(self.n-1)):
            self.arr[x]=min(self.arr[2*x+1],self.arr[2*x+2])
    def query(self,a,b,k=0,l=0,r=None):
        if r is None:
            r=self.n
        if r<=a or b<=l:
            return self.o
        if a<=l<=r<=b:
            return self.arr[k]
        return min(self.query(a,b,2*k+1,l,(l+r)//2),self.query(a,b,2*k+2,(l+r)//2,r))
    def __getitem__(self,x):
        return self.arr[self.n-1+x]
    def __setitem__(self,x,z):
        self.arr[self.n-1+x]=z
class LowestCommonAncestor:
    def __init__(self,n):
        self.n=n
        self.g=[[] for i in range(n)]
    def merge(self,u,v,t=0):
        self.g[u-t].append(v-t)
        self.g[v-t].append(u-t)
    def update(self):
        t=[]
        self.f=[None for i in range(self.n)]
        def dfs(u,per=-1,d=0):
            if self.f[u] is None:
                self.f[u]=len(t)
            t.append((d,u))
            for v in self.g[u]:
                if v==per:
                    continue
                dfs(v,u,d+1)
                t.append((d,u))
        dfs(0)
        self.rmq=RangeMinQuery(len(t),(float('inf'),0))
        for i in range(len(t)):
            self.rmq[i]=t[i]
        self.rmq.update()
    def query(self,a,b):
        x,y=self.f[a],self.f[b]
        if x>y:
            x,y=y,x
        d,v=self.rmq.query(x,y+1)
        return v
N=int(input())
g=[[] for i in range(N)]
h=[[] for i in range(N)]
deep=[None for i in range(N)]
lcm=LowestCommonAncestor(N)
for i in range(N-1):
    a,b=map(int,input().split())
    a,b=a-1,b-1
    g[a].append(b)
    g[b].append(a)
    lcm.merge(a,b)
for i in range(N):
    g[i].sort()
lcm.update()
gd=[{} for i in range(N)]
per=[None for i in range(N)]
eu=[[None,None] for i in range(N)]
eu1={}
temp=0
def dfs(u,p,d=0):
    global temp
    eu[u][0]=temp
    deep[u]=d
    temp+=1
    per[u]=p
    k=0
    for v in g[u]:
        if v==p:
            continue
        k+=dfs(v,u,d+1)
        h[u].append(eu[v])
    eu[u][1]=temp
    temp+=1
    eu[u]=tuple(eu[u])
    eu1[eu[u]]=u
    k*=2
    k+=1
    if p<0:
        return
    gd[p][u]=k
    return k
dfs(0,-1)
s={0}
while s:
    t=set()
    for u in s:
        k=0
        for v in g[u]:
            if v==per[u]:
                continue
            k+=gd[u][v]
        if per[u]>=0:
            k+=gd[u][per[u]]
        for v in g[u]:
            if v==per[u]:
                continue
            gd[v][u]=(k-gd[u][v])*2+1
            t.add(v)
    s=t
Q=int(input())
for i in range(Q):
    x,y=map(int,input().split())
    x,y=x-1,y-1
    ans=pow(2,deep[x]+deep[y]-2*deep[lcm.query(x,y)],998244353)
    if eu[y][0]<=eu[x][0]<=eu[x][1]<=eu[y][1]:
        x,y=y,x
    if eu[x][0]<=eu[y][0]<=eu[y][1]<=eu[x][1]:
        ans*=gd[per[y]][y]
        ans*=gd[eu1[h[x][bisect.bisect_right(h[x],eu[y])-1]]][x]
    else:
        ans*=gd[per[y]][y]
        ans*=gd[per[x]][x]
    ans%=998244353
    print(ans)
