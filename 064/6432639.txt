#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <numeric>
#include <algorithm>
#include <queue>
#include <string>
#include <random>
#include <array>
#include <climits>
#include <map>
#include <cassert>
#include <stack>
#include <iomanip>
#include <cfloat>
#include <bitset>
#include <fstream>
#include <chrono>

int main() {
	int n; std::cin >> n;
	std::vector<std::tuple<int, int, char>> edges(n - 1);
	for (auto& [u, v, c] : edges) {
		std::cin >> u >> v >> c; --u; --v;
	}
	std::vector<std::vector<std::pair<int, int>>> graph(n);
	for (const auto [u, v, c] : edges) {
		graph[u].emplace_back(v, c - 'a');
		graph[v].emplace_back(u, c - 'a');
	}
	std::vector<int> depth(n, -1); depth[0] = 0;
	std::vector<int> history{ 0 };
	for (auto i = 0; i < history.size(); ++i) {
		const auto current = history[i];
		for (const auto [next, _] : graph[current]) {
			if (depth[next] >= 0) continue;
			depth[next] = depth[current] + 1;
			history.push_back(next);
		}
	}
	std::reverse(history.begin(), history.end());
	std::vector<std::unordered_map<int, int>> subtree(n);
	std::vector<int> base_filter(n);
	for (const auto current : history) {
		std::unordered_map<int, int> dest; dest.emplace(0, 1);
		int dest_filter{ 0 };
		for (const auto [child, c] : graph[current]) {
			if (depth[child] < depth[current]) continue;
			auto& source = subtree[child];
			auto source_filter = base_filter[child] ^ (1 << c);
			if (dest.size() < source.size()) {
				std::swap(dest, source);
				std::swap(dest_filter, source_filter);
			}
			for (const auto& [pattern, count] : source) {
				dest[pattern ^ source_filter ^ dest_filter] += count;
			}
		}
		subtree[current] = std::move(dest);
		base_filter[current] = dest_filter;
	}
	const auto root = std::move(subtree[0]);
	long long int result{ 0 };
	for (const auto& [pattern, count] : root) {
		result += (long long int)count * (count - 1) / 2;
		for (auto c = 0; c < 26; ++c) {
			if ((pattern >> c) & 1) continue;
			const auto other = root.find(pattern | (1 << c));
			if (other == root.end()) continue;
			result += (long long int)count * other->second;
		}
	}
	std::cout << result << '\n';
}
