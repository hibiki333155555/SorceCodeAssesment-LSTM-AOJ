#include<iostream>
#include<iomanip>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
#define EPS (1e-10)
#define equal(a,b) (fabs(a-b)<EPS)

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE = -1;

class Point {
public:
	double x, y;
	/*构造函数*/
	Point() {}
	Point(double x, double y) :x(x), y(y) {}
	/*针对加法的重载*/
	Point operator + (Point& p) { return Point(x + p.x, y + p.y); }
	Point operator - (Point& p) { return Point(x - p.x, y - p.y); }
	Point operator * (double a) { return Point(a * x, a * y); }
	Point operator / (double a) { return Point(x / a, y / a); }

	/*返回向量的模*/
	double abs() { return(sqrt(x * x + y * y)); }
};

/*写成大写防止和vector冲突*/
typedef Point Vector;

/*这里用Line表示线段*/
class Line {
public:
	Point p1, p2;
	Line() {}
	Line(Point p1, Point p2) :p1(p1), p2(p2) {}
	/*获取直线的方向向量*/
	Vector GetVector() { return Point(p2.x - p1.x, p2.y - p1.y); }
};

/*用来表示数个点的动态数组*/
vector<Point> Po;

/*用来保存凸包上半部分的动态数组*/
vector<Point> ConUp;

/*用来保存凸包下半部分的动态数组*/
vector<Point> ConDown;

/*计算两个向量的内积*/
double dot(Vector v1, Vector v2)
{
	return v1.x * v2.x + v1.y * v2.y;
}

/*计算两个向量的外积 v1积v2*/
double cross(Vector v1, Vector v2)
{
	return v1.x * v2.y - v1.y * v2.x;
}

bool xiaoyu(Point p1, Point p2)
{
	if (p1.x < p2.x)
		return true;
	else if (p1.x == p2.x)
	{
		if (p1.y <= p2.y)
			return true;
	}
	else
		return false;
}

/*判断目标点位于线段顺时针位置还是逆时针位置*/
int ccw(Point p1,Point p2,Point p)
{
	Vector b = p - p1;
	Vector a = p2 - p1;
	if (cross(a, b) > 0)
		return COUNTER_CLOCKWISE;
	else
		return CLOCKWISE;
}

/*构造凸包的函数,Po数组已经排好序*/
void Hull(vector<Point> Po)
{
	ConUp.push_back(Po[0]);
	ConUp.push_back(Po[1]);
	ConDown.push_back(Po[Po.size() - 1]);
	ConDown.push_back(Po[Po.size() - 2]);

	for (int i = 2; i < Po.size(); i++)
	{
		for (int n = ConUp.size(); n >= 2 && ccw(ConUp[n - 2], ConUp[n - 1], Po[i]) == COUNTER_CLOCKWISE; n--)
			ConUp.pop_back();
		ConUp.push_back(Po[i]);
	}

	for (int i = Po.size() - 3; i >= 0; i--)
	{
		for (int n = ConDown.size(); n >= 2 && ccw(ConDown[n - 2], ConDown[n - 1], Po[i]) == COUNTER_CLOCKWISE; n--)
			ConDown.pop_back();
		ConDown.push_back(Po[i]);
	}
}

int main()
{
	int n = 0;
	cin >> n;
	Point temp;
	for (int i = 0; i < n; i++)
	{
		cin >> temp.x >> temp.y;
		Po.push_back(temp);
	}
	sort(Po.begin(), Po.end(), xiaoyu);
	Hull(Po);
	reverse(ConDown.begin(), ConDown.end());
	/*至此生成完整的突包*/
	for (int i = ConUp.size() - 2; i >= 1; i--)
		ConDown.push_back(ConUp[i]);
	int minpos=0;
	for (int i = 1; i < ConDown.size(); i++)
	{
		if (ConDown[i].y < ConDown[minpos].y)
			minpos = i;
		else if (ConDown[i].y == ConDown[minpos].y)
			if (ConDown[i].x < ConDown[minpos].x)
				minpos = i;
	}
	int nsize=ConDown.size();
	cout << n << endl;
	for (int i = 0; i < n; i++)
		cout << ConDown[(i + minpos) % n].x <<" "<< ConDown[(i + minpos) % n].y << endl;
	return 0;
}
