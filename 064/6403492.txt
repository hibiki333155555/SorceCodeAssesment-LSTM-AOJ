use std::io::*;
use std::str::FromStr;
use std::iter::*;

struct Dice {
    tp: i32, ft: i32, rt: i32, lt: i32, bk: i32, bm: i32,
}
impl Dice {
    fn new(s: Vec<i32>) -> Dice {
        Dice{ tp: s[0], ft: s[1], rt: s[2], lt: s[3], bk: s[4], bm: s[5] }
    }
    fn roll(&mut self, ch: char) {
        match ch {
            'N' => { let tmp = self.tp; self.tp = self.ft; self.ft = self.bm; self.bm = self.bk; self.bk = tmp; },
            'S' => { let tmp = self.tp; self.tp = self.bk; self.bk = self.bm; self.bm = self.ft; self.ft = tmp; },
            'E' => { let tmp = self.tp; self.tp = self.lt; self.lt = self.bm; self.bm = self.rt; self.rt = tmp; },
            'W' => { let tmp = self.tp; self.tp = self.rt; self.rt = self.bm; self.bm = self.lt; self.lt = tmp; },
            _ => {},
        }
    }
}
fn main() {
    //let cin = stdin();
    //let cin = cin.lock();
    //let mut sc = Scanner::new(cin);
    //let n = sc.read();
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    let vca: Vec<i32> = s.split_whitespace().map(|e| e.parse().unwrap()).collect();
    let mut ds = Dice::new(vca);
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    let vcb: Vec<i32> = s.split_whitespace().map(|e| e.parse().unwrap()).collect();

    if vcb[1] == ds.lt || vcb[1] == ds.rt { ds.roll('W'); }
    for _ in 0..3{
        if vcb[1] == ds.ft { break;}
        ds.roll('S');  
    }
    for _ in 0..3{
        if vcb[0] == ds.tp {break;}
        ds.roll('W');  
    } 
    if  vcb[0] == ds.tp && vcb[1] == ds.ft && 
        vcb[2] == ds.rt && vcb[3] == ds.lt{
         println!("Yes")
    }
    else{
        println!("{}", "No")
    }
    // for cmd in cmds.chars() {}
}

struct Scanner<R: Read> {
    reader: R,
}
#[allow(dead_code)]
impl<R: Read> Scanner<R> {
    fn new(reader: R) -> Scanner<R> {
        Scanner { reader: reader }
    }
    fn safe_read<T: FromStr>(&mut self) -> Option<T> {
        let token = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)
            .skip_while(|c| c.is_whitespace())
            .take_while(|c| !c.is_whitespace())
            .collect::<String>();
        if token.is_empty() {
            None
        } else {
            token.parse::<T>().ok()
        }
    }

    fn read<T: FromStr>(&mut self) -> T {
        if let Some(s) = self.safe_read() {
            s
        } else {
            writeln!(stderr(), "Terminated with EOF").unwrap();
            std::process::exit(0);
        }
    }
}

