import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
// const long mod = 1_000_000_000 + 7;
const long mod = 998_244_353L;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

int N;
long[] bs;
long[][] dp;

long rec (int l, int r) {
  if (dp[l][r] != -INF)
    return dp[l][r];
  if (r == l + 1) {
    dp[l][r] = bs[l];
    return dp[l][r];
  }
  if (r < l + 1) {
    dp[l][r] = 0L;
    return dp[l][r];
  }

  chmax(dp[l][r], bs[l] - rec(l + 1, r));
  chmax(dp[l][r], bs[r - 1] - rec(l, r - 1));
  return dp[l][r];
}

void main () {
  N = readln.chomp.to!int;
  auto as = new long[](N);
  foreach (i; 0 .. N)
    as[i] = readln.chomp.to!long;
  bs = new long[](N - 1);

  long ttl = as.fold!((a, b) => a + b);
  long ret = 0L;
  foreach (i; 0 .. N) {
    foreach (j; 0 .. N - 1) {
      bs[j] = as[(i + 1 + j) % N];
    }
    dp = new long[][](N, N);
    foreach (m; 0 .. N)
      foreach (n; 0 .. N)
        dp[m][n] = -INF;

    long tot = (-rec(0, N - 1) + (ttl - as[i])) / 2L;
    chmax(ret, tot + as[i]);
  }

  writeln(ret);
}

