// I SELL YOU...! 
#include<iostream>
#include<vector>
#include<algorithm>
#include<functional>
#include<queue>
#include<chrono>
#include<iomanip>
#include<map>
#include<set>
#include<numeric>
using namespace std;
using ll = long long;
using P = pair<ll,ll>;
using TP = tuple<ll,ll,ll>;
void init_io(){
  cin.tie(0);
  ios::sync_with_stdio(false);
  cout << fixed << setprecision(18);
}
pair<map<ll,ll>, vector<ll>> make_idx() {
  ll n=20;
  set<ll> st;
  for(ll i=0;i<(1ll << n);i++) {
    ll p = 1;
    for(ll j=0;j<n;j++) {
      if (i&(1ll<<j)) {
        p = lcm(p, j+1);
      }
    }
    st.insert(p);
  }
  ll idx = 0;
  map<ll,ll> res;
  vector<ll> bc;
  for(auto v: st) {
    res[v] = idx;
    bc.push_back(v);
    idx++;
  }
  return make_pair(res, bc);
}
signed main(){
  init_io();
  ll n,m;
  cin >> n >> m;
  vector<ll> a(m),b(m),c(m);
  auto [idx, bc] = make_idx();
  vector<vector<bool>> d(n, vector<bool>(idx.size()));
  vector<vector<P>> G(n, vector<P>());
  for(int i=0;i<m;i++) {
    cin >> a[i] >> b[i] >> c[i];
    a[i]--;
    b[i]--;
    G[a[i]].push_back(P(b[i], c[i]));
  }
  queue<P> que;
  que.push(P(0, idx[1]));
  d[0][idx[1]] = true;
  while(!que.empty()) {
    auto [v, i] = que.front(); que.pop();
    ll val = bc[i];
    for(auto [nv, mul]:G[v]) {
      ll next_val = lcm(mul, val);
      ll next_idx = idx[next_val];
      if (!d[nv][next_idx]) {
        d[nv][next_idx] = true;
        que.push(P(nv, next_idx));
      }
    }
  }
  const ll INF= 1e18;
  ll min_v = INF, max_v = -INF;
  for(int i=0;i<(int)idx.size();i++) {
    if (d[n-1][i]) {
      min_v = min(min_v, bc[i]);
      max_v = max(max_v, bc[i]);
    }
  }
  if (min_v == INF) {
    cout <<"IMPOSSIBLE"<<endl;
  } else {
    cout << min_v <<" "<<max_v << endl;
  }
}

