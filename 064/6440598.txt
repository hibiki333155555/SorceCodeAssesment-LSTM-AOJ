#include <bits/stdc++.h>
//#include <boost/multiprecision/cpp_int.hpp>
//#include <atcoder/all>
using namespace std;
#define rep(i, a) for (int i = (int)0; i < (int)a; ++i)
#define repl(i, a) for (long long i = (long long)0; i < (long long)a; ++i)
#define rrep(i, a) for (int i = (int)a; i > -1; --i)
#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)
#define REPL(i, a, b) for (long long i = (long long)a; i < (long long)b; ++i)
#define RREP(i, a, b) for (int i = (int)a; i > b; --i)
#define pb push_back
#define eb emplace_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define popcount __builtin_popcount
#define popcountll __builtin_popcountll
#define fi first
#define se second
using ll = long long;
constexpr ll mod = 1e9 + 7;
constexpr ll mod_998244353 = 998244353;
constexpr ll INF = 1LL << 60;

//#pragma GCC target("avx2")
//#pragma GCC optimize("O3")
//#pragma GCC optimize("unroll-loops")

//using lll = boost::multiprecision::cpp_int;
template <class T>
inline bool chmin(T &a, T b) {
  if (a > b) {
    a = b;
    return true;
  }
  return false;
}
template <class T>
inline bool chmax(T &a, T b) {
  if (a < b) {
    a = b;
    return true;
  }
  return false;
}

ll mypow(ll x, ll n, const ll &p = -1) {  // x^nをmodで割った余り

  if (p != -1) {
    x = (x % p + p) % p;
  }
  ll ret = 1;
  while (n > 0) {
    if (n & 1) {
      if (p != -1)
        ret = (ret * x) % p;
      else
        ret *= x;
    }
    if (p != -1)
      x = (x * x) % p;
    else
      x *= x;
    n >>= 1;
  }
  return ret;
}

template <typename T>
struct myrand {
  random_device seed;
  mt19937 mt;
  myrand() : mt(seed()) {}
  T operator()(T a, T b) {  //[a,b)
    uniform_int_distribution<T> dist(a, b - 1);
    return dist(mt);
  }
};

//using namespace atcoder;

//------------------------
//-----------------------
//------------------------
//------------------------
//------------------------

using P=pair<double,double>;
void solve(){
  int n;
  cin>>n;
  vector<P>p(n);
  rep(i,n)cin>>p[i].fi>>p[i].se;
  sort(all(p));
  
  auto get_dist=[](const P &l,const P &r)->double{
    return sqrt((l.fi-r.fi)*(l.fi-r.fi)+(l.se-r.se)*(l.se-r.se));
  };  
  auto rec=[&get_dist](auto self,int l,int r,vector<P> &p)->double{
    if(r-l<=1)return 1e9;
    int m=(l+r)/2;
    double d=min(self(self,l,m,p),self(self,m,r,p));
    auto compare_y=[](const P &l,const P &r)->bool{
      return l.se<r.se;
    };
    inplace_merge(p.begin()+l,p.begin()+m,p.begin()+r,compare_y);
    REP(i,l,r-1){
      chmin(d,get_dist(p[i],p[i+1]));
    }

    vector<P>b;
    REP(i,l,r){
      if(abs(p[m].fi-p[i].fi)>=d)continue;

      rep(j,b.size()){
        double dx=p[i].fi-p[b.size()-1-j].fi;
        double dy=p[i].se-p[b.size()-1-j].fi;
        if(dy>=d)break;
        chmin(d,get_dist(p[i],p[b.size()-1-j]));
      }
      b.eb(p[i]);
    }
    return d;
  };
  double ans=rec(rec,0,n,p);
  cout<<ans<<"\n";
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << fixed << setprecision(15);
  solve();
  return 0;
}
