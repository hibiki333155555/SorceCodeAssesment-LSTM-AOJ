#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 1000000005

typedef struct {
    int price;
    int weigth;
    char type;
    long Time;
    char name[21];
} Node;

int isSame (Node * L, int com_i, Node * R, int com_j){
    if (L[com_i].price == R[com_j].price && L[com_i].weigth == R[com_j].weigth && L[com_i].type == R[com_j].type && L[com_i].Time == R[com_j].Time){
        if (strlen(L[com_i].name) == strlen(R[com_j].name) && strcmp(L[com_i].name, R[com_j].name) == 0){
            return 1;
        }
    }
    return 0;
}

int LeftIsSmaller(Node * L, int com_i, Node * R, int com_j){
    if (isSame(L, com_i, R, com_j) == 1){
        return 1;
    } else {
        if (L[com_i].price < R[com_j].price){
            //printf("p:%d\n", L[com_i].price);
            return 1;
        } else if (L[com_i].price > R[com_j].price){
            return 0;
        }
        
        if (L[com_i].weigth < R[com_j].weigth){
            //printf("w:%d\n", L[com_i].weigth);
            return 1;
        } else if (L[com_i].weigth > R[com_j].weigth){
            return 0;
        }
        
        if ((int)(L[com_i].type) < (int)(R[com_j].type)){
            //printf("t:%c %c\n", L[com_i].type, R[com_j].type);
            return 1;
        } else if ((int)(L[com_i].type) > (int)(R[com_j].type)){
            return 0;
        }
        
        if (L[com_i].Time < R[com_j].Time){
            return 1;
        } else if (L[com_i].Time > R[com_j].Time){
            return 0;
        }
        
        int j = 0;
        while(1){
            if (L[com_i].name[j] == '\0' || R[com_j].name[j] == '\0'){
                if (R[com_j].name[j] != '\0'){
                    return 1;
                } else {
                    return 0;
                }
            }
            
            if (L[com_i].name[j] == R[com_j].name[j]){
                j++;
                continue;
            } else if ((int)(L[com_i].name[j]) < (int)(R[com_j].name[j])){
                return 1;
            } else if ((int)(L[com_i].name[j]) > (int)(R[com_j].name[j])){
                return 0;
            }
        }
        
    }
    return 0;
}

void Marge(Node * A, int left, int mid, int right){
    int n1 = mid - left;
    int n2 = right - mid;
    int com_i = 0, com_j = 0;
    Node * L = (Node *)malloc(sizeof(Node) * (n1 + 1));
    Node * R = (Node *)malloc(sizeof(Node) * (n2 + 1));
    for (int i = 0; i < n1; i++){
        L[i] = A[left + i];
    }
    for (int i = 0; i < n2; i++){
        R[i] = A[mid + i];
    }
    Node tmp = {MAX, MAX, 'Z', 2000000000005l, "zzzzzzzzzzzzzzzzzzzz"};
    L[n1] = R[n2] = tmp;
    for (int i = left; i < right; i++){
        if (LeftIsSmaller(L, com_i, R, com_j) == 1){
            A[i] = L[com_i];
            com_i++;
        } else {
            A[i] = R[com_j];
            com_j++;
        }
    }
    return;
}

void MargeSort(Node * A, int left, int right){
    if (left + 1 < right){
        int mid = (left + right)/2;
        MargeSort(A, left, mid);
        MargeSort(A, mid, right);
        Marge(A, left, mid, right);
    }
}

int main(void){
    // Your code here!
    int n;
    scanf(" %d", &n);
    Node * A = (Node * )malloc(sizeof(Node) * (n+1));
    for (int i = 0; i < n; i++){
        scanf(" %d %d %c %ld %s", &A[i].price, &A[i].weigth, &A[i].type, &A[i].Time, A[i].name);
        //printf(" %d %d %c %ld %s\n", A[i].price, A[i].weigth, A[i].type, A[i].Time, A[i].name);
    }
    
    //printf("\n");
    
    MargeSort(A, 0, n);
    
    for (int i = 0; i < n; i++){
        printf("%d %d %c %ld %s\n", A[i].price, A[i].weigth, A[i].type, A[i].Time, A[i].name);
    }
    
    
    
    return 0;
}
