#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

constexpr ll mod = 998244353;

ll mod_pow(ll a,ll b){
    a%=mod;
    if(b==0)return 1;
    if(b==1)return a;
    ll res=mod_pow(a,b/2)%mod;
    res*=res; res%=mod;
    if(b%2)res*=a;
    return res%mod;
}

struct perm{
private:
    int sz;
    vector<ll> p,invp;
public:
    perm(int n){
        sz=n+1;
        p.resize(sz),invp.resize(sz);
        p[0]=1;
        for(int i=1;i<=sz-1;i++){
            p[i]=p[i-1]*i%mod;
        }
        invp[sz-1]=mod_pow(p[sz-1],mod-2);
        for(int i=sz-2;i>=0;i--){
            invp[i]=invp[i+1]*(i+1)%mod;
        }
    }
    ll comb(ll x,ll y){
        if(x<y||y<0)return 0;
        return (p[x]*invp[x-y]%mod)*invp[y]%mod;
    }
};
perm P(1<<20);


template<typename T> using V = vector<T>;
template<typename T> using VV = vector<vector<T>>;
template<typename T> using PQ = priority_queue<T>;
template<typename T> using PQR = priority_queue<T,vector<T>,greater<T>>;
#define fs first
#define sc second
#define pb push_back
#define mp make_pair
#define mt make_tuple
#define eb emplace_back
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
#define all(v) (v).begin(),(v).end()
#define siz(v) (ll)(v).size()
#define rep(i,a,n) for(ll i=a;i<(ll)(n);++i)
#define repr(i,a,n) for(ll i=n-1;(ll)a<=i;--i)
#define pw2(n) (1ll<<(n))
#define pcntl(x) __builtin_popcountll(x)
#define ENDL '\n'
typedef pair<int,int> Pi;
typedef pair<ll,ll> PL;

template <const long long MOD = 998244353> // MODを適宜設定すること
struct Mint {
  using M = Mint;
  ll a;
  Mint(ll x = 0) {
    a = x % MOD;
    if (a < 0)
      a += MOD;
  } // Mintで

  M pow(ll n) {
    assert(n >= 0);
    M b = *this, r = 1 % MOD;
    while (n) {
      if (n & 1)
        r *= b;
      b *= b;
      n >>= 1;
    }
    return r;
  }

  M inv() { return pow(MOD - 2); }

  M &operator+=(M r) {
    a += r.a;
    if (a >= MOD)
      a -= MOD;
    return *this;
  }
  M &operator-=(M r) {
    a += MOD - r.a;
    if (a >= MOD)
      a -= MOD;
    return *this;
  }
  M &operator*=(M r) {
    a = 1LL * a * r.a % MOD;
    return *this;
  }
  M &operator/=(M r) { return (*this) *= r.inv(); }
  M operator+(M r) const { return M(a) += r; };
  M operator-(M r) const { return M(a) -= r; };
  M operator*(M r) const { return M(a) *= r; };
  M operator/(M r) const { return M(a) /= r; };
  M operator-() const { return M() - *this; }

  friend ostream &operator<<(ostream &os, const M &r) { return os << r.a; }
};
using M = Mint<998244353>;

// is_extendedがtrueのとき、aはAx=BのAとBを連結した行列
int GaussJordan(VV<M> &a, bool is_extended = false) {
  int m = a.size(), n = a[0].size(), rank = 0;
  assert(m);

  rep(c, 0, n) {
    if (is_extended && c == n - 1)
      break;
    int pivot = -1;
    rep(r, rank, m) {
      if (a[r][c].a != 0) {
        pivot = r;
        break;
      }
    }

    if (pivot == -1)
      continue;

    swap(a[pivot], a[rank]);
    M inv = a[rank][c].inv();
    rep(c2, 0, n) a[rank][c2] *= inv;

    rep(r, 0, m) {
      if (r != rank && a[r][c].a) {
        M fac = a[r][c];
        rep(c2, 0, n) a[r][c2] -= a[rank][c2] * fac;
      }
    }
    ++rank;
  }
  return rank;
}

int linear_equation(VV<M> a, vector<ll> b, vector<ll> &res) {
  int m = a.size(), n = a[0].size();
  VV<M> mat(m, V<M>(n + 1));
  rep(i, 0, m) {
    rep(j, 0, n) mat[i][j] = a[i][j];
    mat[i][n] = b[i];
  }
  int rank = GaussJordan(mat, true);

  rep(r, rank, m) if (mat[r][n].a) return -1;

  // answer
  res.assign(n, 0);
  rep(i, 0, rank) res[i] = mat[i][n].a;
  return rank;
}
/*
-1 : 解なし
rank=nのとき、resに解が入る
rank<nのとき、(n-rank)個の値を決めると解が定まる
*/

using state = array<int,3>;

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<state> v;
    map<state,int> mp;
    auto find_id=[&](state x)->bool{
        if(mp.find(x) == mp.end()){
            int sz = mp.size();
            v.push_back(x);
            mp[x] = sz; return true;
        }
        return false;
    };
    vector<pair<pair<int,int>,ll>> edge;
    // 遷移列挙
    {
        queue<int> q;
        state init = {n,0,0};
        mp[init] = 0;
        v.push_back(init);
        q.push(0);
        const ll inv = mod_pow(P.comb(n,2), mod-2);
        auto add1=[&](int x)->int{
            if(x+1 == 3)return 0;
            else return x+1;
        };
        while(q.size()){
            int _ = q.front(); q.pop();
            auto cur = v[_];
            for(int i=0;i<3;i++){
                for(int j=i;j<3;j++){
                    if(i == j and cur[i]<2)continue;
                    if(cur[i]<1 or cur[j]<1)continue;
                    int ni = add1(i);
                    int nj = add1(j);
                    cur[i]--; cur[j]--;
                    cur[ni]++; cur[nj]++;
                    if(find_id(cur)){
                        q.push(mp[cur]);
                    }
                    int nxt = mp[cur];
                    cur[i]++; cur[j]++;
                    cur[ni]--; cur[nj]--;
                    ll r;
                    if(i == j){
                        r = P.comb(cur[i],2);
                    }
                    else{
                        r = (ll)cur[i]*(ll)cur[j];
                    }
                    r *= inv;
                    r %= mod;
                    edge.push_back({{_,nxt},r});
                }
            }
        }
    }
    int goal = mp[{0,0,n}];
    int sz = mp.size();
    vector<vector<M>> A(sz,vector<M>(sz));
    vector<ll> B(sz);
    for(auto e:edge){
        if(e.first.first == goal)continue;
        // cout << e.first.first << " " << e.first.second << " " << e.second << endl;
        A[e.first.first][e.first.second] = -e.second;
    }
    for(int i=0;i<sz;i++){
        A[i][i] = 1;
        B[i] = (goal != i);
    }
    vector<ll> res;
    auto r = linear_equation(A, B, res);
    // ll sum = 0;
    // for(int i=0;i<sz;i++){
    //     cout << res[i] << endl;
    //     sum += res[i];
    // }
    cout << res[0] << endl;
}


