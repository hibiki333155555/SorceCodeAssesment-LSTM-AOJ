#pragma GCC target("avx")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using P = pair<int, int>;

#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
using mint = modint1000000007;
#endif // __has_include(<atcoder/all>)

#define Rep(i, n) for (int i = 0; i < (int)(n); ++i)
#define SegRep(i, a, b) for (int i = (int)a; i <= (int)(b); ++i)
#define RevRep(i, b, a) for (int i = (int)b; i >= a; --i)
#define BitRep(i, n) for (int i = 0; i < (int)(1 << n); ++i)
#define All(vec) vec.begin(), vec.end()
#define Part(vec, b, e) vec.begin() + b, vec.begin() + e
#define Accumulate(vec) accumulate(vec.begin(), vec.end(), 0LL)
#define Sort(vec) sort(vec.begin(), vec.end())
#define Reverse(vec) reverse(vec.begin(), vec.end())
#define Unique(vec) unique(vec.begin(), vec.end())
#define Erase(vec) erase(vec.begin(), vec.end())
#define Count(vec, x) (int)count(vec.begin(), vec.end(), x)
#define Find(vec, s) vec.find(s) != vec.end()
#define Iota(vec, x) iota(vec.begin(), vec.end(), x)
#define Next_permutation(vec) next_permutation(vec.begin(), vec.end())
#define Set_union(A, B, res) set_union(A.begin(), A.end(), B.begin(), B.end(), inserter(res, res.end()));
#define Set_intersection(A, B, res) set_intersection(A.begin(), A.end(), B.begin(), B.end(), inserter(res, res.end()));
#define Set_difference(A, B, res) set_difference(A.begin(), A.end(), B.begin(), B.end(), inserter(res, res.end()));
#define Set_symmetric_difference(A, B, res) set_symmetric_difference(A.begin(), A.end(), B.begin(), B.end(), inserter(res, res.end()));

const double PI = acos(-1);
constexpr ll MOD = 1000000007;
constexpr int INF = 1000000001;
constexpr ll LLINF = 1000000000000000001;
constexpr int dx4[] = {1, 0, -1, 0};
constexpr int dy4[] = {0, 1, 0, -1};
constexpr int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};
constexpr int dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};

class Timer {
public:
	Timer() {
		start_ = std::chrono::system_clock::now();
	}

	~Timer() {
		end_ = std::chrono::system_clock::now();
		auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_ - start_).count();
		std::cout << elapsed << " ms" << std::endl;
	}

private:
	std::chrono::system_clock::time_point start_, end_;
};

template <class T>
inline bool chmin(T &a, const T &b) noexcept {
	if (a > b) {
		a = b;
		return true;
	}
	return false;
}
template <class T>
inline bool chmax(T &a, const T &b) noexcept {
	if (a < b) {
		a = b;
		return true;
	}
	return false;
}

template<class T>
using min_heap = priority_queue<T, vector<T>, greater<T>>;
template<class T>
using max_heap = priority_queue<T, vector<T>, less<T>>;

struct UnionFind {
protected:
	vector<int> par_;
	int group_cnt_;

public:
	explicit UnionFind(const int &N) : par_(N, -1), group_cnt_(N) {}

	virtual int root(const int &x) {
		if (par_[x] < 0) return x;
		return par_[x] = root(par_[x]);
	}

	bool same(const int &x, const int &y) {
		return root(x) == root(y);
	}

	bool unite(int x, int y) {
		x = root(x), y = root(y);
		if (x == y) return false;
		if (par_[x] > par_[y]) swap(x, y);
		par_[x] += par_[y];
		par_[y] = x;
		group_cnt_--;
		return true;
	}

	int size(const int &x) {
		return -par_[root(x)];
	}

	int max_size() const {
		return -(*min_element(All(par_)));
	}

	int group_count() const noexcept {
		return group_cnt_;
	}
};
struct WeightedUnionFind : public UnionFind {
private:
	vector<int> diff_weight_;

public:
	explicit WeightedUnionFind(const int &N) : UnionFind(N), diff_weight_(N, 0) {}

	int root(const int &x) override {
		if (par_[x] < 0) return x;
		const int r = root(par_[x]);
		diff_weight_[x] += diff_weight_[par_[x]];
		return par_[x] = r;
	}

	int weight(const int &x) {
		root(x);
		return diff_weight_[x];
	}

	bool unite(int &x, int &y, int &w) {
		w += weight(x);
		w -= weight(y);
		x = root(x);
		y = root(y);
		if (x == y) return false;
		if (par_[x] < par_[y]) {
			swap(x, y);
			w = -w;
		}
		par_[x] += par_[y];
		par_[y] = x;
		diff_weight_[y] = w;
		group_cnt_--;
		return true;
	}

	int diff(const int &x, const int &y) {
		if (same(x, y)) return weight(y) - weight(x);
		return INF;
	}
};

template<class T, T(*op)(T, T) = min, T e_ = INT_MAX>
struct SegmentTree {
private:
	int n_;
	vector<T> node_;

public:
	SegmentTree(const int &N) {
		n_ = 1;
		while (n_ < N) n_ *= 2;
		node_.resize(2 * n_ - 1, e_);
	}

	void update(int &i, const T &x) {
		i += n_ - 1;
		node_[i] = x;
		while (i > 0) {
			i = (i - 1) / 2;
			node_[i] = op(node_[2 * i + 1], node_[2 * i + 2]);
		}
	}

	int query(const int &a, const int &b) {
		return query_sub(a, b, 0, 0, n_);
	}

	int query_sub(const int &a, const int &b, const int &k, const int &l, const int &r) {
		if (r <= a || b <= l) return e_;
		if (a <= l && r <= b) return node_[k];
		int vl = query_sub(a, b, 2 * k + 1, l, (l + r) / 2);
		int vr = query_sub(a, b, 2 * k + 2, (l + r) / 2, r);
		return op(vl, vr);
	}
};
template<class T, T(*op)(T, T) = min, T e_ = INT_MAX>
struct LazySegmentTree {
private:
	int n_;
	vector<T> node_;
	vector<T> delay_;

public:
	LazySegmentTree(const int &N) {
		n_ = 1;
		while (n_ < N) n_ *= 2;
		node_.resize(2 * n_ - 1, e_);
		delay_.resize(2 * n_ - 1, e_);
	}

	void delay(const int &i, const int &l, const int &r) {
		if (delay_[i] == e_) return;
		T x = delay_[i];
		node_[i] = x;
		if (i < n_ - 1) {
			delay_[2 * i + 1] = x;
			delay_[2 * i + 2] = x;
		}
		delay_[i] = e_;
	}

	void update(const int &l, const int &r, const T &x) {
		update_sub(l, r, x, 0, 0, n_);
	}

	void update_sub(const int &a, const int &b, const T &x, const int &k, const int &l, const int &r) {
		delay(k, l, r);
		if (r <= a || b <= l) return;
		if (a <= l && r <= b) {
			delay_[k] = x;
			delay(k, l, r);
		} else {
			update_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);
			update_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);
			node_[k] = op(node_[2 * k + 1], node_[2 * k + 2]);
		}
	}

	T query(const int &a, const int &b) {
		return query_sub(a, b, 0, 0, n_);
	}

	T query_sub(const int &a, const int &b, const int &k, const int &l, const int &r) {
		if (r <= a || b <= l) return INF;
		delay(k, l, r);
		if (a <= l && r <= b) return node_[k];
		T vl = query_sub(a, b, 2 * k + 1, l, (l + r) / 2);
		T vr = query_sub(a, b, 2 * k + 2, (l + r) / 2, r);
		return vl < vr ? vl : vr;
	}

	T find(const int &i) {
		return query_sub(i, i + 1, 0, 0, n_);
	}
};
template<class T>
struct BIT {
private:
	int n_;
	vector<T> node_;

public:
	BIT(const int &N) : n_(N), node_(N + 1, 0) {}

	T sum(int i) {
		T res = 0;
		while (i > 0) {
			res += node_[i];
			i -= i & -i;
		}
		return res;
	}

	T segment_sum(int a, int b) {
		return sum(b) - sum(a - 1);
	}

	void add(int i, const T &x) {
		while (i <= n_) {
			node_[i] += x;
			i += i & -i;
		}
	}

	int lower_bound(T &x) {
		if (x <= 0) return 0;
		int i = 0, r = 1;
		while (r < n_) r <<= 1;
		for (int len = r; len > 0; len >>= 1) {
			if (i + len < n_ && node_[i + len] < x) {
				x -= node_[i + len];
				i += len;
			}
		}
		return i;
	}
};

template<class T>
double median(vector<T> &vec, const bool &sorted = false) {
	if (!sorted) sort(vec.begin(), vec.end());
	int n = vec.size();
	if (n % 2 == 1) return vec[n / 2];
	else return (double)(vec[n / 2 - 1] + vec[n / 2]) / 2;
}

template<class T>
T gcd(T x, T y) {
	if (y == 0) return x;
	return gcd(y, x % y);
}
template<class T>
inline ll lcm(T x, T y) {
	return x / gcd(x, y) * y;
}
int extend_gcd(int a, int b, int &x, int &y) {
	int d = a;
	if (b != 0) {
		d = extend_gcd(b, a % b, y, x);
		y -= (a / b) * x;
	} else {
		x = 1;
		y = 0;
	}
	return d;
}

template<class T>
bool is_prime(const T &n) {
	if (n % 2 == 0 && n != 2) return false;
	for (ll i = 3; i * i <= n; i += 2) {
		if (n % i == 0) return false;
	}
	if (n <= 1) return false;
	return true;
}
template<class T>
set<ll> divisor(const T &n) {
	set<ll> res;
	for (ll i = 1; i * i <= n; ++i) {
		if (n % i == 0) {
			res.insert(i);
			if (n / i != i) res.insert(n / i);
		}
	}
	return res;
}
map<ll, int> prime_factor(ll &n) {
	map<ll, int> res;
	while (n % 2 == 0) {
		++res[2];
		n /= 2;
	}
	for (ll i = 3; i * i <= n; i += 2) {
		while (n % i == 0) {
			++res[i];
			n /= i;
		}
	}
	if (n != 1) res[n] = 1;
	return res;
}
vector<ll> prime_factor_vector(ll &N) {
	ll rem = N;
	vector<ll> p;
	for (ll i = 2; i * i <= N; ++i) {
		while (rem % i == 0) {
			rem /= i;
			p.emplace_back(i);
		}
	}
	if (rem != 1LL) p.emplace_back(rem);
	return p;
}
int divisor_count(ll &n, const ll &mod) {
	ll ans = 1;
	for (auto val : prime_factor(n)) {
		ans = ans * ((ll)val.second + 1) % mod;
	}
	return (int)ans;
}

ll legendre(ll &N, const ll &p) {
	ll res = 0;
	while (N) {
		res += N / p;
		N /= p;
	}
	return res;
}

vector<bool> sieve(const int &n) {
	vector<bool> res(n + 1, true);
	res[0] = res[1] = false;
	for (int i = 4; i <= n; i += 2) res[i] = false;
	for (int i = 3; i * i <= n; i += 2) {
		if (res[i]) {
			for (int j = i * 2; j <= n; j += i) res[j] = false;
		}
	}
	return res;
}
int prime_count(const int &n) {
	int res = 0;
	for (auto val : sieve(n)) {
		if (val) res++;
	}
	return res;
}
vector<bool> segment_sieve(const int &a, const int &b) {
	vector<bool> tmp((int)sqrt(b) + 1, true), res(b - a, true);
	for (int i = 4; i * i < b; i += 2) tmp[i] = false;
	for (int i = max(2, (a + 1) / 2) * 2; i < b; i += 2) res[i - a] = false;
	for (int i = 3; i * i < b; i += 2) {
		if (tmp[i]) {
			for (int j = i * 2; j * j < b; j += i) tmp[j] = false;
			for (int j = max(2, (a + i - 1) / i) * i; j < b; j += i) res[j - a] = false;
		}
	}
	return res;
}
int segment_prime_count(const int &a, const int &b) {
	int res = 0;
	for (auto val : segment_sieve(a, b)) {
		if (val) ++res;
	}
	return res;
}

ll fast_pow(ll x, ll e) {
	ll res = 1;
	while (e > 0) {
		if (e & 1) res = res * x;
		x = x * x;
		e >>= 1;
	}
	return res;
}
ll mod_pow(ll x, ll e, const ll &mod = MOD) {
	ll res = 1;
	while (e > 0) {
		if (e & 1) res = res * x % mod;
		x = x * x % mod;
		e >>= 1;
	}
	return res;
}
ll mod_inv(ll a, const ll &mod = MOD) {
	return mod_pow(a, mod - 2, mod);
}
template<class T>
ll mod_fact(T n, const ll &mod = MOD) {
	ll res = 1;
	while (n > 0) {
		res = res * n % mod;
		--n;
	}
	return res;
}
ll mod_comb(ll n, ll k, const ll &mod = MOD) {
	vector<ll> fact(n + 1);
	fact[1] = 1;
	for (ll i = 2; i <= n; ++i) {
		fact[i] = fact[i - 1] * i % mod;
	}
	return fact[n] * mod_inv(fact[k] * fact[n - k] % mod, mod) % mod;
}

template<class T>
vector<vector<T>> mat_mul(vector<vector<T>> &A, vector<vector<T>> &B, const ll &mod = MOD) {
	int N = A.size();
	vector<vector<T>> res(N, vector<T>(N));
	T tmp;
	Rep(i, N) {
		Rep(j, N) {
			tmp = 0;
			Rep(k, N) {
				tmp = (tmp + A[i][k] * B[k][j]) % mod;
			}
			res[i][j] = tmp;
		}
	}
	return res;
}
template<class T>
vector<vector<T>> mat_pow(vector<vector<T>> &A, ll e, const ll &mod = MOD) {
	int N = A.size();
	vector<vector<T>> res(N, vector<T>(N));
	Rep(i, N) res[i][i] = 1;
	while (e > 0) {
		if (e & 1) res = mat_mul(res, A, mod);
		A = mat_mul(A, A, mod);
		e >>= 1;
	}
	return res;
}

template<class T>
struct Edge {
public:
	int to_;
	T weight_;

	Edge(const int &t, const T &w) : to_(t), weight_(w) {}

	inline bool operator<(Edge &e) const {
		return weight_ < e.weight_;
	}
};
template<class T>
struct Edge2 {
public:
	int from_, to_;
	T weight_;

	Edge2(const int &f, const int &t, const T &w) : from_(f), to_(t), weight_(w) {}

	inline bool operator<(Edge2 &e) const {
		return weight_ < e.weight_;
	}
};

using Graph = vector<vector<int>>;
template<class T>
using WeightedGraph = vector<vector<Edge<T>>>;

vector<int> topological_sort(const Graph &G) {
	vector<int> res;
	int n = (int)G.size();
	vector<int> in_deg(n);
	for (int i = 0; i < n; ++i) {
		for (const int &to : G[i]) {
			++in_deg[to];
		}
	}
	queue<int> que;
	for (int i = 0; i < n; ++i) {
		if (in_deg[i] == 0) {
			que.push(i);
		}
	}
	while (!que.empty()) {
		int now = que.front();
		res.emplace_back(now);
		que.pop();
		for (const int &to : G[now]) {
			--in_deg[to];
			if (in_deg[to] == 0) {
				que.push(to);
			}
		}
	}
	return res;
}

template<class T>
T maximum_spanning_tree(vector<Edge2<T>> &edges, const int &n, const bool &sorted = false) {
	T res = 0;
	UnionFind UF(n);
	if (!sorted) sort(edges.begin(), edges.end());
	for (const auto &e : edges) {
		if (UF.unite(e.from_, e.to_)) res += e.weight_;
	}
	return res;
}

int tree_diameter(const Graph &G) {
	int n = G.size();
	vector<int> dist(n, -1);
	queue<int> Q;
	dist[0] = 0;
	Q.push(0);
	while (!Q.empty()) {
		int cur = Q.front(); Q.pop();
		for (const auto &to : G[cur]) {
			if (dist[to] != -1) continue;
			dist[to] = dist[cur] + 1;
			Q.push(to);
		}
	}
	int s = max_element(dist.begin(), dist.end()) - dist.begin();
	fill(dist.begin(), dist.end(), -1);
	dist[s] = 0;
	Q.push(s);
	while (!Q.empty()) {
		int cur = Q.front(); Q.pop();
		for (const auto &to : G[cur]) {
			if (dist[to] != -1) continue;
			dist[to] = dist[cur] + 1;
			Q.push(to);
		}
	}
	return *max_element(dist.begin(), dist.end());
}

template <class T>
vector<T> compress(vector<T> &X) {
	vector<T> res = X;
	sort(res.begin(), res.end());
	res.erase(unique(res.begin(), res.end()), res.end());
	for (int i = 0; i < (int)X.size(); ++i) {
		X[i] = lower_bound(res.begin(), res.end(), X[i]) - res.begin();
	}
	return res;
}
template <typename T>
vector<T> compress(vector<T> &C1, vector<T> &C2) {
	vector<T> vals;
	int N = (int)C1.size();
	for (int i = 0; i < N; ++i) {
		for (T d = 0; d <= 1; d++) {
			T tc1 = C1[i] + d;
			T tc2 = C2[i] + d;
			vals.push_back(tc1);
			vals.push_back(tc2);
		}
	}
	sort(vals.begin(), vals.end());
	vals.erase(unique(vals.begin(), vals.end()), vals.end());
	for (int i = 0; i < N; ++i) {
		C1[i] = lower_bound(vals.begin(), vals.end(), C1[i]) - vals.begin();
		C2[i] = lower_bound(vals.begin(), vals.end(), C2[i]) - vals.begin();
	}
	return vals;
}

vector<complex<double>> fft(vector<complex<double>> &a, const bool &inverse = false) {
	int n = a.size();
	int h = 0;
	for (int i = 0; 1 << i < n; ++i) h++;
	for (int i = 0; i < n; ++i) {
		int j = 0;
		for (int k = 0; k < h; ++k) j |= (i >> k & 1) << (h - 1 - k);
		if (i < j) swap(a[i], a[j]);
	}
	for (int b = 1; b < n; b *= 2) {
		for (int j = 0; j < b; ++j) {
			complex<double> w = polar(1.0, (2 * PI) / (2 * b) * j * (inverse ? 1 : -1));
			for (int k = 0; k < n; k += b * 2) {
				complex<double> s = a[j + k];
				complex<double> t = a[j + k + b] * w;
				a[j + k] = s + t;
				a[j + k + b] = s - t;
			}
		}
	}
	if (inverse)
		for (int i = 0; i < n; i++) a[i] /= n;
	return a;
}
vector<complex<double>> fft(vector<double> &a, const bool &inverse = false) {
	int n = a.size();
	vector<complex<double>> a_complex(n);
	for (int i = 0; i < n; ++i) a_complex[i] = complex<double>(a[i], 0);
	return fft(a_complex, inverse);
}
vector<double> convolte(vector<double> &a, vector<double> &b) {
	int s = a.size() + b.size() - 1;
	int t = 1;
	while (t < s) t *= 2;
	a.resize(t);
	b.resize(t);
	vector<complex<double>> A = fft(a);
	vector<complex<double>> B = fft(b);
	for (int i = 0; i < t; i++) {
		A[i] *= B[i];
	}
	A = fft(A, true);
	a.resize(s);
	for (int i = 0; i < s; i++) a[i] = A[i].real();
	return a;
}

void Main() {
	int n, q;
	cin >> n >> q;
	WeightedUnionFind UF(n);
	Rep(i, q) {
		int t, x, y;
		cin >> t >> x >> y;
		if (t == 0) {
			int z;
			cin >> z;
			UF.unite(x, y, z);
		} else {
			int d = UF.diff(x, y);
			if (d == INF) cout << '?' << endl;
			else cout << d << endl;
		}
	}
}

int main() {
	cin.tie(nullptr);
	ios_base::sync_with_stdio(false);
	cout << fixed << setprecision(15);
	Main();
	return 0;
}
