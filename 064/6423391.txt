#include <bits/stdc++.h>
using namespace std;

struct io_setup {
    io_setup() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout << fixed << setprecision(15);
    }
} io_setup;

struct Union_Find_Tree {
    vector<int> data;
    const int n;
    int cnt;

    Union_Find_Tree(int n) : data(n, -1), n(n), cnt(n) {}

    int root(int x) {
        if (data[x] < 0) return x;
        return data[x] = root(data[x]);
    }

    int operator[](int i) { return root(i); }

    bool unite(int x, int y) {
        x = root(x), y = root(y);
        if (x == y) return false;
        if (data[x] > data[y]) swap(x, y);
        data[x] += data[y], data[y] = x;
        cnt--;
        return true;
    }

    int size(int x) { return -data[root(x)]; }

    int count() { return cnt; };

    bool same(int x, int y) { return root(x) == root(y); }

    void clear() {
        cnt = n;
        fill(begin(data), end(data), -1);
    }
};

template <typename T, bool directed = false>
struct Kruscal {
    struct edge {
        int from, to;
        T cost;
        int id;
        edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}
    };

    vector<edge> es;
    const T INF_T;
    const int n;
    int m;

    Kruscal(int n) : INF_T(numeric_limits<T>::max() / 2), n(n), m(0) {}

    void add_edge(int from, int to, T cost) {
        es.emplace_back(from, to, cost, m);
        if (!directed) es.emplace_back(to, from, cost, m);
        m++;
    }

    T min_spanning_tree() {
        sort(begin(es), end(es), [](const edge &e1, const edge &e2) { return e1.cost < e2.cost; });
        Union_Find_Tree uf(n);
        T ret = 0;
        for (auto &e : es) {
            if (uf.unite(e.from, e.to)) ret += e.cost;
        }
        if (uf.size(0) < n) return INF_T;
        return ret;
    }
};

int main() {
    int V, E;
    cin >> V >> E;

    Kruscal<int> G(V);

    for (int i = 0; i < E; i++) {
        int u, v, c;
        cin >> u >> v >> c;
        G.add_edge(u, v, c);
    }

    cout << G.min_spanning_tree() << '\n';
}
