#include<iostream>
#include<vector>
using namespace std;
const int NIL = -1;
struct Tree
{
    int parent;
    int leftChild;
    int rightSibling;
    Tree() : parent(NIL), leftChild(NIL), rightSibling(NIL){}
};
int getDepth(struct Tree *A, int k);
void Child(struct Tree *A, int n, vector<int>& Child);

int main()
{
    int n;
    cin >> n;
    struct Tree *A;
    A = new struct Tree[n];
    for (int i = 0, k = 0, id = 0; i < n; ++i)
    {
        int lastChild = NIL, currentChild = NIL;
        cin >> id >> k;
        for (int j = 0; j < k; ++j)
        {
            cin >> currentChild;
            A[currentChild].parent = id;
            if(A[id].leftChild == NIL)
                A[id].leftChild = currentChild;
            if(lastChild != NIL)
                A[lastChild].rightSibling = currentChild;
            lastChild = currentChild;
        }
    }

    vector<int> Children;
    for (int i = 0; i < n; ++i)
    {
        cout << "node " << i << ": parent = " << A[i].parent
             << ", depth = " << getDepth(A, i) << ", ";
        if(A[i].parent == NIL)
            cout << "root, [";
        else if(A[i].leftChild == NIL)
            cout << "leaf, [";
        else
            cout << "internal node, [";
        Child(A, i, Children);
        for (auto j = Children.begin(); j < Children.end(); ++j)
        {
            cout << *j;
            if (j < Children.end() - 1)
                cout << ", ";
        }
        cout << "]" << endl;
    }

    return 0;
}
int getDepth(struct Tree *A, int k)
{
    int d = 0;
    while (A[k].parent != NIL)
    {
        k = A[k].parent;
        ++d;
    }
    return d;
}
void Child(struct Tree *A, int n, vector<int>& Children)
{
    Children.clear();
    n = A[n].leftChild;
    while (n != NIL)
    {
        Children.push_back(n);
        n = A[n].rightSibling;
    }
}
