#line 1 "test.cpp"
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using P = pair<int, int>;
template <typename T = int>
using VV = vector<vector<T>>;

#line 2 "/Library/kyopro-lib/scc_graph.cpp"

#line 6 "/Library/kyopro-lib/scc_graph.cpp"

class SCC_Graph {
 public:
  SCC_Graph(int n) : n(n), comp(n, -1), g(n), rev_g(n) {};

  void add_edge(int from, int to) {
    g[from].push_back(to);
    rev_g[to].push_back(from);
  };

  std::vector<int> scc() {
    std::vector<bool> visited(n, false);
    std::vector<int> order;

    for (int i = 0; i < n; ++i) {
      if (!visited[i]) dfs(i, visited, order);
    }

    std::reverse(std::begin(order), std::end(order));

    int comp_idx = 0;
    for (int i = 0; i < n; ++i) {
      if (comp[i] == -1) {
        rdfs(i, comp_idx, comp, siz);
        ++comp_idx;
      }
    }

    return comp;
  }

  bool is_same(int u, int v) {
    return comp[u] != -1 && comp[v] != -1 && comp[u] == comp[v];
  }

  int size(int u) {
    return siz[comp[u]];
  }

 private:
  int n;
  std::vector<int> comp;
  std::vector<std::vector<int>> g, rev_g;
  std::map<int, int> siz;

  void dfs(int u, std::vector<bool> &visited, std::vector<int> &order) {
    visited[u] = true;
    for (int v : g[u]) {
      if (!visited[v]) dfs(v, visited, order);
    }
    order.push_back(u);
  }

  void rdfs(int u, int comp_idx, std::vector<int> &comp, std::map<int, int> siz) {
    comp[u] = comp_idx;
    ++siz[comp_idx];
    for (int v : rev_g[u]) {
      if (comp[v] == -1) rdfs(v, comp_idx, comp, siz);
    }
  }
};
#line 11 "test.cpp"

int main() {
  int n, m;
  cin >> n >> m;

  SCC_Graph scc_g(n);
  for (int i = 0; i < m; ++i) {
    int s, t;
    cin >> s >> t;
    scc_g.add_edge(s, t);
  }

  scc_g.scc();

  int q;
  cin >> q;

  for (int i = 0; i < q; ++i) {
    int u, v;
    cin >> u >> v;
    cout << scc_g.is_same(u, v) << "\n";
  }
  
  // cout << ans << endl;
  // cout << (ok ? "Yes" : "No") << endl;
}

