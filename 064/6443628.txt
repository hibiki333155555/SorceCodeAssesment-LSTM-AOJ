import sys
import copy

# READ_FROM_FILE = True
READ_FROM_FILE = False

RIGHT = 0
DOWN = 1
LEFT = 2
UP = 3
DIRECTION_BEGIN = RIGHT
DIRECTION_END = RIGHT + 4
DUMMY_DIRECTION = DIRECTION_END + 1

opposite_dir_dic = {RIGHT: LEFT,
                    DOWN: UP,
                    LEFT: RIGHT,
                    UP: DOWN,
                    DIRECTION_END: DUMMY_DIRECTION}
dx_dy_dic = {RIGHT: [1, 0], DOWN: [0, 1], LEFT: [-1, 0], UP: [0, -1]}


def show_puzzle(puzzle, width, height):
    for y in range(height):
        for x in range(width):
            print(f'{puzzle[y][x]:2d}', end=' ')
        print('')
    return


def calc_manhattan_distance_table(width, num_idx, goal_state):
    manhattan_distance_table = [[0] * num_idx for _ in range(num_idx)]

    for c_num in range(num_idx):
        g_idx = goal_state.index(c_num)
        gx = g_idx % width
        gy = g_idx // width
        for c_idx in range(num_idx):
            cx = c_idx % width
            cy = c_idx // width

            if c_num != 0:
                manhattan_distance_table[c_num][c_idx] = abs(gx - cx) + abs(gy - cy)
            else:
                manhattan_distance_table[c_num][c_idx] = 0
    return manhattan_distance_table


def calc_manhattan_distance(num_idx, manhattan_distance_table, state):
    m_dist = 0
    for c_idx in range(num_idx):
        c_num = state[c_idx]
        m_dist += manhattan_distance_table[c_num][c_idx]
    return m_dist


def get_next_state_list(adjacency_list, manhattan_distance_table, c_h_dist, c_state, c_zero_idx, c_dir):
    next_state_list = []
    for adjacent in adjacency_list[c_zero_idx]:
        n_dir = adjacent[1]
        if c_dir == opposite_dir_dic[n_dir]:
            continue
        n_idx = adjacent[0]
        num_c_state_n_idx = c_state[n_idx]
        n_state = copy.copy(c_state)
        n_state[c_zero_idx] = c_state[n_idx]
        n_state[n_idx] = 0
        n_h_dist = c_h_dist \
                   - manhattan_distance_table[0][c_zero_idx] - manhattan_distance_table[num_c_state_n_idx][n_idx] \
                   + manhattan_distance_table[0][n_idx] + manhattan_distance_table[num_c_state_n_idx][c_zero_idx] + 1
        next_state_list.append((n_h_dist, n_state, n_idx, n_dir))
    return next_state_list


def dls(num_idx, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
        c_h_dist, c_state, c_zero_idx, c_dir, c_num_moves):
    if c_state == goal_state:
        return c_num_moves

    if c_num_moves > depth_limit:
        return -1

    next_state_list = get_next_state_list(adjacency_list, manhattan_distance_table,
                                          c_h_dist, c_state, c_zero_idx, c_dir)
    for next_state in next_state_list:
        n_h_dist = next_state[0]
        n_state = next_state[1]
        n_zero_idx = next_state[2]
        n_dir = next_state[3]
        n_num_moves = c_num_moves + 1

        if n_h_dist > depth_limit:
            return -1

        min_num_moves = dls(num_idx, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
                            n_h_dist, n_state, n_zero_idx, n_dir, n_num_moves)
        if min_num_moves >= 0:
            return min_num_moves
    return -1


def iddfs(num_idx, adjacency_list, manhattan_distance_table, max_depth, start_state, zero_idx, goal_state):
    c_m_dist = calc_manhattan_distance(num_idx, manhattan_distance_table, start_state)
    is_even_start_zero_idx = (zero_idx % 2 == 0)
    g_zero_idx = goal_state.index(0)
    is_even_goal_zero_idx = (g_zero_idx % 2 == 0)
    start_depth = c_m_dist

    if is_even_start_zero_idx != is_even_goal_zero_idx:
        start_depth += 1

    for depth_limit in range(start_depth, max_depth + 2, 2):
        min_num_moves = dls(num_idx, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
                            c_m_dist, start_state, zero_idx, DIRECTION_END, 0)

        if min_num_moves >= 0:
            return min_num_moves
        elif depth_limit == max_depth:
            return max_depth
    return -1


def main():
    if READ_FROM_FILE:
        f = open('test00.txt', 'r')
    else:
        f = sys.stdin

    goal_state = []
    width = 4
    height = 4
    num_idx = width * height
    adjacency_list = [[] for _ in range(num_idx)]

    for y in range(height):
        offset = y * width
        for x in range(width):
            idx = offset + x
            goal_state.append(idx + 1)

            for d in range(DIRECTION_BEGIN, DIRECTION_END):
                dx = dx_dy_dic[d][0]
                dy = dx_dy_dic[d][1]
                nx = x + dx
                ny = y + dy
                n_idx = ny * width + nx
                if 0 <= nx < width and 0 <= ny < height:
                    adjacency_list[idx].append((n_idx, d))

    goal_state[-1] = 0
    manhattan_distance_table = calc_manhattan_distance_table(width, num_idx, goal_state)
    start_state = []
    for _ in range(height):
        row = list(map(int, f.readline().split()))
        start_state += row

    zero_idx = start_state.index(0)
    max_depth = 45
    min_num_moves = iddfs(num_idx, adjacency_list, manhattan_distance_table, max_depth,
                          start_state, zero_idx, goal_state)

    print(min_num_moves)
    return


if __name__ == '__main__':
    main()

