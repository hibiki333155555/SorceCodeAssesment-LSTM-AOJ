#include <bits/stdc++.h>
using namespace std;
 
#define lli long long int
#define REP(i,s,n) for(int i=s;i<n;i++)
#define INF (1LL<<50)
#define DEBUG 0
#define mp(a,b) make_pair(a,b)
#define SORT(V) sort(V.begin(),V.end())
#define PI (3.141592653589794)
#define TO_STRING(VariableName) # VariableName
#define LOG(x) if(DEBUG)cout<<TO_STRING(x)<<"="<<x<<" "<<endl;
#define LOG2(x,y) if(DEBUG)cout<<TO_STRING(x)<<"="<<x<<" "<<TO_STRING(y)<<"="<<y<<endl;
#define LOG3(x,y,z) if(DEBUG)cout<<TO_STRING(x)<<"="<<x<<" "<<TO_STRING(y)<<"="<<y<<" "<<TO_STRING(z)<<"="<<z<<endl;
#define LOG4(w,x,y,z) if(DEBUG)cout<<TO_STRING(w)<<"="<<w<<" "<<TO_STRING(x)<<"="<<x<<" "<<TO_STRING(y)<<"="<<y<<" "<<TO_STRING(z)<<"="<<z<<endl;
 
template<class T>bool chmax(T & a, const T & b) { if (a < b) { a = b; return 1; } return 0; }
template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }

lli dx[4] = {-1,0,1,0};
lli dy[4] = {0,1,0,-1};

// Generated by 2.11.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
int main(){

    lli h,w,n;
    cin>>h>>w>>n;
    vector<vector<lli> > board(h+10,vector<lli>(w+10,0));

    lli sx,sy,gx,gy;
    cin>>sx>>sy>>gx>>gy;
    sx--;
    sy--;
    gx--;
    gy--;

    REP(i,0,n){
        lli x,y,k;
        cin>>x>>y>>k;
        x--;
        y--;
        queue<lli> qx,qy,qlefK;
        qx.push(x);
        qy.push(y);
        qlefK.push(k);

        board[x][y] = 1;

        while(!qx.empty()){
            lli nowX = qx.front();
            lli nowY = qy.front();
            lli lefK = qlefK.front();
            LOG3(nowX,nowY,lefK);
            qx.pop();
            qy.pop();
            qlefK.pop();

            if(lefK==0)continue;

            REP(j,0,4){
                lli nextX = nowX + dx[j];
                lli nextY = nowY + dy[j];

                if(nextX < 0 || h <= nextX || nextY < 0 || w <= nextY)continue;
                if(board[nextX][nextY]==1)continue;
                board[nextX][nextY] = 1;
                qx.push(nextX);
                qy.push(nextY);
                qlefK.push(lefK-1);
            }
        }
    }

    queue<lli> qx,qy;
    qx.push(sx);
    qy.push(sy);
    board[sx][sy]=1;
    while(!qx.empty()){
        lli nowX = qx.front();
        lli nowY = qy.front();
        LOG2(nowX,nowY);
        if(nowX == gx && nowY == gy){
            cout<<"Yes"<<endl;
            return 0;
        }

        qx.pop();
        qy.pop();
        REP(j,0,4){
            lli nextX = nowX + dx[j];
            lli nextY = nowY + dy[j];
            if(nextX < 0 || h <= nextX || nextY < 0 || w <= nextY)continue;
            if(board[nextX][nextY]==1)continue;
            board[nextX][nextY] = 1;
            qx.push(nextX);
            qy.push(nextY);
        }
    }
    cout<<"No"<<endl;
    return 0;
}

