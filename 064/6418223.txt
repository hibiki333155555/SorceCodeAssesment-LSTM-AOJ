#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <cmath>
#include <iomanip>
#include <stack>
#include <queue>
#include <numeric>
#include <map>
#include <unordered_map>
#include <set>
#include <fstream>
#include <chrono>
#include <random>
#include <bitset>
//#include <atcoder/all>
#define rep(i,n) for(int i=0;i<(n);i++)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define sz(x) ((int)(x).size())
#define pb push_back
using ll = long long;
using namespace std;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
ll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}
ll lcm(ll a, ll b) {return a/gcd(a,b)*b;}

const ll mod = 998244353;

ll mpow(ll a, ll x){
  ll res = 1;
  while(x > 0){
    if(x & 1) res = (res * a) % mod;
    a = (a * a) % mod;
    x >>= 1;
  }
  return res;
}

ll minv(ll x){
  ll res = 1, k = mod - 2;
  while(k){
    if(k&1) res = (res * x) % mod;
    x = (x * x) % mod;
    k >>= 1;
  }
  return res;
}

int isc(char x){
  return 'a'<=x && x<='z';
}
int isd(char x){
  return '0'<=x && x<='9';
}

ll cdtd(char x){
  return (ll)(x-'0');
}

int cctd(char x){
  return (int)(x-'a');
}

pair<ll,int> readnum(const string& s, int idx){
  ll res = 0;
  for(int i=idx;;i++){
    if(!isc(s[i])){
      return {res,i-1};
    }
    res *= 10;
    res += cdtd(s[i]);
    res %= mod;
  }
}

pair<ll,ll> ex(char c, const string& s, int idx, const vector<ll>& v){
  int minusflag = 0;
  pair<ll,ll> res = {0,0};
  for(int i=idx;i<sz(s);i++){
    if(s[i]=='-') minusflag=1;
    else if(s[i]=='+') minusflag=0;
    else if(isc(s[i])){
      if(s[i]==c){
        if(minusflag) res.first--;
        else res.first++;
      }
      else{
        res.second += v[cctd(s[i])]%mod * (minusflag?-1:1);
        res.second += mod * 2;
        res.second %= mod;
      }
    }
    else if(isd(s[i])){
      auto p = readnum(s,i);
      res.second += p.first%mod * (minusflag?-1:1);
      res.second += mod * 2;
      res.second %= mod;
      i = p.second;
    }
  }
  return res;
}


pair<ll,ll> modparen(const string& s,int idx, const vector<ll>& v){
  ll res = 0;
  int minusflag = 0;
  for(int i=idx+1;i<sz(s);i++){
    if(s[i]==')'){
      return {res,i};
    }
    if(s[i]=='-') minusflag=1;
    else if(s[i]=='+') minusflag=0;
    else if(isc(s[i])){
      res+=v[(int)(s[i]-'a')]%mod*(minusflag?-1:1);
      res+=mod*2;
      res%=mod;
    }
    else if(isd(s[i])){
      auto p = readnum(s,i);
      res += p.first%mod * (minusflag?-1:1);
      res += mod*2;
      res %= mod;
      i = p.second;
    }
  }
}

pair<ll,ll> paren(const string& s,int idx, const vector<ll>& v){
  ll md = 1;
  rep(i,9) md*=10;
  md++;
  ll res = 0;
  int minusflag = 0;
  for(int i=idx+1;i<sz(s);i++){
    if(s[i]==')'){
      if(res<0){
        res += abs(res)/md*md;
        res += md*3;
      }
      res %= md;
      return {res,i};
    }
    if(s[i]=='-') minusflag=1;
    else if(s[i]=='+') minusflag=0;
    else if(isc(s[i])){
      res+=v[cctd(s[i])]*(minusflag?-1:1);
      if(res<0){
        res += abs(res)/md*md;
        res += md*3;
      }
      res %= md;
    }
    else if(isd(s[i])){
      auto p = readnum(s,i);
      res += p.first * (minusflag?-1:1);
      if(res<0){
        res += abs(res)/md*md;
        res += md*3;
      }
      res %= md;
      i = p.second;
    }
  }
}

ll f(ll a, pair<ll,ll> asn, ll t){
  if(t==0) return a;
  else if(t==1){
    ll ada=0,adb=0;
    if(a<0 && asn.first>0 || a>0 && asn.first<0){
      ada = mod - (abs(a*asn.first)%mod);
    }
    else ada = a*asn.first%mod;
    if(asn.second<0){
      adb = mod - (asn.second%mod);
    }
    else adb = asn.second%mod;
    return (ada+adb)%mod;
  }
  else{
    if(a<0){
      a = (-(abs(a)%mod)+mod)%mod;
    }
    else a%=mod;
    if(asn.second<0){
      asn.second = (-(abs(asn.second)%mod)+mod)%mod;
    }
    else asn.second %= mod;
    ll ada = (mpow(abs(asn.first),t)*(asn.first<0?-1:1)+mod*2)%mod*(a+mod)%mod;
    ada %= mod;
    ll adb = asn.second * (mpow(((asn.first+mod)+mod-1)%mod,t)) %mod * minv((asn.first+mod+mod-1)%mod) % mod;
    return (ada+adb)%mod;
  }
}

vector<pair<ll,ll>> calc(const vector<string>& P){
  int N = sz(P);
  vector<ll> val(26,-1);
  vector<pair<ll,ll>> OA;
  rep(i,N){
    if(sz(P[i])==1){
      // 変数定義
      char c = P[i][0];
      val[cctd(c)]=0;
    }
    else{
      ll donum = 1;
      for(int j=0;j<sz(P[i]);j++){
        // 代入
        if(j+2<sz(P[i]) && P[i].substr(j+1,2)=="<-"){
          char c = P[i][j];
          int idx = cctd(c);
          pair<ll,ll> asn = ex(c,P[i],j+3,val);
          val[idx] = f(val[idx],asn,donum);
          break;
        }
        // for
        else if(P[i].substr(j,3)=="for"){
          auto p = paren(P[i],j+3,val);
          donum *= p.first;
          j = p.second;
        }
        // print
        else if(P[i].substr(j,5)=="print"){
          auto p = modparen(P[i],j+5,val);
          OA.pb({p.first,donum});
          j = p.second;
        }
      }
    }
  }
  vector<pair<ll,ll>> OA2;
  rep(i,N){
    if(i){
      if(OA[i-1].first==OA[i].first){
        OA2.back().first+=OA[i].second;
      }
      else OA2.pb(OA[i]);
    }
    OA2.pb(OA[i]);
  }
  return OA2;
}

void solve(int N,int M){
  vector<string> PA(N), PB(M);
  rep(i,N) cin >> PA[i];
  rep(i,M) cin >> PB[i];
  auto OA = calc(PA);
  auto OB = calc(PB);
  if(OA==OB) cout << "Yes" << '\n';
  else cout << "No" << '\n';
}

int main(){
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  while(1){
    int N,M; cin >> N >> M;
    if(N==0 && M==0) break;
    solve(N,M);
  }
  return 0;
}

