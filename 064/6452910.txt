#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>;
class extension {
//イテレーター省略
#define all(v) v.begin(),v.end()
//配列の読み取り
#define loadVector(n,v) for (int i = 0;i < n;i++) cin >> v[i]
//pair型配列の読み取り
#define loadVectors(n,v) for (int i = 0;i < n;i++) cin >> v[i].first >> v[i].second
//逆ソート
#define r_sort(v) sort(v.rbegin(),v.rend())
//long long省略
#define ll long long
//指定したkeyがmapに存在するかどうか
#define mapFind(m,x) m.find(x) != end(m)
//long doubleの省略
#define ld long double

//nをbase_number進数に変換する
public:string To_oct(int n, int base_number) {
    string s;
    while (n) {
        s = to_string(n % base_number) + s;
        n /= base_number;
    }
    return s;
}

//エラトステネスの篩
vector<int> Eratosthenes(int N) {
    vector<bool> is_prime(N + 1);
    for (int i = 0; i <= N; i++) is_prime[i] = true;
    vector<int> P;
    for (int i = 2; i <= N; i++)
    {
        if (is_prime[i])
        {
            for (int j = 2 * i; j <= N; j += i)
            {
                is_prime[j] = false;
            }
            P.emplace_back(i);
        }
    }
    return P;
}

//文字列を分割する
vector<string> Split(const string& str, char sep) {
    vector<string> v;
    stringstream ss(str);
    string buffer;
    while(getline(ss, buffer, sep)) {
        v.push_back(buffer);
    }
    return v;
}

//約数全列挙
vector<ll> Divisor(ll n) {
    vector<ll> result;
    set<ll> s;
    for (ll i = 1; i <= sqrt(n); i++) {
        if (n % i == 0) {
            s.insert(i);
            s.insert(n / i);
        }
    }

    for (int x : s) {
        result.push_back(x);
    }
    return result;
}

//連立方程式を解く
pair<int,int> SimultaneousEquations(int a,int b,int c,int d,int e,int f) {
    double matrix;
	matrix = a * e - b*d;

	double x, y;
	if (matrix == 0) {
		cout << "連立方程式の解はありません\n";
		return make_pair(-1,-1);
	}
	else {
		x = (c * e - b * f) / matrix;
		y = (a * f - c * d) / matrix;
		
		if (floor(x) != x || floor(y) != y) return make_pair(-1,-1);
		return make_pair(x,y);
	}
}

//コンビネーション(nCr)
unsigned long long Combination(int n, int r)
{
    if (n < 0 || r < 0 || r > n) cout << "無効な値です" << endl;

    if (n - r < r) r = n - r;
    if (r == 0) return 1;
    if (r == 1) return n;

    vector<int> numerator(r);
    vector<int> denominator(r);

    for (int k = 0; k < r; k++)
    {
        numerator[k] = n - r + k + 1;
        denominator[k] = k + 1;
    }

    for (int p = 2; p <= r; p++)
    {
        int pivot = denominator[p - 1];
        if (pivot > 1)
        {
            int offset = (n - r) % p;
            for (int k = p - 1; k < r; k += p)
            {
                numerator[k - offset] /= pivot;
                denominator[k] /= pivot;
            }
        }
    }

    unsigned long long result = 1;
    for (int k = 0; k < r; k++)
    {
        if (numerator[k] > 1) result *= numerator[k];
    }

    return result;
}
};

//Union-Find
struct UnionFind {
    vector<int> par, rank, siz;

    // 構造体の初期化
    UnionFind(int n) : par(n,-1), rank(n,0), siz(n,1) { }

    // 根を求める
    int root(int x) {
        if (par[x]==-1) return x; // x が根の場合は x を返す
        else return par[x] = root(par[x]); // 経路圧縮
    }

    // x と y が同じグループに属するか (= 根が一致するか)
    bool issame(int x, int y) {
        return root(x)==root(y);
    }

    // x を含むグループと y を含むグループを併合する
    bool unite(int x, int y) {
        int rx = root(x), ry = root(y); // x 側と y 側の根を取得する
        if (rx==ry) return false; // すでに同じグループのときは何もしない
        // union by rank
        if (rank[rx]<rank[ry]) swap(rx, ry); // ry 側の rank が小さくなるようにする
        par[ry] = rx; // ry を rx の子とする
        if (rank[rx]==rank[ry]) rank[rx]++; // rx 側の rank を調整する
        siz[rx] += siz[ry]; // rx 側の siz を調整する
        return true;
    }

    // x を含む根付き木のサイズを求める
    int size(int x) {
        return siz[root(x)];
    }
};

struct Edge {
  int to = 0;
  int cost = 0;
  
  void SetEdge(int _to,int _cost) {
      to = _to;
      cost = _cost;
  }
  
  void Output() {
      cout << to << " " << cost << endl;
  }
};

int main(void) {
    // Your code here!
    cin.tie(nullptr);
    ios::sync_with_stdio(false);

    //拡張クラスのインスタンス化
    extension ex = extension();
    
    ////////ここから処理内容記述/////////////
    int v,e,r;
    cin >> v >> e >> r;
    
    vector<vector<Edge>> g(v);
    for (int i = 0;i < e;i++) {
        int s,t,d;
        cin >> s >> t >> d;
        
        Edge _e = Edge();
        _e.SetEdge(t,d);
        g[s].push_back(_e);
    }
    
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> que;
    vector<int> dist(v,1e9);
    
    //開始地点を設定する
    dist[r] = 0;
    //r地点を移動距離0に設定
    que.push(make_pair(0,r));
    
    while (!que.empty()) {
        pair<int,int> nowPos = que.top();
        que.pop();
        
        for (auto x : g[nowPos.second]) {
            if (dist[x.to] > dist[nowPos.second]+x.cost) {
                dist[x.to] = dist[nowPos.second]+x.cost;
                que.push(make_pair(dist[x.to],x.to));
            }
        }
    }
    
    for (int i = 0;i < v;i++) {
        if (dist[i] == 1e9) cout << "INF" << endl;
        else cout << dist[i] << endl;
    }
}
