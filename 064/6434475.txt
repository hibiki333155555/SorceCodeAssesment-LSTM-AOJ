#include <bits/stdc++.h>

template <class T, class M>
class segment_tree
{
private:
    M INS_M;
    std::vector<std::pair<std::size_t, std::size_t>> range;
    std::size_t LEAF;
    std::vector<T> data;

    void full_update(void)
    {
        for (std::size_t i = LEAF - 2; i != static_cast<std::size_t>(-1); --i)
        {
            data[i] = INS_M(data[2 * (i + 1) - 1], data[2 * (i + 1)]);
        }
    }

    void point_update(const std::size_t& i)
    {
        if (i != 0)
        {
            const std::size_t ip = (i + 1) / 2 - 1;
            const std::size_t in = 4 * (ip + 1) - 1 - i;
            data[ip] = INS_M(data[in], data[i]);
            point_update(ip);
        }
    }

    T get_kernel(const std::size_t& ii, const std::size_t& jj, const std::size_t& inow) const
    {
        if (ii >= jj)
        {
            return INS_M.e;
        }
        else if (const auto& [iinow, jjnow] = range[inow]; iinow == ii && jjnow == jj)
        {
            return data[inow];
        }
        else
        {
            const std::size_t ic1 = 2 * (inow + 1) - 1;
            const std::size_t ic2 = 2 * (inow + 1);
            const std::size_t mid = range[ic1].second;
            return INS_M(get_kernel(ii, std::min({ jj, mid }), ic1), get_kernel(std::max({ ii, mid }), jj, ic2));
        }
    }

public:
    segment_tree(void) = default;
    segment_tree(const segment_tree&) = default;
    segment_tree(segment_tree&&) noexcept = default;
    segment_tree& operator=(const segment_tree&) & = default;
    segment_tree& operator=(segment_tree&&) & noexcept = default;

    explicit segment_tree(const std::size_t& n_elem)
    {
        assert(n_elem > 0);
        const int k = CHAR_BIT * sizeof(n_elem)
            - __builtin_clzll(static_cast<unsigned long long>(n_elem));
        LEAF = 1LL << k;
        if (LEAF < n_elem)
        {
            LEAF <<= 1;
        }
        range.resize(2 * LEAF - 1);
        data.resize(2 * LEAF - 1, INS_M.e);
        for (std::size_t ii = 0; ii < LEAF; ++ii)
        {
            range[LEAF + ii - 1] = { ii, ii + 1 };
        }
        for (std::size_t i = LEAF - 2; i != static_cast<std::size_t>(-1); --i)
        {
            range[i] = { range[2 * (i + 1) - 1].first, range[2 * (i + 1)].second };
        }
    }

    explicit segment_tree(const std::vector<T>& init)
    {
        std::copy(init.begin(), init.end(), data.begin() + LEAF - 1);
        full_update();
    }

    T get(const std::size_t& ii, const std::size_t& jj) const
    {
        assert(ii < jj);
        assert(jj <= LEAF);
        return get_kernel(ii, jj, 0);
    }

    void set(const std::size_t& ii, const T& val)
    {
        assert(ii < LEAF);
        data[LEAF + ii - 1] = val;
        point_update(LEAF + ii - 1);
    }

    const T& operator[](const std::size_t& ii) const
    {
        assert(ii < LEAF);
        return data[LEAF + ii - 1];
    }
};

class min_object
{
public:
    unsigned e;

    min_object(void)
        : e((1U << 31) - 1)
    {
    }

    unsigned operator()(const unsigned& i, const unsigned& j) const
    {
        return std::min({ i, j });
    }
};

int main(void)
{
    unsigned n, q;
    std::cin >> n >> q;
    segment_tree<unsigned, min_object> tree(n);
    for (unsigned i = 0; i < q; ++i)
    {
        unsigned c, x, y;
        std::cin >> c >> x >> y;
        if (c == 0)
        {
            tree.set(x, y);
        }
        else
        {
            std::cout << tree.get(x, y + 1) << std::endl;
        }
    }
    return 0;
}
