//cf非递归线段树，含懒标记

#include <bits/stdc++.h>
using namespace std;
const int inf = 0x7fffffff;
vector<vector<int>> seg;
vector<vector<int>> a;
int r, c, m;
int read() {
    int f = 1, x = 0;
    char p = getchar();
    while(p < '0' || p > '9') {
        if(p == '-') f = -1;
        p = getchar();
    }
    while(p >= '0' && p <= '9') {
        x = (x << 3) + (x << 1) + (p & 15);
        p = getchar();
    }
    return f * x;
}
inline int ls(int i) {
    return i << 1;
}
inline int rs(int i) {
    return i << 1 | 1;
}
bool trans;
void build(int row) {
    int n = (trans ? r : c);
    seg[row].reserve(2 * n);
    for(int i = n; i < 2 * n; ++i) seg[row][i] = (trans ? a[i - n][row] : a[row][i - n]);
    for(int i = n - 1; i > 0; --i) seg[row][i] = min(seg[row][ls(i)], seg[row][rs(i)]);
}
int query(int row, int l, int _r) {
    int ans = inf;
    int n = (trans ? r : c);
    for(l += n, _r += n; l < _r; l >>= 1, _r >>= 1) {
        if(l & 1) ans = min(ans, seg[row][l++]);
        if(_r & 1) ans = min(ans, seg[row][--_r]);
    }
    return ans;
}
int main() {
    while(scanf("%d%d%d", &r, &c, &m), r | c | m) {
        seg = vector<vector<int>>(min(r, c), vector<int>());
        a = vector<vector<int>>(r, vector<int>(c));
        trans = r > c;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) a[i][j] = read();
        for(int i = 0; i < (trans ? c : r); ++i) build(i);
        while(m--) {
            int r1 = read(), c1 = read(), r2 = read(), c2 = read();
            int ans = inf;
            if(trans) {
                swap(r1, c1);
                swap(r2, c2);
            }
            for(int i = r1; i <= r2; ++i) {
                ans = min(ans, query(i, c1, c2 + 1));
            }
            printf("%d\n", ans);
        }
    }
}
/*
3 3 4
1 2 3
4 2 2
2 1 1
0 0 2 2
0 0 1 1
1 0 1 0
0 1 1 2
1 10 4
1 2 3 4 5 6 7 8 9 10
0 0 0 9
0 0 0 4
0 5 0 9
0 4 0 5
0 0 0

4 3 4
1 2 3
4 2 2
2 1 1
3 2 1
0 0 3 2
0 0 1 1
1 0 1 0
0 1 3 2
0 0 0


*/
