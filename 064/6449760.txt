#include <iostream>
#include <vector>
#include <bitset>
#include <algorithm>

using namespace std;

struct edge {
    int to;
    bitset<12> bit;
};

using ll = long long;
const vector<int> factor{2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19};
const ll INF = 1LL << 60;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<edge>> graph(n);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c, a--, b--;

        bitset<12> bit;
        for (int i = 0; i < 12; i++) {
            if (c % factor[i] == 0)bit[i] = true;
        }

        graph[a].push_back({b, bit});
    }

    vector<vector<bool>> dp(n, vector<bool>(1 << 12));
    dp[0][0] = true;
    vector<pair<int, bitset<12>>> que;
    {
        bitset<12> tmp;
        que.emplace_back(0, tmp);
    }

    while (!que.empty()) {
        auto now = que.back();
        que.pop_back();

        auto here = now.first;
        auto bit = now.second;
        for (auto next: graph[here]) {
            auto nextBit = bit | next.bit;
            if (!dp[next.to][nextBit.to_ulong()]) {
                dp[next.to][nextBit.to_ulong()] = true;
                que.emplace_back(next.to, nextBit);
            }
        }
    }

    ll mi = INF, ma = -INF;
    for (int i = 0; i < 1 << 12; i++) {
        if (!dp[n - 1][i])continue;

        ll now = 1;
        if (i & (1 << 3))now *= 2 << 3;
        else if (i & (1 << 2))now *= 2 << 2;
        else if (i & (1 << 1))now *= 2 << 1;
        else if (i & (1 << 0))now *= 2 << 0;

        if (i & (1 << 5))now *= 3 * 3;
        else if (i & (1 << 4))now *= 3;

        for (int j = 6; j < 12; j++) {
            if (i & (1 << j))now *= factor[j];
        }

        mi = min(mi, now), ma = max(ma, now);
    }

    if (mi == INF && ma == -INF)cout << "IMPOSSIBLE" << endl;
    else cout << mi << " " << ma << endl;
    return 0;
}
