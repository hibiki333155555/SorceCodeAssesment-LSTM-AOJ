#!usr/bin/env python3
from collections import defaultdict, deque
from heapq import heappush, heappop
from itertools import permutations, accumulate
import sys
import math
import bisect
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def IR(n):
    return [I() for _ in range(n)]
def LIR(n):
    return [LI() for _ in range(n)]

import typing

sys.setrecursionlimit(1000000)

mod = 998244353

"""
convolve
copy from: https://atcoder.jp/contests/abc196/submissions/21171121
"""

primitive_root = 3
roots = [pow(primitive_root, (mod-1)>>i, mod) for i in range(24)]
inv_roots = [pow(root, mod-2, mod) for root in roots]
 
def ntt(A, n):
    for i in range(n):
        m = 1<<(n-i-1)
        for s in range(1<<i):
            w = 1
            s *= m*2
            for j in range(m):
                A[s+j], A[s+j+m] = (A[s+j]+A[s+j+m])%mod, (A[s+j]-A[s+j+m])*w%mod
                w *= roots[n-i]
                w %= mod
 
def intt(A, n):
    for i in range(n):
        m = 1<<i
        for s in range(1<<(n-i-1)):
            w = 1
            s *= m*2
            for j in range(m):
                A[s+j], A[s+j+m] = (A[s+j]+A[s+j+m]*w)%mod, (A[s+j]-A[s+j+m]*w)%mod
                w *= inv_roots[i+1]
                w %= mod
    inv = pow((mod+1)//2, n, mod)
    for i in range(1<<n):
        A[i] *= inv
        A[i] %= mod

def convolution(A, B):
    la = len(A)
    lb = len(B)
    deg = la + lb - 2
    n = deg.bit_length()
    N = 1<<n
    A += [0]*(N-la)
    B += [0]*(N-lb)
    ntt(A, n)
    ntt(B, n)
    A = [a*b%mod for a, b in zip(A, B)]
    intt(A, n)
    return A[:deg+1]

from functools import lru_cache

def main():
    @lru_cache(None)
    def dfs(x):
        ax = a[x]
        sx = s[x]
        if sx <= k:
            dp = [1]
            k_ = k-sx+1
            for y in v[x]:
                dpy = dfs(y)
                if len(dpy) == 1:
                    continue
                dp = convolution(dp,dfs(y))[:k_]
            dp = [0]*ax+dp
            dp[0] = 1
            return dp
        else:
            return [1]

    n,k = LI()
    a = LI()
    p = LI()
    # n = I()
    # k = n>>1
    # a = [1]*n
    # p = [1]*(n-1)
    s = a[:]
    v = [[] for _ in range(n)]
    for i,pi in enumerate(p,1):
        v[pi-1].append(i)
    q = deque([0])
    while q:
        x = q.popleft()
        sx = s[x]
        for y in v[x]:
            s[y] += sx
            q.append(y)
    if sum(a) < k:
        ans = 0
    else:
        ans = dfs(0)[k]
    print(ans)
    return


if __name__ == "__main__":
    main()

