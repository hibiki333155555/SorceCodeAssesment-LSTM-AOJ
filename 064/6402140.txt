import sys 
# from statistics import *
# from operator import add
# import collections
import math
#import numpy
#import itertools

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
input = lambda: sys.stdin.readline().rstrip()

def dist(x, y, p):
    sm = 0
    for x, y in zip(x, y):
        sm += abs(x -y)**p
    return sm**(1/p)

class Dice:
    def __init__(self, T, S, E, W, N, B):
        self.E = E
        self.W = W
        self.N = N
        self.S = S
        self.T = T
        self.B = B
    
    def West(self):
        t= self.W
        self.W = self.T
        self.T=self.E
        self.E=self.B
        self.B=t
    
    def East(self):
        self.T, self.B, self.W, self.E = self.W, self.E, self.B, self.T
    
    def North(self):
        t=self.N
        self.N=self.T
        self.T=self.S
        self.S=self.B
        self.B=t
    
    def South(self):
        t=self.S
        self.S=self.T
        self.T=self.N 
        self.N=self.B 
        self.B=t        
    
    def top(self):
        return self.T

def main():
    #a,  n= tuple(map(int, read().split()))
    #r = float(read().split()[0])
    #a = [list(map(int, input().split())) for _ in range(n)]
    #for i in sys.stdin: #for i in iter(input, '0'):
    #*a, = map(int, input().split())

    a = list(map(int, input().split()))
    ds = Dice(a[0], a[1], a[2], a[3], a[4], a[5])
    b = list(map(int, input().split()))
    
    if b[1] == ds.W or b[1] == ds.E:
        ds.West()
    for i in range(3):
        if b[1] == ds.S:
           break
        ds.South()
    for i in range(3):
        if b[0] == ds.T:
            break
        ds.West()

    if b[0] == ds.T and b[1] == ds.S and b[2] == ds.E and b[3] == ds.W:
         print("Yes")
    else:
        print("No")
   
    #print("%.10f" %dc)
    #dc = max(abs(x - y) for x, y in zip(x, y))
    #sd = (sum((mn - x)**2 for x in a) / n)**0.5
    #print(f'{sd: .10f}')
    #math.sqrt(a**2 + math.cos(rd))
    #math.radians(deg)  #abs(complex(x, y)  #math.hypot(x, y)
    #print(*s[a:b+1], sep='')
    #s = s[h:] + s[:h]
    #if p in ss: #if ss.find(p) != -1:
    #otp = [[0]*(n+1)]*(r+1)xxx
    #p = [[0 for _ in range(l)] for _ in range(n)]
    #cnt = sum([1 for i,j,k in itertools.combinations(range(1,n+1),3) if i+j+k==x])
    #otp.append(cnt)
    #opt = mode(dl) #opt = max(dl, key = dl.count)
    #cntDc = collections.Counter(dl)
    #opt = cntDc.most_common()[0][0]
    #print(' '.join(map(str, r)))
    #print("%d "%p[i][j], end='')
    #print(*otp, sep = "\n")

main()

