#include "bits/stdc++.h"
#include <random>
#include <chrono>
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define SZ(x) ((lint)(x).size())
#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;++i)
#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;--i)
#define REP(i, n) FOR(i,0,n)
#define IREP(i, n) IFOR(i,0,n)
#define endk '\n'
using namespace std; typedef unsigned long long _ulong; typedef long long int lint; typedef long double ld; typedef pair<lint, lint> plint; typedef pair<ld, ld> pld;
struct fast_ios { fast_ios() { cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10); }; } fast_ios_;
template<class T> auto add = [](T a, T b) -> T { return a + b; };
template<class T> auto mul = [](T a, T b) -> T { return a * b; };
template<class T> auto f_max = [](T a, T b) -> T { return max(a, b); };
template<class T> auto f_min = [](T a, T b) -> T { return min(a, b); };
template<class T> using V = vector<T>;
using Vl = V<lint>; using VVl = V<Vl>; using VVVl = V<V<Vl>>;
template< typename T > ostream& operator<<(ostream& os, const vector< T >& v) {
	for (int i = 0; i < (int)v.size(); i++) os << v[i] << (i + 1 != v.size() ? " " : "");
	return os;
}
template< typename T >istream& operator>>(istream& is, vector< T >& v) {
	for (T& in : v) is >> in;
	return is;
}
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
template <class T>
T div_floor(T a, T b) {
	if (b < 0) a *= -1, b *= -1;
	return a >= 0 ? a / b : (a + 1) / b - 1;
}
template <class T>
T div_ceil(T a, T b) {
	if (b < 0) a *= -1, b *= -1;
	return a > 0 ? (a - 1) / b + 1 : a / b;
}
template <class F> struct rec {
	F f;
	rec(F&& f_) : f(std::forward<F>(f_)) {}
	template <class... Args> auto operator()(Args &&... args) const {
		return f(*this, std::forward<Args>(args)...);
	}
};
lint gcd(lint a, lint b) { if (b == 0) return a; else return gcd(b, a % b); }
lint digit(lint a) { return (lint)log10(a); }
lint e_dist(plint a, plint b) { return abs(a.first - b.first) * abs(a.first - b.first) + abs(a.second - b.second) * abs(a.second - b.second); }
lint m_dist(plint a, plint b) { return abs(a.first - b.first) + abs(a.second - b.second); }
bool check_overflow(lint a, lint b, lint limit) { if (b == 0) return false; return a >= limit / b; } // a * b > c => true
void Worshall_Floyd(VVl& g) { REP(k, SZ(g)) REP(i, SZ(g)) REP(j, SZ(g)) chmin(g[i][j], g[i][k] + g[k][j]); }
const lint MOD1000000007 = 1000000007, MOD998244353 = 998244353, INF = 2e18;
lint dx[8] = { 0, -1, 0, 1, 1, -1, 1, -1 }, dy[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };
bool YN(bool flag) { cout << (flag ? "YES" : "NO") << endk; return flag; } bool yn(bool flag) { cout << (flag ? "Yes" : "No") << endk; return flag; }
struct Edge {
	lint from, to;
	lint cost, t;
	Edge() {

	}
	Edge(lint u, lint v, lint c, lint _t) {
		cost = c;
		from = u;
		to = v;
		t = _t;
	}
	bool operator<(const Edge& e) const {
		return cost < e.cost;
	}
};
struct WeightedEdge {
	lint to;
	lint cost;
	WeightedEdge(lint v, lint c) {
		to = v;
		cost = c;
	}
	bool operator<(const WeightedEdge& e) const {
		return cost < e.cost;
	}
};
using WeightedGraph = V<V<WeightedEdge>>;
typedef pair<lint, plint> tlint;
typedef pair<ld, ld> pld;
typedef pair<plint, plint> qlint;
typedef pair<lint, string> valstr;
typedef pair<Vl, lint> valv;


template <std::int_fast64_t Modulus>
class modint
{
	using u64 = std::int_fast64_t;

public:
	u64 a;
	constexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}
	constexpr u64& value() noexcept { return a; }
	constexpr const u64& value() const noexcept { return a; }
	constexpr modint operator+(const modint rhs) const noexcept
	{
		return modint(*this) += rhs;
	}
	constexpr modint operator-(const modint rhs) const noexcept
	{
		return modint(*this) -= rhs;
	}
	constexpr modint operator*(const modint rhs) const noexcept
	{
		return modint(*this) *= rhs;
	}
	constexpr modint operator/(const modint rhs) const noexcept
	{
		return modint(*this) /= rhs;
	}
	constexpr modint& operator+=(const modint rhs) noexcept
	{
		a += rhs.a;
		if (a >= Modulus)
		{
			a -= Modulus;
		}
		return *this;
	}
	constexpr modint& operator-=(const modint rhs) noexcept
	{
		if (a < rhs.a)
		{
			a += Modulus;
		}
		a -= rhs.a;
		return *this;
	}
	constexpr modint& operator*=(const modint rhs) noexcept
	{
		a = a * rhs.a % Modulus;
		return *this;
	}
	constexpr modint& operator/=(modint rhs) noexcept
	{
		u64 exp = Modulus - 2;
		while (exp)
		{
			if (exp % 2)
			{
				*this *= rhs;
			}
			rhs *= rhs;
			exp /= 2;
		}
		return *this;
	}
};
typedef modint<MOD998244353> ModInt;

ModInt mod_pow(ModInt x, lint n) {
	ModInt ret = 1;
	while (n > 0) {
		if (n & 1) (ret *= x);
		(x *= x);
		n >>= 1;
	}
	return ret;
}

ModInt func[200000];
void funcinit(int N)
{
	func[0] = 1;
	for (int i = 1; i <= N; i++)
	{
		func[i] = func[i - 1] * i;
	}
}
ModInt comb(ModInt n, ModInt r)
{
	if (n.a <= 0 || n.a < r.a)
	{
		return 1;
	}
	return func[n.a] / (func[r.a] * func[(n - r).a]);
}

struct Rerooting {
	V<V<ModInt>> dp;
	VVl to;
	V<map<lint, lint>> ref;
	V<ModInt> ans;
	Rerooting(lint sz) {
		dp.resize(sz);
		ref.resize(sz);
		to.resize(sz);
		ans.resize(sz);
	}

	void add_edge(int u, int v) {
		ref[u][v] = SZ(to[u]);
		to[u].push_back(v);
		ref[v][u] = SZ(to[v]);
		to[v].push_back(u);
	}

	void build() {
		dfs(1);
		dfs2(0, 0);
	}

	ModInt dfs(lint curr, lint prv = -1) {
		ModInt sum = 1;
		lint deg = SZ(to[curr]);
		dp[curr] = V<ModInt>(deg, 0);
		REP(i, deg) {
			lint nxt = to[curr][i];
			if (nxt == prv) continue;
			dp[curr][i] = dfs(nxt, curr);
			sum += dp[curr][i] * 2;
		}
		return sum;
	}

	void dfs2(lint curr, ModInt score, lint prv = -1) {
		lint deg = SZ(to[curr]);
		REP(i, deg) {
			if (to[curr][i] == prv) dp[curr][i] = score;
		}
		V<ModInt> dp_l(deg + 1, 0), dp_r(deg + 1, 0);
		REP(i, deg) {
			dp_l[i + 1] = dp_l[i] + dp[curr][i];
		}
		IREP(i, deg) {
			dp_r[i] = dp_r[i + 1] + dp[curr][i];
		}
		ModInt sum = 1;
		REP(i, deg) {
			lint nxt = to[curr][i];
			if (nxt == prv) continue;
			dfs2(nxt, (dp_l[i] + dp_r[i + 1]) * 2 + 1, curr);
		}
	}

	ModInt get(int u, int p) {
		return dp[p][ref[p][u]];
	}
};

template< typename G >
struct DoublingLowestCommonAncestor {
	int LOG = 2;
	vector< int > dep;
	const G& g;
	vector< vector< int > > table;

	DoublingLowestCommonAncestor(const G& g) : g(g), dep(g.size()) {
		int curr = 1;
		while (curr < g.size()) {
			curr *= 2;
			LOG++;
		}
		table.assign(LOG, vector< int >(g.size(), -1));
	}

	void dfs(int idx, int par, int d) {
		table[0][idx] = par;
		dep[idx] = d;
		for (auto& to : g[idx]) {
			if (to != par) dfs(to, idx, d + 1);
		}
	}

	void build() {
		dfs(0, -1, 0);
		for (int k = 0; k + 1 < LOG; k++) {
			for (int i = 0; i < table[k].size(); i++) {
				if (table[k][i] == -1) table[k + 1][i] = -1;
				else table[k + 1][i] = table[k][table[k][i]];
			}
		}
	}

	int query(int u, int v) {
		if (dep[u] > dep[v]) swap(u, v);
		for (int i = LOG - 1; i >= 0; i--) {
			if (((dep[v] - dep[u]) >> i) & 1) v = table[i][v];
		}
		if (u == v) return u;
		for (int i = LOG - 1; i >= 0; i--) {
			if (table[i][u] != table[i][v]) {
				u = table[i][u];
				v = table[i][v];
			}
		}
		return table[0][u];
	}

	int _query(int k, int64_t t)
	{
		for (int i = LOG - 1; i >= 0; i--) {
			if ((t >> i) & 1) k = table[i][k];
		}
		return k;
	}
};

int main() {
	lint N;
	cin >> N;
	VVl to(N);
	Rerooting dp(N);
	REP(i, N - 1) {
		lint u, v;
		cin >> u >> v; u--; v--;
		to[u].push_back(v);
		to[v].push_back(u);
		dp.add_edge(u, v);
	}

	dp.build();

	DoublingLowestCommonAncestor lca(to);
	lca.build();

	auto getd = [&](lint u, lint v) {
		return lca.dep[u] + lca.dep[v] - 2 * lca.dep[lca.query(u, v)];
	};

	auto step = [&](lint x, lint y) {
		lint _lca = lca.query(x, y);
		if (x == _lca) {
			return lca._query(y, getd(x, y) - 1);
		}
		else {
			return lca._query(x, 1);
		}
	};

	lint Q;
	cin >> Q;
	REP(i, Q) {
		lint x, y;
		cin >> x >> y; x--; y--;
		ModInt ans = mod_pow(2, getd(x, y));
		ans *= dp.get(x, step(x, y));
		ans *= dp.get(y, step(y, x));
		cout << ans.a << endk;
	}
}
