#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <cmath>
#include <climits>
#include <stdio.h>
using namespace std;
#define EPS (1e-10)
#define equals(a, b) (fabs((a) - (b)) < EPS)

// 点
class Point {
public:
    double x, y;

    Point(double x = 0, double y = 0): x(x), y(y) {}

    Point operator + (Point p) { return Point(x + p.x, y + p.y); }
    Point operator - (Point p) { return Point(x - p.x, y - p.y); }
    Point operator * (double a) { return Point(a * x, a * y); }
    Point operator / (double a) { return Point(x / a, y / a); }

    // ノルム
    double norm() { return x * x + y * y; }

    // ベクトルの大きさ
    double abs() { return sqrt(norm()); }

    bool operator < (const Point &p) const {
        return x != p.x ? x < p.x : y < p.y;
    }

    bool operator == (const Point &p) const {
        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;
    }
};
// ベクトル
typedef Point Vector;
// 多角形
typedef vector<Point> Polygon;

// 線分
class Segment {
public:
    Point p1, p2;

    Segment(Point p1, Point p2): p1(p1), p2(p2) {}
};
// 直線
typedef Segment Line;

// 円
class Circle {
public:
    Point p;
    double r;
    Circle(Point p = Point(), double r = 0.0): p(p), r(r) {}
};

// 内積
double dot(Vector a, Vector b) {
    return a.x * b.x + a.y * b.y;
}

// 外積
double cross(Vector a, Vector b) {
    return a.x * b.y - a.y * b.x;
}

// 直行判定
bool isOrthogonal(Vector a, Vector b) {
    return equals(dot(a, b), 0.0);
}
bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {
    return isOrthogonal(a1-a2, b1-b2);
}

// 平行判定
bool isParallel(Vector a, Vector b) {
    return equals(cross(a, b), 0.0);
}
bool isParallel(Point a1, Point a2, Point b1, Point b2) {
    return isParallel(a1-a2, b1-b2);
}

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE         = -1;
static const int ONLINE_BACK       = 2;
static const int ONLINE_FRONT      = -2;
static const int ON_SEGMENT        = 0;

// 位置関係判定
int positionalRelationship(Point p1, Point p2, Point p3) {
    Vector a = p2 - p1;
    Vector b = p3 - p1;

    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;
    if (cross(a, b) < -EPS) return CLOCKWISE;
    if (dot(a, b) < -EPS) return ONLINE_BACK;
    if (a.norm() < b.norm()) return ONLINE_FRONT;

    return ON_SEGMENT;
}

// 交差判定
bool isIntersect(Point a1, Point a2, Point b1, Point b2) {
    return (
            positionalRelationship(a1, a2, b1) * positionalRelationship(a1, a2, b2) <= 0
            &&
            positionalRelationship(b1, b2, a1) * positionalRelationship(b1, b2, a2) <= 0
    );
}
bool isIntersect(Segment s1, Segment s2) {
    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);
}

// 射影
Point project(Segment s, Point p) {
    Vector base = s.p2 - s.p1;
    double r = dot(p - s.p1, base) / base.norm();
    return s.p1 + base * r;
}

// 反射
Point reflect(Segment s, Point p) {
    return p + (project(s, p) - p) * 2.0;
}

// 距離
double getDistance(Point p1, Point p2) {
    return (p1 - p2).abs();
}
double getDistanceLtoP(Line l, Point p) {
    return abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()));
}
double getDistanceStoP(Segment s, Point p) {
    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();
    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();
    return getDistanceLtoP(s, p);
}
double getDistance(Segment s1, Segment s2) {
    if (isIntersect(s1, s2)) return 0.0;
    return min(
            min(getDistanceStoP(s1, s2.p1), getDistanceStoP(s1, s2.p2)),
            min(getDistanceStoP(s2, s1.p1), getDistanceStoP(s2, s1.p2))
    );
}

double arg(Vector p) { return atan2(p.y, p.x); }
Vector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }

// 交点
Point getCrossPoint(Segment s1, Segment s2) {
    Vector base = s2.p2 - s2.p1;
    double d1 = abs(cross(base, s1.p1 - s2.p1));
    double d2 = abs(cross(base, s1.p2 - s2.p1));
    double t = d1 / (d1 + d2);
    return s1.p1 + (s1.p2 - s1.p1) * t;
}
pair<Point, Point> getCrossPoints(Circle c, Line l) {
    Vector pr = project(l, c.p);
    Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();
    double base = sqrt(c.r * c.r - (pr - c.p).norm());
    return make_pair(pr + e * base, pr - e * base);
}
pair<Point, Point> getCrossPoints(Circle c1, Circle c2) {
    double d = (c1.p - c2.p).abs();
    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
    double t = arg(c2.p - c1.p);
    return make_pair(c1.p + polar(c1.r, t + a), c1.p + polar(c1.r , t - a));
}

// 点の内包判定
int contains(Polygon g, Point p) {
    int n = g.size();
    bool x = false;
    for (int i = 0; i < n; ++i) {
        Point a = g[i] - p;
        Point b = g[(i + 1) % n] - p;
        if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;
        if (a.y > b.y) swap(a, b);
        if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;
    }
    return (x ? 2 : 0);
}

// アンドリューのアルゴリズム
Polygon andrewScan(Polygon s) {
    if (s.size() < 3) return s;

    Polygon u, l;
    // x, yを基準に昇順にソート
    sort(s.begin(), s.end());
    // xが小さいものから2つuに追加
    u.push_back(s[0]);
    u.push_back(s[1]);
    // xが大きいものから2つlに追加
    l.push_back(s[s.size() - 1]);
    l.push_back(s[s.size() - 2]);

    // 凸包の上部を生成
    for (int i = 2; i < s.size(); ++i) {
        for (int j = u.size(); j >= 2 && positionalRelationship(u[j-2], u[j-1], s[i]) == COUNTER_CLOCKWISE; --j) {
            u.pop_back();
        }
        u.push_back(s[i]);
    }

    // 凸包の下部を生成
    for (int i = s.size()-3; i >= 0; --i) {
        for (int j = l.size(); j >= 2 && positionalRelationship(l[j-2], l[j-1], s[i]) == COUNTER_CLOCKWISE; --j) {
            l.pop_back();
        }
        l.push_back(s[i]);
    }

    // 時計回りになるように凸包の点の列を生成
    reverse(l.begin(), l.end());

    for (int i = u.size()-2; i >= 1 ; --i) {
        l.push_back(u[i]);
    }

    return l;
}

// 端点の種類
static const int BOTTOM = 0;
static const int LEFT   = 1;
static const int RIGHT  = 2;
static const int TOP    = 3;

// 端点
class EndPoint {
public:
    Point p;
    // 入力線分のID、端点の種類
    int seg, st;
    EndPoint() {}
    EndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}

    bool operator < (const EndPoint &ep) const {
        // y座標が小さい順に整列
        if (p.y == ep.p.y) {
            // yが同一の場合は、下端点、左端点、右端点、上端点の順に調べる
            return st < ep.st;
        }
        else {
            return p.y < ep.p.y;
        }
    }
};

// 端点のリスト
EndPoint EP[2 * 100000];

// 線分交差問題：マンハッタン幾何
int manhattanIntersection(vector<Segment> S) {
    int n = S.size();

    for (int i = 0, k = 0; i < n; ++i) {
        // 端点p1,p2が左下を基準に並ぶように調整
        if (S[i].p1.y == S[i].p2.y) {
            if (S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);
        }
        else if (S[i].p1.y > S[i].p2.y) {
            swap(S[i].p1, S[i].p2);
        }

        // 水平線分を端点リストに追加
        if (S[i].p1.y == S[i].p2.y) {
            EP[k++] = EndPoint(S[i].p1, i, LEFT);
            EP[k++] = EndPoint(S[i].p2, i, RIGHT);
        }
        // 垂直線分を端点リストに追加
        else {
            EP[k++] = EndPoint(S[i].p1, i, BOTTOM);
            EP[k++] = EndPoint(S[i].p2, i, TOP);
        }
    }

    // 端点のy座標に関して昇順に整列
    sort(EP, EP + (2 * n));

    // 二分探索木
    set<int> BT;
    // 番兵を設置
    BT.insert(INT_MAX);

    int cnt = 0;
    for (int i = 0; i < 2 * n; ++i) {
        if (EP[i].st == TOP) {
            // 上端点を削除
            BT.erase(EP[i].p.x);
        }
        else if (EP[i].st == BOTTOM) {
            // 下端点を追加
            BT.insert(EP[i].p.x);
        }
        else if (EP[i].st == LEFT) {
            // O(log n)
            set<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);
            // O(log n)
            set<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);
            // O(k), bとeの距離（点の数）を加算
            cnt += distance(b, e);
        }
    }

    return cnt;
}

int main() {
    int n;
    cin >> n;

    int x1, x2;
    int y1, y2;
    vector<Segment> S;
    for (int i = 0; i < n; ++i) {
        cin >> x1 >> y1 >> x2 >> y2;

        Point p1 = Point(x1, y1);
        Point p2 = Point(x2, y2);

        S.push_back(Segment(p1, p2));
    }

    cout << manhattanIntersection(S) << endl;
}
