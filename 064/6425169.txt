#include<bits/stdc++.h>
using namespace std;
using LL = long long int;
using LD = long double;

#define rep(i, n) for(LL i = 0; i<n; i++)
#define repl(i, l, n) for(LL i=(l); i<(n); i++)
#define per(i,n) for(LL i=(n)-1;i>=0;i--)
#define perl(i,r,l) for(LL i=r-1;i>=l;i--)

template<class T> void Out( T O ){ cout << O << endl; }
template<class T1, class T2> void OOut( T1 O1, T2 O2  ){ cout << O1 << ' ' << O2 << endl; }
template<class T> void FixedOut( int n, T O ){ cout << fixed << setprecision(n) << O << endl; }
template<class T> int Digit( T num ){ return to_string(num).length(); }
template<typename T1, typename T2, typename T3, typename T4> double L2( T1 ax, T2 ay, T3 bx, T4 by){
    double dx = bx - ax;
    double dy = by - ay;
    return pow( dx * dx + dy * dy, 0.5);
}
int L1( int ax, int ay, int bx, int by ){
    return abs(ax - bx) + abs(ay - by);
}
template<class T> bool chmax(T& a, T b){
    if( a < b ){ a = b; return true; }
    else{ return false; }
}
template<class T> bool chmin(T& a, T b){
    if( a > b ){ a = b; return true; }
    else{ return false; }
}

int w, h;
int field[110][110];

void dfs(int i, int j){
    field[i][j] = 0;

    //8方向探索
    repl(dx, -1, 2){
        repl(dy, -1, 2){
            if(0 <= i + dx && i + dx < w && 0 <= j + dy && j + dy < h){
                if(field[i+dx][j+dy] == 1) dfs(i+dx, j+dy);
            }
        }
    }
}
int main(){
    cin >> w >> h;

    while(!(w == 0 && h == 0)){
        rep(i, w) rep(j, h) cin >> field[i][j];

        int ret = 0;
        rep(i, w){
            rep(j, h){
                if(field[i][j] == 1){
                    dfs(i, j);
                    ret++;
                }
            }
        }
        Out(ret);
        cin >> w >> h;
    }
    
    return 0;
}
