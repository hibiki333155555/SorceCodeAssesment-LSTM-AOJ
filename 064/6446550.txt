#ifdef LOGX
#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
using namespace std;
//#include <atcoder/all>
//using namespace atcoder;

/*---------macro---------*/
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rep2(i, s, n) for (int i = s; i < (int)(n); i++)
#define unless(x) if(!(x))
#define until(x) while(!(x))
#define ALL(a) a.begin(),a.end()
#define RALL(a) a.rbegin(),a.rend()
#define mybit(i,j) (((i)>>(j))&1)

/*---------type/const---------*/
constexpr int big=1000000007;
//constexpr int big=998244353;
constexpr double EPS=1e-8; //適宜変える
typedef long long ll;
typedef unsigned long long ull;
typedef std::string::const_iterator state; //構文解析
constexpr int dx[4]={1,0,-1,0};
constexpr int dy[4]={0,1,0,-1};
constexpr char newl='\n';
struct{
    constexpr operator int(){return -int(1e9)-10;}
    constexpr operator ll(){return -ll(1e18)-10;}
}neginf;
struct{
    constexpr operator int(){return int(1e9)+10;}
    constexpr operator ll(){return ll(1e18)+10;}
    constexpr auto operator -(){return neginf;}
}inf;

/*---------debug---------*/
#ifdef LOGX
#include <template/debug.hpp>
#else
#define dbg(...) ;
#define dbgnewl ;
#define prt(x) ;
#define _prt(x) ;
#endif

/*---------function---------*/
template<typename T> T max(const std::vector<T> &a){T ans=a[0];for(T elem:a){ans=max(ans,elem);}return ans;}
template<typename T> T min(const std::vector<T> &a){T ans=a[0];for(T elem:a){ans=min(ans,elem);}return ans;}
template<typename T,typename U> bool chmin(T &a,const U b){if(a>b){a=b;return true;}return false;}
template<typename T,typename U> bool chmax(T &a,const U b){if(a<b){a=b;return true;}return false;}
bool valid(int i,int j,int h,int w){return (i>=0 && j>=0 && i<h && j<w);}
template<class T,class U>T expm(T x,U y,const ll mod=big){T res=1;while(y){if(y&1)(res*=x)%=mod;(x*=x)%=mod;y>>=1;}return res;}
template<class T,class U>T exp(T x,U y){T res=1;while(y){if(y&1)res*=x;x*=x;y>>=1;}return res;}

#include<cassert>

//特殊なtrie
//個数の代わりにmax
template<typename T,int SZ=32>
struct BinaryTrie{
    BinaryTrie():root(nullptr){}
    //xを追加する。同じ値を複数個追加することも可能。
    void insert(T x,const ll v){
        root=insert_inner(root,x,v);
    }
    //y^XOR_val<=xとなる範囲でのvalのmax
    ll lower_count(T x,T XOR_val=0){
        return lower_count_inner(root,x,XOR_val);
    }
private:
    struct Node{
        ll val;
        Node *child[2];
        Node():val(0),child{nullptr,nullptr}{}
    };
    Node *root;
    Node* insert_inner(Node *now,const T x,const ll v,const int now_height=SZ-1){
        if(!now){
            now=new Node;
            now->val=-inf;
        }
        if(now_height==-1){
            chmax(now->val,v);
            return now;
        }
        int ne=x>>now_height & 1;
        now->child[ne]=insert_inner(now->child[ne],x,v,now_height-1);
        now->val=-inf;
        rep(i,2)if(now->child[i])chmax(now->val,now->child[i]->val);
        return now;
    }
    ll lower_count_inner(Node *now,const T x,const T XOR_val,const int now_height=SZ-1){
        assert(now);
        if(now_height==-1)return now->val;
        //XOR_valのビットが0：(xのビットが1 ? 0の個数を足して1に潜る : 0に潜る)
        //そうでない：(xのビットが1 ? 1の個数を0に足して0に潜る : 1に潜る)
        const int XOR_bit=(XOR_val>>now_height)&1;
        const int x_bit=(x>>now_height)&1;
        //-> (x_bit==1 ? XOR_bitの個数を足して!XOR_bitに潜る:XOR_bitに潜る)
        ll ans=-inf;
        if(x_bit){
            if(now->child[XOR_bit]){
                chmax(ans,now->child[XOR_bit]->val);
            }
            if(now->child[!XOR_bit]){
                chmax(ans,lower_count_inner(now->child[!XOR_bit],x,XOR_val,now_height-1));
            }
        }
        else{
            if(now->child[XOR_bit]){
                chmax(ans,lower_count_inner(now->child[XOR_bit],x,XOR_val,now_height-1));
            }
        }
        return ans;
    }
};

int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout << std::fixed << std::setprecision(10);
/*------------------------------------*/
    
    int n,m;
    cin >> n >> m;
    vector<int> a(n);
    vector<ll> b(n);
    rep(i,n)cin >> a[i];
    rep(i,n)cin >> b[i];
    const int frsz=n/2;
    BinaryTrie<int> bt;
    rep(i,1<<frsz){
        int A=0;
        ll B=0;
        rep(j,frsz)if(mybit(i,j))A^=a[j],B+=b[j];
        bt.insert(A,B);
    }
    reverse(ALL(a));
    reverse(ALL(b));
    rep(i,frsz)a.pop_back();
    rep(i,frsz)b.pop_back();
    ll ans=0;
    rep(i,1<<a.size()){
        int A=0;
        ll B=0;
        rep(j,a.size())if(mybit(i,j))A^=a[j],B+=b[j];
        ll T=bt.lower_count(m,A);
        if(A<=m)chmax(T,0);
        chmax(ans,B+T);
    }
    cout << ans << newl;
}
