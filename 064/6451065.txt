#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
using ll = long long;

template<typename E, typename H>
struct DualSegmentTree {
    int sz, height;
    vector<E> lazy;
    const H h;
    const E ei;

    DualSegmentTree(int n, const H h, const E &ei) : h(h), ei(ei) {
        sz = 1;
        height = 0;
        while (sz < n) sz <<= 1, height++;
        lazy.assign(2 * sz, ei);
    }

    inline void propagate(int k) {
        if (lazy[k] != ei) {
            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);
            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);
            lazy[k] = ei;
        }
    }

    inline void thrust(int k) {
        for (int i = height; i > 0; i--) propagate(k >> i);
    }

    void update(int a, int b, const E &x) {
        thrust(a += sz);
        thrust(b += sz - 1);
        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) lazy[l] = h(lazy[l], x), ++l;
            if (r & 1) --r, lazy[r] = h(lazy[r], x);
        }
    }

    E operator[](int k) {
        thrust(k += sz);
        return lazy[k];
    }
};

template<typename E, typename H>
DualSegmentTree<E, H> get_dual_segment_tree(int N, const H &h, const E &ei) {
    return {N, h, ei};
}

struct range {
    int start, end;
};

bool cmp1(const range &a, const range &b) { return a.start < b.start; }
bool cmp2(const range &a, const range &b) { return a.end < b.end; }

int main() {
    int n, m;
    cin >> n >> m;

    vector<range> ranges(n);
    vector<ll> imos(m + 2);
    for (int i = 0; i < n; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        ranges[i] = {b, c};
        imos[b] += a, imos[c + 1] -= a;
    }
    for (int i = 1; i < m + 2; i++) imos[i] += imos[i - 1];

    {
        int q;
        cin >> q;
        while (q--) {
            int d, e;
            cin >> d >> e;
            imos[e] -= d;
        }

        for (auto &x: imos) {
            if (x >= 0)x = 0;
            else x = -x;
        }
    }

    ll ret = 0;
    bool possible = true;
    {
        sort(ranges.begin(), ranges.end(), cmp1);

        auto h = [](ll a, ll b) { return a + b; };
        auto seg = get_dual_segment_tree(imos.size(), h, 0);
        for (int i = 1; i <= m; i++)seg.update(i, i + 1, imos[i]);

        range farthest = {-1, -1};
        int nextRange = 0;
        for (int i = 1; i <= m; i++) {
            while (nextRange < n && ranges[nextRange].start <= i) {
                if (cmp2(farthest, ranges[nextRange]))farthest = ranges[nextRange];
                nextRange++;
            }

            int val = seg[i];
            if (val > 0) {
                if (farthest.end < i)possible = false;
                else {
                    ret += val;
                    seg.update(farthest.start, farthest.end + 1, -val);
                }
            }
        }
    }

    if (!possible)cout << -1 << endl;
    else cout << ret << endl;
    return 0;
}

