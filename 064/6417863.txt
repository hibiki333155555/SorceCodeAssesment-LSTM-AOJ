#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

class union_find {
  private:
    vector<int> parent;

  public:
    union_find(int n) : parent(n, -1) {}
    bool unite(int x, int y) {
        x = root(x), y = root(y);
        if(x != y) {
            if(size(x) < size(y)) swap(x, y);
            parent[x] += parent[y];
            parent[y] = x;
            return true;
        }
        return false;
    }
    int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }
    int size(int x) { return -parent[root(x)]; }
    bool same(int x, int y) { return root(x) == root(y); }
};

int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    
    int H,W,N; cin >> H >> W >> N;
    int sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;
    sx--; sy--; gx--; gy--;
    vector<tuple<int,int,int>> a(N);
    rep(i,N) {
        int x,y,k; cin >> x >> y >> k; x--; y--;
        a[i] = {x, y, k};
    }

    if(H > W) {
        swap(H, W);
        swap(sx, sy);
        swap(gx, gy);
        rep(i,N) {
            auto [x, y, k] = a[i];
            swap(x, y);
            a[i] = {x, y, k};
        }
    }

    // H <= W
    vector<vector<int>> sum(H, vector<int>(W + 1));
    rep(i,N) {
        auto [x, y, k] = a[i];
        for(int i = x - k; i <= x + k; i++) {
            int d = k - abs(i - x);
            int L = y - d, R = y + d;
            sum[i][L]++; sum[i][R + 1]--;
        }
    }
    rep(i,H)rep(j,W) sum[i][j + 1] += sum[i][j];

    union_find uf(H * W);
    auto f = [&](int i, int j){ return i * W + j; };
    rep(i,H)rep(j,W) {
        if(sum[i][j] == 0) {
            if(i + 1 < H && sum[i + 1][j] == 0) {
                uf.unite(f(i, j), f(i + 1, j));
            }
            if(j + 1 < W && sum[i][j + 1] == 0) {
                uf.unite(f(i, j), f(i, j + 1));
            }
        }
    }

    cout << (uf.same(f(sx, sy), f(gx, gy)) ? "Yes" : "No") << endl;
}
