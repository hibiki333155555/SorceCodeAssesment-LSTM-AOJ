#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using ull = unsigned long long;
using ld = long double;
using P = pair<ll, ll>;
using tp = tuple<ll, ll, ll>;

template <class T>
using vec = vector<T>;
template <class T>
using vvec = vector<vec<T>>;

#define all(hoge) (hoge).begin(), (hoge).end()
#define en '\n'
#define rep(i, m, n) for(ll i = (ll)(m); i < (ll)(n); ++i)
#define rep2(i, m, n) for(ll i = (ll)(n)-1; i >= (ll)(m); --i)
#define REP(i, n) rep(i, 0, n)
#define REP2(i, n) rep2(i, 0, n)

constexpr long long INF = 1LL << 60;
constexpr int INF_INT = 1 << 25;
// constexpr long long MOD = (ll)1e9 + 7;
constexpr long long MOD = 998244353LL;
static const ld pi = 3.141592653589793L;

#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")

template <class T>
inline bool chmin(T &a, T b) {
    if(a > b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
inline bool chmax(T &a, T b) {
    if(a < b) {
        a = b;
        return true;
    }
    return false;
}

//グラフ関連
struct Edge {
    int to, rev;
    ll cap;
    Edge(int _to, int _rev, ll _cap) : to(_to), rev(_rev), cap(_cap) {}
};

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

void add_edge(Graph &G, int from, int to, ll cap, bool revFlag, ll revCap) {
    G[from].push_back(Edge(to, (int)G[to].size(), cap));
    if(revFlag)
        G[to].push_back(Edge(from, (int)G[from].size() - 1, revCap));
}

void solve() {
    ll h, w;
    cin >> h >> w;
    vec<string> s(h);
    REP(i, h) {
        cin >> s[i];
    }

    ll m;
    cin >> m;
    vec<tp> tab;
    REP(i, m) {
        ll a, b, t;
        cin >> a >> b >> t;
        a--;
        b--;
        tab.push_back({t, a, b});
    }
    sort(all(tab), greater<tp>());
    P st, v;
    REP(i, h) {
        REP(j, w) {
            if(s[i][j] == 'S') {
                st = {i, j};
            }
            if(s[i][j] == 'V') {
                v = {i, j};
            }
        }
    }

    queue<P> q;
    vvec<ll> d(h, vec<ll>(w, -1));
    q.push(st);
    d[st.first][st.second] = 0;
    ll di[4] = {0, 0, 1, -1};
    ll dj[4] = {1, -1, 0, 0};
    while(q.size()) {
        auto [i, j] = q.front();
        q.pop();
        if(s[i][j] == 'V') {
            break;
        }
        while(tab.size()) {
            auto [t, a, b] = tab.back();
            if(d[i][j] + 1 < t)
                break;
            s[a][b] = '#';
            tab.pop_back();
        }
        REP(v, 4) {
            ll ni = di[v] + i;
            ll nj = dj[v] + j;
            if(ni < 0 or ni >= h or nj < 0 or nj >= w)
                continue;
            if(s[ni][nj] == '#')
                continue;
            if(d[ni][nj] != -1)
                continue;
            d[ni][nj] = d[i][j] + 1;
            q.push({ni, nj});
        }
    }

    if(d[v.first][v.second] == -1) {
        cout << "No" << en;
        return;
    }

    REP(i, h) {
        REP(j, w) {
            if(v == make_pair(i, j))
                continue;
            d[i][j] = -1;
        }
    }

    while(q.size())
        q.pop();
    q.push(v);

    while(q.size()) {
        auto [i, j] = q.front();
        q.pop();
        if(s[i][j] == 'S') {
            break;
        }
        while(tab.size()) {
            auto [t, a, b] = tab.back();
            if(d[i][j] + 1 < t)
                break;
            s[a][b] = '#';
            tab.pop_back();
        }
        REP(v, 4) {
            ll ni = di[v] + i;
            ll nj = dj[v] + j;
            if(ni < 0 or ni >= h or nj < 0 or nj >= w)
                continue;
            if(s[ni][nj] == '#')
                continue;
            if(d[ni][nj] != -1)
                continue;
            d[ni][nj] = d[i][j] + 1;
            q.push({ni, nj});
        }
    }

    if(d[st.first][st.second] == -1) {
        cout << "No" << en;
    } else {
        cout << "Yes" << en;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cout << fixed << setprecision(10);

    // ll t;
    // cin >> t;
    // REP(i, t - 1) {
    //     solve();
    // }

    solve();

    return 0;
}

