# https://qiita.com/knakajima3027/items/b871631b8997a6d67223

def calculate_area_to_same_depth(grounds, fromIndex):
    allArea = 0
    depth = 0
    depthToIndex = {}
    optimizeIndex = fromIndex
    for i in range(fromIndex, len(grounds)):
        nowGround = grounds[i]
        prevDepth = depth

        if nowGround == "\\":
            depth -= 1
            # 次の\の時
            if i != 0 and prevDepth in depthToIndex:
                optimizeIndex = depthToIndex[prevDepth]
        elif nowGround == "/":
            depth += 1
        elif nowGround == "_":
            pass

        depthToIndex[depth] = i

        # 台形の計算をしてる
        allArea += ((abs(prevDepth) + abs(depth)) * 1 / 2)

        if i != fromIndex and depth == 0:
            return [0, i, int(allArea)]

    if optimizeIndex != fromIndex:
        return [1, optimizeIndex, None]
    else:
        return [None, None, None]


def main():
    from sys import stdin
    readline = stdin.readline
    grounds = str(readline())

    allAreas = []
    i = 0
    while i < len(grounds):
        ground = grounds[i]
        if ground == "\\":
            # 毎回探すのではなく、存在しない場合は存在する位置に移動するようにする
            type, endIndex, area = calculate_area_to_same_depth(grounds, i)
            if type == 0:
                if endIndex is not None and area is not None:
                    allAreas.append(area)
                    i = endIndex + 1
                    continue
            elif type == 1:
                i = endIndex + 1
        elif ground == "/":
            pass
        elif ground == "_":
            pass
        i += 1

    print(sum(allAreas))
    print(' '.join([str(len(allAreas))] + list(map(lambda x: str(x), allAreas))))


if __name__ == '__main__':
    main()

