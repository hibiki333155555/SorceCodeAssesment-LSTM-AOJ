#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int m,n; cin >> m >> n;
    vector<vector<int>> v(m);
    vector<vector<int>> pe(n);
    int cost = 0;
    for(int i=0;i<m;i++){
        int s; cin >> s;
        v[i].resize(s);
        cost += s;
        for(int j=0;j<s;j++){
            cin >> v[i][j];
            v[i][j]--;
            pe[v[i][j]].push_back(i);
        }
    }
    vector<vector<int>> ng(m,vector<int>(m,0));
    for(int i=0;i<n;i++){
        for(int &j:pe[i]){
            for(int &k:pe[i]){
                if(j==k)continue;
                ng[j][k] = 1;
            }
        }
    }
    int res = 0;
    if(m == 1){
        res = v[0].size();
    }
    else{
        int fr = m/2;
        int bc = m-fr;
        vector<int> dp(1<<bc);
        vector<int> ok(1<<bc,1);
        // dpの前計算
        for(int i=1;i<(1<<bc);i++){
            for(int j=0;j<bc;j++){
                if((1<<j)&i){
                    if(!ok[i-(1<<j)]){
                        ok[i] = 0;
                        break;
                    }
                    for(int k=j+1;k<bc;k++){
                        if((1<<k)&i){
                            if(ng[fr+j][fr+k]){
                                ok[i] = 0;
                                break;
                            }
                        }
                    }
                    break;
                }
            }
            if(ok[i]){
                for(int j=0;j<bc;j++){
                    if(i&(1<<j))dp[i] += v[fr+j].size();
                }
            }
            // cout << i << " " << dp[i] << endl;
        }
        // ゼータ変換ぽい奴
        for(int i=0;i<bc;i++){
            for(int j=0;j<(1<<bc);j++){
                if(j&(1<<i)){
                    dp[j] = max(dp[j],dp[j&~(1<<i)]);
                }
            }
        }
        // 前計算
        vector<int> ua(fr);
        for(int i=0;i<fr;i++){
            for(int j=0;j<bc;j++){
                if(ng[i][fr+j]){
                    ua[i]+=(1<<j);
                }
            }
        }
        // 決めうち
        vector<int> okf(1<<fr,1);
        for(int i=0;i<(1<<fr);i++){
            for(int j=0;j<fr;j++){
                if((1<<j)&i){
                    if(!okf[i-(1<<j)]){
                        okf[i] = 0;
                        break;
                    }
                    for(int k=j+1;k<fr;k++){
                        if((1<<k)&i){
                            if(ng[j][k]){
                                okf[i] = 0;
                                break;
                            }
                        }
                    }
                    break;
                }
            }
            if(okf[i]){
                int sum = 0;
                int bit = (1<<bc)-1;
                for(int j=0;j<fr;j++){
                    if((1<<j)&i){
                        sum += v[j].size();
                        bit |= ua[j];
                        bit ^= ua[j];
                    }
                }
                sum += dp[bit];
                res = max(res,sum);
            }
        }
    }
    cout << cost-res << endl;
}


