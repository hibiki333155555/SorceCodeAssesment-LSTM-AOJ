#line 1 "main.cpp"
#define PROBLEM \
  "https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_B"

#line 2 "lib/prelude.hpp"
#ifndef LOCAL
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#endif
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep2(i, m, n) for (auto i = (m); i < (n); i++)
#define rep(i, n) rep2(i, 0, n)
#define repr2(i, m, n) for (auto i = (n); i-- > (m);)
#define repr(i, n) repr2(i, 0, n)
#define all(x) begin(x), end(x)
#line 3 "lib/graph.hpp"

struct unit_edge {
  int v;
  int to() const { return v; }
  operator int() const { return to(); }
  int w() const { return 1; }
};

template <class Weight>
struct weighted_edge {
  int v;
  Weight weight;
  int to() const { return v; }
  operator int() const { return to(); }
  Weight w() const { return weight; }
};

template <class Inner>
struct basic_graph {
  using weight_type = int;
  constexpr static bool weighted = false;
  const Inner& inner;
  basic_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto u : inner[v]) f(unit_edge{u});
  }
};

template <class Inner, class Weight>
struct basic_weighted_graph {
  using weight_type = Weight;
  constexpr static bool weighted = true;
  const Inner& inner;
  basic_weighted_graph(const Inner& g) : inner(g) {}
  template <class F>
  void adj(int v, F&& f) const {
    for (auto [u, w] : inner[v]) f(weighted_edge<weight_type>{u, w});
  }
};

template <class T>
struct graph_trait : public T {
  graph_trait(T t) : T(move(t)) {}
};

template <class T>
using W = typename graph_trait<T>::weight_type;

template <size_t N>
struct graph_trait<vector<int>[N]> : basic_graph<vector<int>[N]> {
  using basic_graph<vector<int>[N]>::basic_graph;
  int size() const { return N; }
};

template <>
struct graph_trait<vector<vector<int>>> : basic_graph<vector<vector<int>>> {
  using basic_graph<vector<vector<int>>>::basic_graph;
  int size() const { return this->inner.size(); }
};

template <size_t N, class Weight>
struct graph_trait<vector<pair<int, Weight>>[N]>
    : basic_weighted_graph<vector<pair<int, Weight>>[N], Weight> {
  using basic_weighted_graph<vector<pair<int, Weight>>[N],
                             Weight>::basic_weighted_graph;
  int size() const { return N; }
};

template <class Weight>
struct graph_trait<vector<vector<pair<int, Weight>>>>
    : basic_weighted_graph<vector<vector<pair<int, Weight>>>, Weight> {
  using basic_weighted_graph<vector<vector<pair<int, Weight>>>,
                             Weight>::basic_weighted_graph;
  int size() const { return this->inner.size(); }
};
#line 3 "lib/graph/tree/dfs.hpp"

template <class G, class Fin, class Fout>
void dfs(const G& graph, int s, Fin&& fin, Fout&& fout) {
  graph_trait<G> g(graph);
  auto dfs_fn = [&](auto&& f, int v, int p) {
    g.adj(v, [&](auto&& e) {
      if (e.to() != p)
        fin(e, v), f(f, e.to(), v), fout(e, v);
    });
  };
  dfs_fn(dfs_fn, s, -1);
}

template <class G, class F>
void dfs(const G& graph, int s, F&& f) {
  dfs(graph, s, f, [](auto&&, auto&&) {});
}

template <class G, class F>
void dfs_bottom_up(const G& graph, int s, F&& f) {
  dfs(graph, s, [](auto&&, auto&&) {}, f);
}

template <class G, class F>
void dfs_ord(const G& graph, int s, F&& f) {
  f(s, -1);
  dfs(graph, s, [&](int v, int p) { f(v, p); });
}

template <class G, class F>
void dfs_rev_ord(const G& graph, int s, F&& f) {
  dfs_bottom_up(graph, s, [&](int v, int p) { f(v, p); });
  f(s, -1);
}
#line 4 "lib/graph/tree/rerooting.hpp"

struct identity {
  template <class T>
  auto operator()(T&& x) const {
    return forward<T>(x);
  }
};

template <class G, class T, class Add, class Remove, class Inv = identity>
vector<T> rerooting(const G& graph, T unit = T(), Add&& add = Add(),
                    Remove remove = Remove(), Inv e_inv = Inv()) {
  graph_trait<G> g(graph);
  vector<T> now(g.size(), unit), res(g.size(), unit);
  dfs_bottom_up(graph, 0, [&](auto&& e, int p) {
    add(now[p], now[e.to()], e.to(), e.w());
  });
  res[0] = now[0];
  dfs(graph, 0,
      [&](auto&& e, int p) {
        remove(now[p], now[e.to()], e.to(), e.w());
        add(now[e.to()], now[p], p, e_inv(e.w()));
        res[e.to()] = now[e.to()];
      },
      [&](auto&& e, int p) {
        remove(now[e.to()], now[p], p, e_inv(e.w()));
        add(now[p], now[e.to()], e.to(), e.w());
      });
  return res;
}
#line 5 "main.cpp"

int main() {
  int n;
  scanf("%d", &n);
  vector<vector<pair<int, int>>> G(n);
  rep(_, n - 1) {
    int u, v;
    int w;
    scanf("%d%d%d", &u, &v, &w);
    G[u].emplace_back(v, w);
    G[v].emplace_back(u, w);
  }
  auto res = rerooting(
      G, pair(pair(0, -1), pair(0, -1)),
      [&](auto& xu, auto& xv, int v, int w) {
        if (xu.first.first < xv.first.first + w)
          xu.second = xu.first, xu.first = pair(xv.first.first + w, v);
        else if (xu.second.first < xv.first.first + w)
          xu.second = pair(xv.first.first + w, v);
      },
      [&](auto& xu, auto&&, int v, auto&&) {
        if (xu.first.second == v) xu.first = xu.second;
      });
  rep(v, n) printf("%d\n", res[v].first.first);
}

