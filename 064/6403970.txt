#include <bits/stdc++.h>
#define rep(i,cc,n) for(int i=cc;i<n;++i)
#define drep(i,cc,n) for(int i=cc;i>=n;--i)
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
const long long INF = 1LL << 60;
const long long  MOD = 1e9 + 7;
long double PI = 3.14159265358979;
typedef long long ll;
using namespace std;

struct Unionfind{
    vector<int> p, siz;
    Unionfind(int n){
        p.resize(n, -1);
        siz.resize(n, 1);
    }

    //親を求める
    int find(int x){
        if(p[x] == -1) return x;
        else return p[x] = find(p[x]);
    }

    //xを含むグループと y を含むグループをくっつける
    void unite(int x, int y){
        x = find(x);
        y = find(y);
 
        if(x == y) return;
        //union by size (y 側のサイズが小さくなるようにする)
        if(siz[x] < siz[y]) swap(x, y);
        siz[x] += siz[y];
        p[y] = x;
    }

    //xを含むグループのサイズ
    int size(int x) {
        return siz[find(x)];
    }
};

//辺の構造体
struct Edge{
    ll u,v,cost;
    //後ろにconstつける！
    bool operator<(const Edge& e) const {return this->cost<e.cost;}
};

//計算量:=O(m log{n})
ll Kruskal(vector<Edge> &edges,ll n){
    sort(edges.begin(), edges.end());//辺の重みの昇順
    Unionfind uf(n);
    ll ret = 0;
    for(auto e : edges){
        //その辺を加える必要があるか
        if (uf.find(e.u) != uf.find(e.v)){
            uf.unite(e.u,e.v);
            ret += e.cost;
        }
    }
    return ret;
}

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    int v, e;
    cin >> v >> e;

    vector<Edge> ed(e);

    rep(i,0,e){
        ll s, t, w;
        cin >> s >> t >> w;

        ed[i].u = s;
        ed[i].v = t;
        ed[i].cost = w;
    }

    ll ans = Kruskal(ed, v);
    cout << ans << endl;
    return 0;        
}
