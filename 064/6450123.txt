#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define _max(a, b) ((a) > (b) ? (a) : (b))
#define R register
ll n, m;
ll x[10000010], odd;
const int BASE = 10000;
const int MX_LEN = 1010;
struct Bign {
    int num[MX_LEN];
    int len;
    Bign() {
        memset(num, 0, sizeof(num));
        len = 1;
    }
    Bign(const ll x) {
        *this = x;
    }
    Bign(const string x) {
        *this = x;
    }
    Bign(const Bign& x) {
        memset(num, 0, sizeof(num));
        len = x.len;
        for(int i = 0; i < len; i++)
            num[i] = x.num[i];
    }
    void clean() {
        while(num[len - 1] == 0 && len != 1)
            len--;
    }
    Bign operator=(const ll x) {
        stringstream ss;
        ss << x;
        string temp;
        ss >> temp;
        return *this = temp;
    }
    Bign operator=(const string x) {
        len = 0;
        memset(num, 0, sizeof(num));
        ll temp = 0;
        ll base = 1;
        for(int i = x.length() - 1; i >= 0; i--) {
            temp += (x[i] - '0') * base;
            base *= 10;
            if(base == BASE) {
                num[len++] = temp;
                temp = 0;
                base = 1;
            }
        }
        num[len++] = temp;
        clean();
        return *this;
    }
    Bign operator+(const Bign& b) const {
        Bign c;
        c.len = _max(len, b.len) + 1;
        for(int i = 0; i < c.len; i++) {
            c.num[i] += num[i] + b.num[i];
            c.num[i + 1] += c.num[i] / BASE;
            c.num[i] %= BASE;
        }
        c.clean();
        return c;
    }
    Bign operator-(const Bign& b) const {  // a-b保证a>b
        Bign c;
        c.len = _max(len, b.len);
        for(int i = 0; i < c.len; ++i) {
            c.num[i] += num[i] - b.num[i];
            if(c.num[i] < 0) {
                c.num[i] += BASE;
                c.num[i + 1] -= 1;
            }
        }
        c.clean();
        return c;
    }
    Bign operator<<(const int& num) const {
        Bign c = *this;
        c.len += 10;
        for(R int i = 0; i < c.len; ++i) {
            c.num[i] <<= num;
            if(i && c.num[i - 1] >= BASE)
                ++c.num[i], c.num[i - 1] -= BASE;
        }
        c.clean();
        return c;
    }
    Bign operator>>(const int& num) const {
        Bign c = *this;
        for(R int i = len - 1; i >= 0; --i) {
            if((c.num[i] & 1) && i)
                c.num[i - 1] += BASE;
            c.num[i] >>= num;
        }
        c.clean();
        return c;
    }
    Bign operator*(const Bign& b) const {
        Bign c;
        c.len = len + b.len + 5;
        for(int i = 0; i < c.len; ++i) {
            for(int j = 0; j < b.len; ++j) {
                c.num[i + j] += num[i] * b.num[j];
                c.num[i + j + 1] += c.num[i + j] / BASE;
                c.num[i + j] %= BASE;
            }
        }
        c.clean();
        return c;
    }
    Bign operator/(const ll& b) const {  //大数除以long long
        Bign c;
        c.len = len;
        ll rest = 0;
        for(int i = len - 1; i >= 0; --i) {
            rest = rest * BASE + num[i];
            c.num[i] = rest / b;
            rest %= b;
        }
        c.clean();
        return c;
    }
    Bign operator/(const Bign& b) const {
        Bign c, rest, now, _base;
        now = *this;
        rest = b;
        _base = 1;
        while(now >= rest) {
            rest = rest << 1;
            _base = _base << 1;
        }
        while(_base.len > 1 || _base.num[0]) {
            if(now >= rest) {
                now -= rest;
                c += _base;
            }
            rest = rest >> 1;
            _base = _base >> 1;
        }
        c.clean();
        return c;
    }
    Bign operator%(const ll& b) const {
        return (*this) - ((*this) / b) * b;
    }
    Bign operator%(const Bign& b) const {
        return (*this) - ((*this) / b) * b;
    }
    Bign operator+=(const Bign& b) {
        return (*this) = (*this) + b;
    }
    Bign operator-=(const Bign& b) {
        return (*this) = (*this) - b;
    }
    Bign operator*=(const Bign& b) {
        return (*this) = (*this) * b;
    }
    Bign operator/=(const ll& b) {
        return (*this) = (*this) / b;
    }
    Bign operator/=(const Bign& b) {
        return (*this) = (*this) / b;
    }
    Bign operator%=(const ll& b) {
        return (*this) = (*this) % b;
    }
    Bign operator%=(const Bign& b) {
        return (*this) = (*this) % b;
    }
    bool operator<(const Bign& b) const {
        if(len == b.len) {
            for(int i = len - 1; i >= 0; --i) {
                if(num[i] != b.num[i])
                    return num[i] < b.num[i];
            }
            return 0;
        }
        return len < b.len;
    }
    bool operator>(const Bign& b) const {
        if(len == b.len) {
            for(int i = len - 1; i >= 0; --i) {
                if(num[i] != b.num[i])
                    return num[i] > b.num[i];
            }
            return 0;
        }
        return len > b.len;
    }
    bool operator==(const Bign& b) const {
        if(len == b.len) {
            for(int i = len - 1; i >= 0; --i) {
                if(num[i] != b.num[i])
                    return 0;
            }
            return 1;
        }
        return 0;
    }
    bool operator!=(const Bign& b) const {
        return !((*this) == b);
    }
    bool operator<=(const Bign& b) const {
        return !((*this) > b);
    }
    bool operator>=(const Bign& b) const {
        return !((*this) < b);
    }
    friend ostream& operator<<(ostream& out, const Bign& x) {
        out << x.num[x.len - 1];
        for(int i = x.len - 2; i >= 0; i--) {
            int t = BASE / 10;
            while(x.num[i] < t && t > 1) {
                out << 0;
                t /= 10;
            }
            out << x.num[i];
        }
        return out;
    }
    friend istream& operator>>(istream& in, Bign& x) {
        string temp;
        in >> temp;
        x = temp;
        return in;
    }
    double to_ll() {
        double x = num[len - 1];
        for(int i = len - 2; i >= 0; i--) {
            x = x * BASE + num[i];
        }
        return x;
    }
};
void _Init() {
    m = n * (n + 1) / 2;
    ll cnt = 0;
    odd = 0x7fffffffffffffffLL;
    for(int i = 0; i < m; i++) {
        ll t;
        cin >> t;
        if((t % 2) == 0)
            x[cnt++] = t;
        else
            odd = min(odd, t);
    }
}

void solve() {
    sort(x, x + n);
    Bign a = x[0];
    Bign b = x[1];
    Bign ans = (a * b);
    ans /= odd;
    ll base = (ll)(sqrtl(ans.to_ll()) + 0.5);
    cout << base << endl;
    for(int i = 0; i < n; i++) {
        if(i)
            cout << " ";
        cout << x[i] / base;
    }
}
int main() {
#ifdef LOCAL
    freopen("data.in", "r", stdin);
    freopen("data.out", "w", stdout);
#endif
    int ttt = 0;
    while(cin >> n) {
        if(n == 0)
            break;
        if(ttt++)
            cout << endl;
        _Init();
        solve();
    }

    return 0;
}

