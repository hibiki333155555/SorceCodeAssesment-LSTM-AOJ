fn main() -> Result<(), Box<dyn std::error::Error>> {
    let sc = scan::Scanner::new();
    let (v, e) = sc.read::<(_, usize)>();
    let mut graph = vec![vec![]; v];
    for _ in 0..e {
        let (s, t) = sc.read::<(usize, usize)>();
        graph[s].push(t);
    }
    let scc = strong_connected_component(&graph);
    for c in scc {
        if c.len() > 1 {
            println!("{}", 1);
            return Ok(());
        }
    }
    println!("{}", 0);
    Ok(())
}

fn strong_connected_component(g: &Vec<Vec<usize>>) -> Vec<Vec<usize>> {
    let n = g.len();
    let mut index_list: Vec<usize> = vec![0; n];
    let mut visited: Vec<bool> = vec![false; n];
    let mut id = 0;
    for i in 0..n {
        if visited[i] {
            continue;
        }
        indexing(&g, i, &mut visited, &mut id, &mut index_list);
    }
    for i in 0..n {
        visited[i] = false;
    }
    let mut scc = vec![];
    let mut backward = vec![vec![]; n];
    for i in 0..n {
        for e in &g[i] {
            backward[*e].push(i);
        }
    }
    while let Some(i) = index_list.pop() {
        if visited[i] {
            continue;
        }
        let mut component = vec![];
        generate_components(&backward, i, &mut visited, &mut component);
        scc.push(component);
    }
    scc
}

fn indexing(
    g: &Vec<Vec<usize>>,
    i: usize,
    visited: &mut Vec<bool>,
    id: &mut usize,
    index_list: &mut Vec<usize>,
) {
    visited[i] = true;
    for nex in &g[i] {
        if visited[*nex] {
            continue;
        }
        indexing(g, *nex, visited, id, index_list);
    }
    index_list[*id] = i;
    *id += 1;
}

fn generate_components(
    backward: &Vec<Vec<usize>>,
    i: usize,
    visited: &mut Vec<bool>,
    component: &mut Vec<usize>,
) {
    visited[i] = true;
    component.push(i);
    for nex in &backward[i] {
        if visited[*nex] {
            continue;
        }
        generate_components(backward, *nex, visited, component);
    }
}

mod scan {
    type Chars = Vec<char>;

    pub struct Scanner {
        handle: std::io::Stdin,
    }

    impl Scanner {
        pub fn new() -> Self {
            Scanner {
                handle: std::io::stdin(),
            }
        }
        pub fn read<T>(&self) -> T
        where
            T: Scannable,
        {
            let mut buf = String::new();
            self.handle.read_line(&mut buf).unwrap();
            <T as Scannable>::from_scan(
                buf.trim_end_matches('\n')
                    .trim_end_matches('\r')
                    .to_string(),
            )
        }
    }

    pub trait Scannable {
        fn from_scan(s: String) -> Self;
    }

    macro_rules! impl_Scannable_for_numeical {
    ($($t:ty)*) => {
        $(
            impl Scannable for $t  {
                fn from_scan(s: String) -> Self {
                    s.as_str().parse::<$t>().unwrap()
                }
            }
        )*
    };
}
    impl_Scannable_for_numeical!(usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64);

    macro_rules! impl_Scannable_for_numeical_vector {
    ($($t:ty)*) => {
        $(
            impl Scannable for Vec<$t> {
                fn from_scan(s: String) -> Self {
                    s.split_whitespace()
                        .map(|i| i.parse::<$t>().unwrap())
                        .collect()
                }
            }
        )*
    };
}
    impl_Scannable_for_numeical_vector!(usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64);

    impl Scannable for Chars {
        fn from_scan(s: String) -> Self {
            s.chars().collect()
        }
    }

    impl Scannable for Vec<String> {
        fn from_scan(s: String) -> Self {
            s.split_whitespace().map(|s| s.to_string()).collect()
        }
    }

    impl Scannable for (usize, usize) {
        fn from_scan(s: String) -> Self {
            let mut vals = s.split_whitespace().map(|s| s.parse::<usize>().unwrap());
            (vals.next().unwrap(), vals.next().unwrap())
        }
    }

    impl Scannable for (usize, u64) {
        fn from_scan(s: String) -> Self {
            let mut it = s.split_whitespace();
            (
                it.next().unwrap().parse().unwrap(),
                it.next().unwrap().parse().unwrap(),
            )
        }
    }
}

