#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

void solve(){
    int n,s; cin >> n >> s;
    vector<array<int, 4>> v(n);
    bool f = false;
    int dif = 0; // -(sum(2)-sum(3))
    for(int i=0;i<n;i++){
        for(int j=0;j<4;j++){
            cin >> v[i][j];
            if(v[i][j] == 2)dif--;
            else if(v[i][j] == 3)dif++;
        }
        if(v[i][0] == 1 and v[i][2] == 1){
            f = true;
        }
        if(v[i][1] == 1 and v[i][3] == 1){
            f = true;
        }
    }
    // 長方形の短い方の辺が1
    // この場合は流石に簡単なはず？
    if(f){
        // ジグソーパズル凹凸の数は等しい
        // 盗まれたピースの凹凸の差が入力から定まる
        // これ一般の場合でも言えるな
        int kado = 0;
        for(int i=0;i<n;i++){
            int cnt = 0;
            for(int j=0;j<4;j++){
                if(v[i][j] == 1)cnt++;
            }
            if(cnt == 3)kado++;
        }
        if(kado < 2){
            if(dif == 1){
                printf("1 1 1 2\n");
            }
            else{
                printf("1 1 1 3\n");
            }
        }
        else{
            if(dif == 2){
                printf("1 2 1 2\n");
            }
            else if(dif == 0){
                printf("1 2 1 3\n");
            }
            else{
                printf("1 3 1 3\n");
            }
        }
        return;
    }
    // 4つ角の場合
    {
        int kado = 0;
        for(int i=0;i<n;i++){
            int cnt = 0;
            for(int j=0;j<4;j++){
                if(v[i][j] == 1)cnt++;
            }
            if(cnt == 2)kado++;
        }
        if(kado < 4){
            if(dif == 2){
                printf("1 1 2 2\n");
            }
            else if(dif == 0){
                printf("1 1 2 3\n");
            }
            else{
                printf("1 1 3 3\n");
            }
            return;
        }
    }
    // 端の場合
    // 考えられるdifは、{3,1,-1,-3}
    // そうでない場合
    // 考えられるdifは、{4,2,0,-2,-4}

    // この偶奇で判別可能
    if(abs(dif) == 3 or abs(dif) == 1){
        if(dif == 3){
            printf("1 2 2 2\n");
        }
        else if(dif == 1){
            if(s) printf("1 2 3 2\n");
            else printf("1 2 2 3\n");
        }
        else if(dif == -1){
            if(s) printf("1 3 2 3\n");
            else printf("1 2 3 3\n");
        }
        else{
            printf("1 3 3 3\n");
        }
        return;
    }
    else{
        // printf("unsolved\n");
        if(dif == 4){
            printf("2 2 2 2\n");
        }
        else if(dif == -4){
            printf("3 3 3 3\n");
        }
        else if(dif == 2){
            printf("2 2 2 3\n");
        }
        else if(dif == -2){
            printf("2 3 3 3\n");
        }
        else{
            if(s){
                printf("2 3 2 3\n");
            }
            else{
                printf("2 2 3 3\n");
            }
        }
    }
}

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int q; cin >> q;
    while(q--){
        solve();
    }
}


