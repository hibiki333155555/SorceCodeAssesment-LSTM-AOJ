#define READ_FROM_FILE 0

#if READ_FROM_FILE
#include <fstream>
#endif

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class PointInfo {
public:
	vector<int> coord;
	int idx;

public:
	PointInfo() : idx(-1) {
		return;
	}

	PointInfo(const vector<int>& coord, int idx) : coord(coord), idx(idx) {
		return;
	}

	~PointInfo() {
		return;
	}
};

class KdTree {
private:
	class Node {
	public:
		PointInfo location;
		Node* l_child;
		Node* r_child;
		vector<int> l_most;
		vector<int> r_most;
		vector<int> idx_vec;

	public:
		Node(const PointInfo& l) : location(l), l_child(nullptr), r_child(nullptr) {
			return;
		}

		~Node() {
			if (l_child != nullptr) {
				delete l_child;
			}
			if (r_child != nullptr) {
				delete r_child;
			}
			return;
		}
	};

private:
	int k_;
	vector<PointInfo> point_vec_;
	Node* root_;

private:
	bool does_not_intersect(const Node* cn, const vector<int>& s_coord, const vector<int>& t_coord) {
		for (int i = 0; i < cn->l_most.size(); i++) {
			if (cn->r_most[i] < s_coord[i] || t_coord[i] < cn->l_most[i]) {
				return true;
			}
		}
		return false;
	}

	bool is_contained(const Node* cn, const vector<int>& s_coord, const vector<int>& t_coord) {
		for (int i = 0; i < cn->l_most.size(); i++) {
			if (!(s_coord[i] <= cn->l_most[i] && cn->r_most[i] <= t_coord[i])) {
				return false;
			}
		}
		return true;
	}

	Node* create_kd_tree(int left, int right,int depth) {
		if (left >= right) {
			return nullptr;
		}

		if (left == right - 1) {
			PointInfo cp = point_vec_[left];
			Node* n_node = new Node(cp);
			
			for (int i = 0; i < cp.coord.size(); i++) {
				n_node->l_most.push_back(cp.coord[i]);
				n_node->r_most.push_back(cp.coord[i]);
			}
			n_node->idx_vec.push_back(cp.idx);
			return n_node;
		}
		
		int axis = depth % k_;
		int mid = (left + right) / 2;
		int n_depth = depth + 1;
		Node* n_node = nullptr;

		sort(point_vec_.begin() + left, point_vec_.begin() + right, [&, axis](const PointInfo& lh, const PointInfo& rh) { return lh.coord[axis] < rh.coord[axis]; });
		n_node = new Node(point_vec_[mid]);
		for (int i = left; i < right; i++) {
			n_node->idx_vec.push_back(point_vec_[i].idx);
		}

		n_node->l_child = create_kd_tree(left, mid, n_depth);
		n_node->r_child = create_kd_tree(mid, right, n_depth);

		for (int i = 0; i < point_vec_[left].coord.size(); i++) {
			//if (i == axis) {
			//	n_node->l_most.push_back(point_vec_[left].coord[i]);
			//	n_node->r_most.push_back(point_vec_[right - 1].coord[i]);
			//}
			//else if(n_node->l_child != nullptr && n_node->r_child != nullptr){
			if(n_node->l_child != nullptr && n_node->r_child != nullptr){
				n_node->l_most.push_back(min(n_node->l_child->l_most[i], n_node->r_child->l_most[i]));
				n_node->r_most.push_back(max(n_node->l_child->r_most[i], n_node->r_child->r_most[i]));
			}
			else if (n_node->l_child != nullptr) {
				n_node->l_most.push_back(n_node->l_child->l_most[i]);
				n_node->r_most.push_back(n_node->l_child->r_most[i]);
			}
			else if (n_node->r_child != nullptr) {
				n_node->l_most.push_back(n_node->r_child->l_most[i]);
				n_node->r_most.push_back(n_node->r_child->r_most[i]);
			}
			else {
				n_node->l_most.push_back(n_node->location.coord[i]);
				n_node->r_most.push_back(n_node->location.coord[i]);
			}
		}
		return n_node;
	}

	void search_kd_tree_sub(const Node* cn, const vector<int>& s_coord, const vector<int>& t_coord, vector<int>& idx_vec) {
		if (does_not_intersect(cn, s_coord, t_coord)) {
			return;
		}
		if (is_contained(cn, s_coord, t_coord)) {
			idx_vec.insert(idx_vec.end(), cn->idx_vec.begin(), cn->idx_vec.end());
			return;
		}
		if (cn->l_child == nullptr && cn->r_child == nullptr) {
			idx_vec.push_back(cn->location.idx);
			return;
		}

		if (cn->l_child != nullptr) {
			search_kd_tree_sub(cn->l_child, s_coord, t_coord, idx_vec);
		}
		
		if (cn->r_child != nullptr) {
			search_kd_tree_sub(cn->r_child, s_coord, t_coord, idx_vec);
		}
		return;
	}

public:
	KdTree(int k, const vector<PointInfo>& point_vec) : k_(k), point_vec_(point_vec), root_(nullptr) {
		root_ = create_kd_tree(0, point_vec.size(), 0);
		return;
	}

	~KdTree() {
		if (root_ != nullptr) {
			delete root_;
		}
		return;
	}
	
	void search_kd_tree(const vector<int>& s_coord, const vector<int>& t_coord, vector<int>& idx_vec) {
		search_kd_tree_sub(root_, s_coord, t_coord, idx_vec);
		return;
	}

};


int main(int argc, char** argv) {
#if READ_FROM_FILE
	ifstream ifs("test0.txt");
	cin.rdbuf(ifs.rdbuf());
#endif
	int n = -1;
	int k = 2;
	int x = 0;
	int y = 0;
	int q = -1;
	vector<PointInfo> point_vec;
	KdTree* kd_tree = nullptr;

	cin >> n;
	for (int i = 0; i < n; i++) {
		PointInfo point_info;

		cin >> x >> y;
		point_info.coord.push_back(x);
		point_info.coord.push_back(y);
		point_info.idx = i;
		point_vec.push_back(point_info);
	}

	kd_tree = new KdTree(k, point_vec);

	cin >> q;
	for (int i = 0; i < q; i++) {
		vector<int> s_coord;
		vector<int> t_coord;
		vector<int> idx_vec;

		cin >> x >> y;
		s_coord.push_back(x);
		t_coord.push_back(y);

		cin >> x >> y;
		s_coord.push_back(x);
		t_coord.push_back(y);
		
		kd_tree->search_kd_tree(s_coord, t_coord, idx_vec);
		sort(idx_vec.begin(), idx_vec.end());
		for (const int& idx : idx_vec) {
			cout << idx << endl;
		}
		cout << endl;
	}
	delete kd_tree;
	return 0;
}

