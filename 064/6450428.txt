#include <bits/stdc++.h>

using namespace std;
#define rep(i,n) for(long long i=0;i<n;++i)
#define rep1(i,n) for(long long i=1;i<=n;++i)
#define rrep(i,n) for(long long i=n-1;i>=0;--i)
#define debug(output) if(debugFlag)cout<<#output<<"= "<<output<<"\n";
using lint = long long;
typedef pair<int,int> P;
const bool debugFlag=true;
const lint linf=1.1e18;const lint inf=1.01e9;
constexpr int MOD=1000000007;
template<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }

#include<atcoder/all>
using namespace atcoder;
using mint = modint998244353;

struct Node{
    int no;
    int par;
    int depth;
    mint dp,dp2;
    vector<Node*> child;
    void build(int i){
        no=i;depth=0;
        par=i;dp=1;dp2=0;
    }
};
struct Tree{
    int n;
    vector<Node> node;
    vector<pair<int,int>> list;
    vector<int> pos;
    Tree(int k){
        n=k;
        pos.resize(n,inf);
        node.resize(n);
        for(int i=0;i<n;++i){
            node[i].build(i);
        }
    }
    void input(int k){
        for(int i=0;i<k;++i){
            int a,b;cin>>a>>b;
            --a;--b;
            node[a].child.push_back(&node[b]);
            node[b].child.push_back(&node[a]);
        }
    }
    vector<vector<int>> lcaDp;
    void getLcaDp(){
        lcaDp.resize(n);
        for(int i=0;i<n;++i)lcaDp[i].resize(32);
        for(int i=0;i<n;++i)lcaDp[i][0]=node[i].par;
        for(int j=1;j<32;++j)for(int i=0;i<n;++i)lcaDp[i][j]=lcaDp[lcaDp[i][j-1]][j-1];
    }
    int getLCA(int a,int b){
        if(node[a].depth<node[b].depth)swap(a,b);
        int sub=node[a].depth-node[b].depth;
        for(int i=0;i<32;++i)if(sub>>i&1)a=lcaDp[a][i];
        if(a==b)return a;
        for(int i=31;i>=0;--i){
            if(lcaDp[a][i]==lcaDp[b][i])continue;
            a=lcaDp[a][i];b=lcaDp[b][i];
        }
        return node[a].par;
    }
    int getLCA2(int a,int b){
        if(node[a].depth<node[b].depth)swap(a,b);
        int sub=node[a].depth-node[b].depth-1;
        for(int i=0;i<32;++i)if(sub>>i&1)a=lcaDp[a][i];
        return a;
    }
    void BFS(int s){
        queue<Node> que;
        que.push(node[s]);
        while(!que.empty()){
            Node buf=que.front();que.pop();
            int num=buf.child.size();
            for(int i=0;i<num;++i){
                if(buf.child[i]->no!=buf.par){
                    buf.child[i]->par=buf.no;
                    buf.child[i]->depth=buf.depth+1;
                    que.push(*buf.child[i]);
                }
            }
        }
    }
    mint DFS(Node& node){
        if(node.child.size()==1&&node.par!=node.no){
            return node.dp;
        }
        else{
            int num=node.child.size();
            for(int i=0;i<num;++i){
                if(node.child[i]->no!=node.par){
                    DFS(*node.child[i]);
                    node.dp+=node.child[i]->dp*2;
                }
            }
            return node.dp;
        }
    }
    void rerooting(int v){
        if(node[v].child.size()==1&&node[v].par!=v)return;
        for(auto& child:node[v].child){
            if(child->no==node[v].par)continue;
            child->dp2=(node[v].dp-child->dp*2)*2+node[v].dp2*2;
            rerooting(child->no);
        }
    }
    int dist(int a,int b,int c){
        return node[a].depth+node[b].depth-2*node[c].depth;
    }
    void solve(){
        input(n-1);
        BFS(0);
        DFS(node[0]);
        rerooting(0);
        getLcaDp();
        int q;cin>>q;
        mint ni=2;
        rep(_z,q){
            int a,b;cin>>a>>b;
            --a;--b;
            int lca=getLCA(a,b);
            if(lca==a||lca==b){
                if(lca==b)swap(a,b);
                int lca2=getLCA2(a,b);
                mint res=ni.pow(dist(a,b,lca))*node[b].dp*(node[a].dp2+node[a].dp-node[lca2].dp*2);
                cout<<res.val()<<"\n";
            }
            else{
                mint res=ni.pow(dist(a,b,lca))*node[a].dp*node[b].dp;
                cout<<res.val()<<"\n";
            }
        }
        rep(i,0){
            debug(i);
            debug(node[i].dp.val());
            debug(node[i].dp2.val());
        }
    }
};

signed main(){
  cin.tie(0);
  ios::sync_with_stdio(false);
  int n;cin>>n;
  Tree tree(n);
  tree.solve();
  return 0;
}
