#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <string>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <iomanip>
#include <utility>
#include <tuple>
#include <functional>
#include <bitset>
#include <cassert>
#include <complex>
#include <stdio.h>
#include <time.h>
#include <numeric>
#include <random>
#include <unordered_set>
#include <unordered_map>
#define all(a) (a).begin(), (a).end()
#define rep(i, n) for (ll i = 0; i < (n); i++)
#define req(i, a, b) for (ll i = (a); i < (b); i++)
#define pb push_back
#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << (x) << '\n'
#define debug2(x, y) cerr << __LINE__ << ' ' << #x << ':' << (x) << ',' << #y << ':' << (y) << '\n'
#define debug3(x, y, z) cerr << __LINE__ << ' ' << #x << ':' << (x) << ',' << #y << ':' << (y) << ',' << #z << ':' << (z) << '\n'
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<ll, ll> P;
typedef pair<ll, P> Q;
template<class T> using pri_s = priority_queue<T, vector<T>, greater<T>>;
template<class T> using pri_b = priority_queue<T>;
constexpr int inf = 1000000010;
constexpr int inf2 = 2000000010;
constexpr ll INF = 1000000000000000010;
constexpr ll INF4 = 4000000000000000010;
constexpr int mod1e9 = 1000000007;
constexpr int mod998 = 998244353;
constexpr ld eps = 1e-12;
constexpr ld pi = 3.141592653589793238;
constexpr ll ten(int n) { return n ? 10 * ten(n - 1) : 1; };
int dx[] = { 1,0,-1,0,1,1,-1,-1,0 }; int dy[] = { 0,1,0,-1,1,-1,1,-1,0 };
ll mul(ll a, ll b) { return (a > INF / b ? INF : a * b); }
void fail() { cout << "-1\n"; exit(0); } void no() { cout << "No\n"; exit(0); }
template<class T> void er(T a) { cout << a << '\n'; exit(0); }
template<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }
template<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }
template<class T> istream &operator >> (istream &s, vector<T> &v) { for (auto &e : v) s >> e; return s; }
template<class T> ostream &operator << (ostream &s, const vector<T> &v) { for (auto &e : v) s << e << ' '; return s; }
template<class T, class U> ostream &operator << (ostream &s, const pair<T, U> &p) { s << p.first << ' ' << p.second; return s; }

struct fastio {
	fastio() {
		cin.tie(0); cout.tie(0);
		ios::sync_with_stdio(false);
		cout << fixed << setprecision(20);
		cerr << fixed << setprecision(20);
	}
}fastio_;

namespace library {
	random_device seed_gen;
	mt19937_64 engine(seed_gen());
	ll rnum(ll r) { return engine() % r; }
	ll rnum(ll l, ll r) { return rnum(r - l) + l; }
	vector<ll> rvec(ll n, ll r) {
		vector<ll> res(n);
		rep(i, n) res[i] = rnum(r);
		return res;
	}
	vector<ll> rvec(ll n, ll l, ll r) {
		vector<ll> res(n);
		rep(i, n) res[i] = rnum(l, r);
		return res;
	}
	vector<vector<ll>> avec(ll n, ll l, ll r) {
		if (n == 0) return { {} };
		vector<vector<ll>> pre = avec(n - 1, l, r);
		vector<vector<ll>> res;
		for (vector<ll> v : pre) {
			for (int i = l; i < r; i++) {
				vector<ll> w = v;
				w.pb(i);
				res.pb(w);
			}
		}
		return res;
	}
	vector<vector<ll>> avec(ll n, ll r) { return avec(n, 0, r); }
	vector<vector<ll>> bvec(ll n, ll l, ll r) {
		if (n == 0) return { {} };
		vector<vector<ll>> pre = bvec(n - 1, l, r);
		vector<vector<ll>> res;
		for (vector<ll> v : pre) {
			int b = l;
			if (!v.empty()) b = v.back();
			for (int i = b; i < r; i++) {
				vector<ll> w = v;
				w.pb(i);
				res.pb(w);
			}
		}
		return res;
	}
	vector<vector<ll>> bvec(ll n, ll r) { return bvec(n, 0, r); }
	template<class T> void shuf(vector<T> &v) { shuffle(all(v), engine); }
}

using namespace library;

constexpr ll mod = mod1e9;
template <int mod> class modint {
public:
	int n;
	modint() : n(0) {};
	modint(ll n_) {
		n = n_ % mod;
		if (n < 0) n += mod;
	}
	modint operator -() const { return n > 0 ? mod - n : -n; }
	bool operator == (const modint &m) const { return n == m.n; }
	bool operator != (const modint &m) const { return n != m.n; }
	modint &operator += (const modint &m) { n += m.n; if (n >= mod) n -= mod; return *this; }
	modint &operator -= (const modint &m) { n -= m.n; if (n < 0) n += mod; return *this; }
	modint &operator *= (const modint &m) { n = ll(n) * m.n % mod; return *this; }
	modint &operator /= (const modint &m) { n = ll(n) * modinv(m).n % mod; return *this; }
	modint operator +(modint m) const { return modint(*this) += m; }
	modint operator -(modint m) const { return modint(*this) -= m; }
	modint operator *(modint m) const { return modint(*this) *= m; }
	modint operator /(modint m) const { return modint(*this) /= m; }
	modint &operator ++ () { *this += 1; return *this; }
	modint operator ++ (int) { *this += 1; return *this - 1; }
	modint &operator -- () { *this -= 1; return *this; }
	modint operator -- (int) { *this -= 1; return *this + 1; }
	modint pow(ll b) const {
		modint res = 1, a = modint(*this);
		while (b) {
			if (b & 1) res *= a;
			a *= a;
			b >>= 1;
		}
		return res;
	}
	friend istream &operator >> (istream &s, modint<mod> &a) { s >> a.n; return s; }
	friend ostream &operator << (ostream &s, modint<mod> &a) { s << a.n; return s; }
};

using mint = modint<mod>;
vector<mint> fac, inv, facinv;

mint modinv(mint x) {
	ll a = x.n;
	if (a == 0) abort();
	if (a < (ll)inv.size()) return inv[a];
	ll b = mod, u = 1, v = 0;
	while (b) {
		ll t = a / b;
		a -= t * b; swap(a, b);
		u -= t * v; swap(u, v);
	}
	mint res = u;
	return res;
}

void modcalc(int n) {
	fac.resize(n); inv.resize(n); facinv.resize(n);
	fac[0] = 1; fac[1] = 1; inv[1] = 1;
	facinv[0] = 1; facinv[1] = 1;
	for (ll i = 2; i < n; i++) {
		fac[i] = fac[i - 1] * i;
		inv[i] = -inv[mod % i] * (mod / i);
		facinv[i] = facinv[i - 1] * inv[i];
	}
}

mint comb(ll n, ll k) {
	if (n < 0 || k < 0 || n < k) return 0;
	return fac[n] * facinv[k] * facinv[n - k];
}

mint perm(ll n, ll k) {
	if (n < 0 || k < 0 || n < k) return 0;
	return fac[n] * facinv[n - k];
}

mint hom(ll n, ll k) {
	if (n < 0 || k < 0 || n == 0 && k > 0) return 0;
	if (n == 0 && k == 0) return 1;
	return fac[n + k - 1] * facinv[k] * facinv[n - 1];
}

template<class T> class segtree {
	int n;
	vector<T> data;
	T id = 0;
	T operation(T a, T b) { return max(a, b); }
public:
	segtree(int _n) {
		n = 1;
		while (n < _n + 2) n <<= 1;
		data = vector<T>(2 * n, id);
	}
	segtree(vector<T> vec) {
		int _n = vec.size();
		n = 1;
		while (n < _n + 2) n <<= 1;
		data = vector<T>(2 * n, id);
		for (int i = 0; i < _n; i++) data[i + n] = vec[i];
		for (int i = n - 1; i >= 1; i--) data[i] = operation(data[i << 1], data[i << 1 | 1]);
	}
	void change(int i, T x) {
		i += n;
		data[i] = x;
		while (i > 1) {
			i >>= 1;
			data[i] = operation(data[i << 1], data[i << 1 | 1]);
		}
	}
	void add(int i, T x) { change(i, data[i + n] + x); }
	T get(int a, int b) {
		T left = id; T right = id;
		a += n; b += n;
		while (a < b) {
			if (a & 1) left = operation(left, data[a++]);
			if (b & 1) right = operation(data[--b], right);
			a >>= 1; b >>= 1;
		}
		return operation(left, right);
	}
	T get_all() { return data[1]; }
	T operator[](int i) { return data[i + n]; }
};

class unionfind {
	vector<int> par;
	vector<int> sz;
	vector<int> val;
public:
	unionfind(int n) {
		par = vector<int>(n);
		for (int i = 0; i < n; i++) par[i] = i;
		sz = vector<int>(n, 1);
		val = vector<int>(n);
	}
	int find(int x) {
		if (par[x] == x) return x;
		else return par[x] = find(par[x]);
	}
	int size(int x) { return sz[find(x)]; }
	bool same(int x, int y) { return find(x) == find(y); }
	void add(int x) { val[find(x)]++; }
	int get(int x) { return val[find(x)]; }
	void unite(int x, int y) {
		x = find(x);
		y = find(y);
		if (x == y) return;
		if (sz[x] < sz[y]) {
			par[x] = y;
			sz[y] += sz[x];
			val[y] += val[x];
		}
		else {
			par[y] = x;
			sz[x] += sz[y];
			val[x] += val[y];
		}
	}
};

template<class T> vector<int> compress(vector<T> vec) {
	int vecsize = vec.size();
	vector<T> tmpvec = vec;
	sort(tmpvec.begin(), tmpvec.end());
	tmpvec.erase(unique(tmpvec.begin(), tmpvec.end()), tmpvec.end());
	vector<int> res(vecsize);
	for (int i = 0; i < vecsize; i++) res[i] = lower_bound(tmpvec.begin(), tmpvec.end(), vec[i]) - tmpvec.begin();
	return res;
}

int main() {
	while (true) {
		int n;
		cin >> n;
		if (n == 0) return 0;
		int ans = 0;
		req(i, 1, 1001) {
			req(j, i + 1, 1001) {
				int v = (i + j) * (j - i + 1) / 2;
			}
		}
		cout << ans << '\n';
	}
}
