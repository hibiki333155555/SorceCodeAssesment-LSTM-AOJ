#line 2 "/mnt/c/Users/Cyanmond/ProCon/Library/utilitys.hpp"
#include <algorithm>
#include <array>
#include <cstdint>
#include <cassert>
#include <iterator>
#include <limits>
#include <numeric>
#include <queue>
#include <tuple>
#include <type_traits>
#include <utility>

using i8 = std::int8_t;
using u8 = std::uint8_t;
using i16 = std::int16_t;
using i32 = std::int32_t;
using i64 = std::int64_t;
using u16 = std::uint16_t;
using u32 = std::uint32_t;
using u64 = std::uint64_t;

constexpr i8 operator""_i8(unsigned long long n) noexcept { return static_cast<i8>(n); }
constexpr i16 operator""_i16(unsigned long long n) noexcept {
    return static_cast<i16>(n);
}
constexpr i32 operator""_i32(unsigned long long n) noexcept {
    return static_cast<i32>(n);
}
constexpr i64 operator""_i64(unsigned long long n) noexcept {
    return static_cast<i64>(n);
}
constexpr u8 operator""_u8(unsigned long long n) noexcept { return static_cast<u8>(n); }
constexpr u16 operator""_u16(unsigned long long n) noexcept {
    return static_cast<u16>(n);
}
constexpr u32 operator""_u32(unsigned long long n) noexcept {
    return static_cast<u32>(n);
}
constexpr u64 operator""_u64(unsigned long long n) noexcept {
    return static_cast<u64>(n);
}

constexpr char eoln = '\n';

template <typename T, T Div = 2> constexpr T infty = std::numeric_limits<T>::max() / Div;
template <class T>
using RevPriorityQueue = std::priority_queue<T, std::vector<T>, std::greater<T>>;

constexpr std::array<std::pair<int, int>, 4> dxy4 = {{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}};

class Range {
    struct Iterator {
        int itr;
        constexpr Iterator(const int pos) noexcept : itr(pos) {}
        constexpr void operator++() noexcept { ++itr; }
        constexpr bool operator!=(const Iterator &other) const noexcept {
            return itr != other.itr;
        }
        constexpr int operator*() const noexcept { return itr; }
    };
    const Iterator first, last;

  public:
    explicit constexpr Range(const int f, const int l) noexcept
        : first(f), last(std::max(f, l)) {}
    constexpr Iterator begin() const noexcept { return first; }
    constexpr Iterator end() const noexcept { return last; }
};

class ReversedRange {
    struct Iterator {
        int itr;
        constexpr Iterator(const int pos) noexcept : itr(pos) {}
        constexpr void operator++() noexcept { --itr; }
        constexpr bool operator!=(const Iterator &other) const noexcept {
            return itr != other.itr;
        }
        constexpr int operator*() const noexcept { return itr; }
    };
    const Iterator first, last;

  public:
    explicit constexpr ReversedRange(const int f, const int l) noexcept
        : first(l - 1), last(std::min(f, l) - 1) {}
    constexpr Iterator begin() const noexcept { return first; }
    constexpr Iterator end() const noexcept { return last; }
};

#define SIKICM_REP1(i, r) for (const int i : Range(0, r))
#define SIKICM_REP2(i, l, r) for (int i : Range(l, r))
#define SIKICM_RVP1(i, r) for (const int i : ReversedRange(0, r))
#define SIKICM_RVP2(i, l, r) for (int i : ReversedRange(l, r))
#define SIKICM_SELECT2(a, b, c, name, ...) name
#define REP(...) SIKICM_SELECT2(__VA_ARGS__, SIKICM_REP2, SIKICM_REP1)(__VA_ARGS__)
#define RVP(...) SIKICM_SELECT2(__VA_ARGS__, SIKICM_RVP2, SIKICM_RVP1)(__VA_ARGS__)
#define HRL(n) for ([[maybe_unused]] const int loop_counter : Range(0, n))

template <class Container> constexpr int len(const Container &c) {
    return static_cast<int>(std::size(c));
}

template <typename T> constexpr bool chmin(T &v, const T a) {
    if (v > a) {
        v = a;
        return true;
    }
    return false;
}

template <typename T> constexpr bool chmax(T &v, const T a) {
    if (v < a) {
        v = a;
        return true;
    }
    return false;
}

template <typename T> constexpr T ceil_div(const T x, const T y) {
    assert(y != 0);
    assert(x > 0 and y > 0);
    return (x + y - 1) / y;
}

template <class Container, class T> constexpr int lwb(const Container &c, const T &val) {
    return static_cast<int>(
        std::distance(c.cbegin(), std::lower_bound(c.cbegin(), c.cend(), val)));
}

template <class Container, class T> constexpr int upb(const Container &c, const T &val) {
    return static_cast<int>(
        std::distance(c.cbegin(), std::upper_bound(c.cbegin(), c.cend(), val)));
}

template <class Container, class F> constexpr int lmp(const Container &c, const F &f) {
    return static_cast<int>(
        std::distance(c.cbegin(), std::partition_point(c.cbegin(), c.cend(), f)));
}

template <class F> class RecursiveLambda {
    F f;

  public:
    explicit constexpr RecursiveLambda(F &&f_) : f(std::forward<F>(f_)) {}
    template <class... Args> constexpr auto operator()(Args &&... args) const {
        return f(*this, std::forward<Args>(args)...);
    }
};

template <class F> constexpr decltype(auto) rec_lambda(F &&f) {
    return RecursiveLambda<F>(std::forward<F>(f));
}

template <class T, class... Tail>
void renumber(const std::vector<int> &order, std::vector<T> &head, Tail &... tail) {
    const int n = len(order);
    std::vector<T> sorted_head(n);
    REP(i, n) sorted_head[i] = head[order[i]];

    head = std::move(sorted_head);
    if constexpr (sizeof...(Tail) != 0) {
        renumber(order, tail...);
    }
}

template <class Head, class... Tail>
std::vector<int> priority_sort(std::vector<Head> &head, std::vector<Tail> &... tail) {
    const int n = len(head);
    std::vector<std::tuple<Head, Tail..., int>> res(n);
    REP(i, n) res[i] = std::make_tuple(head[i], tail[i]..., i);
    std::sort(res.begin(), res.end());

    std::vector<int> order(n);
    REP(i, 0, n)
    order[i] = std::get<std::tuple_size_v<std::tuple<Head, Tail...>>>(res[i]);
    renumber(order, head, tail...);
    return order;
}

template <class T> auto make_vec(const int n, const T &value) {
    return std::vector<T>(n, value);
}
template <class... Args> auto make_vec(const int n, Args... args) {
    return std::vector<decltype(make_vec(args...))>(n, make_vec(args...));
}

std::vector<int> iotav(const int n) {
    std::vector<int> ret(n);
    std::iota(ret.begin(), ret.end(), 0);
    return ret;
}

template <class T> std::vector<T> make_prefix_sum(const std::vector<T> &vec) {
    const int n = len(vec);
    std::vector<T> res(n + 1);
    REP(i, n) res[i + 1] = res[i] + vec[i];
    return res;
}

template <class Container> auto calc_sum(const Container &c) {
    return std::accumulate(c.cbegin(), c.cend(),
                           static_cast<typename Container::value_type>(0));
}

template <class T, class F, class... Args>
int apply_id(T first, T last, F &&func, Args &&... args) {
    return std::distance(first, func(first, last, std::forward<Args>(args)...));
}
#line 2 "main.cpp"
#include <bits/stdc++.h>

using namespace std;

#define ALL(x) (x).begin(), (x).end()
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

int main() {
    i64 A, B;
    cin >> A >> B;
    if (A==0 and B==0) {
        cout<<1<<endl;
        return 0;
    }
    bitset<40> a(A), b(B);
    string sa = a.to_string(), sb = b.to_string();
    while (sa[0] == '0' and sb[0] == '0') {
        sa.erase(sa.begin());
        sb.erase(sb.begin());
    }
    int ans = 0;
    REP(i, len(sa)) if (sa[i] == sb[i]) { ++ans; }
    else {
        break;
    }
    cout << ans << endl;
}

