// #pragma GCC target("avx2")
#pragma GCC optimize("O3")
// #pragma GCC optimize("unroll-loops")
#include<bits/stdc++.h>
using namespace std;

using P = pair<int, int>;
const int M = 998244353;



#define MOD 1000000007

template <unsigned int mod>
class ModInt {
private:
    unsigned int v;
    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }
    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }
    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }
    static unsigned int inverse(int a, int m){
        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;
        while(*v){
            t = *u / *v;
            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);
        }
        return (u[1] % m + m) % m;
    }

public:
    ModInt() : v{0}{}
    ModInt(const long long val) : v{norm(val % mod + mod)} {}
    ModInt(const ModInt<mod>& n) : v{n()} {}
    explicit operator bool() const noexcept { return v != 0; }
    bool operator!() const noexcept { return !static_cast<bool>(*this); }
    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }
    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }
    ModInt operator+() const { return *this; }
    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }
    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }
    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }
    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }
    ModInt operator/(const ModInt& val) const { return *this * inv(val); }
    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }
    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }
    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }
    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }
    ModInt operator+(const long long val) const { return ModInt{v + val}; }
    ModInt operator-(const long long val) const { return ModInt{v - val}; }
    ModInt operator*(const long long val) const { return ModInt{(long long)(v * (val % mod))}; }
    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }
    ModInt& operator+=(const long long val){ return *this = *this + val; }
    ModInt& operator-=(const long long val){ return *this = *this - val; }
    ModInt& operator*=(const long long val){ return *this = *this * val; }
    ModInt& operator/=(const long long val){ return *this = *this / val; }
    bool operator==(const ModInt& val) const { return v == val.v; }
    bool operator!=(const ModInt& val) const { return !(*this == val); }
    bool operator==(const long long val) const { return v == norm(val % mod + mod); }
    bool operator!=(const long long val) const { return !(*this == val); }
    unsigned int operator()() const { return v; }
    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }
    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }
    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }
    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }
    friend bool operator==(const long long val, const ModInt& n) { return n == val; }
    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }
    friend istream& operator>>(istream& is, ModInt& n){
        unsigned int v;
        return is >> v, n = v, is;
    }
    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }
    friend ModInt mod_pow(ModInt x, long long n){
        ModInt ans = ((mod == 1) ? 0 : 1);
        while(n){
            if(n & 1) ans *= x;
            x *= x, n >>= 1;
        }
        return ans;
    }
};

template<typename T> class mat : public vector<vector<T> > {
private:
    int r, c;    //行,列
public:
    inline int row() const {
        return r;
    }
    inline int column() const {
        return c;
    }
    mat(int n, int m, T val = 0){
        r = n, c = m;
        for(int i = 0; i < n; i++){
            this->push_back(vector<T>(m, val));
        }
    }
    mat operator+(const mat& another) const {
        if(r != another.r && c != another.c){
            cout << "足し算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] + another[i][j];
            }
        }
        return X;
    }
    mat operator+(const T val) const {
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] + val;
            }
        }
        return X;
    }
    mat operator-(const mat& another) const {
        if(r != another.r && c != another.c){
            cout << "引き算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] - another[i][j];
            }
        }
        return X;
    }
    mat operator-(const T val) const {
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] - val;
            }
        }
        return X;
    }
    vector<T> operator*(const vector<T>& another) const {
        if(c != (int)another.size()){
            cout << "掛け算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        vector<T> vec(r,0);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                vec[i] += (*this)[i][j] * another[j];
            }
        }
        return vec;
    }
    mat operator*(const mat& another) const {
        if(c != another.r){
            cout << "掛け算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        mat<T> X(r, another.c);
        for(int i = 0; i < r; i++){
            for(int k = 0; k < c; k++){
                for(int j = 0; j < (another.c); j++){
                    X[i][j] += (*this)[i][k] * another[k][j];
                }
            }
        }
        return X;
    }
    mat operator-() const {
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = -(*this)[i][j];
            }
        }
        return X;
    }
    int rank() const {
        int res = 0;
        mat B(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                B[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i < c; i++){
            if(res == r) return res;
            int pivot = res;
            for(int j = res; j < r; j++){
                if(B[j][i]){
                    pivot = j;
                    break;
                }
            }
            if(!B[pivot][i]) continue;
            swap(B[pivot], B[res]);
            const T d = (T)1 / B[res][i];
            for(int j = i + 1; j < c; j++){
                B[res][j] *= d;
            }
            for(int j = res + 1; j < r; j++){
                if(!B[j][i]) continue;
                for(int k = i + 1; k < c; k++){
                    B[j][k] -= B[res][k] * B[j][i];
                }
            }
            ++res;
        }
        return res;
    }
    T det() const {
        if(r != c){
            cout << "正方行列でない(行列式定義不可)" << endl;
            exit(1);
        }
        T ans = 1;
        mat B(r, r);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                B[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i < c; i++){
            int pivot = i;
            for(int j = i; j < r; j++){
                if(B[j][i]){
                    pivot = j;
                    break;
                }
            }
            if(!B[pivot][i]) return (T)0;
            if(pivot != i) swap(B[i], B[pivot]), ans = -ans;
            ans *= B[i][i];
            const T d = (T)1 / B[i][i];
            for(int j = i + 1; j < c; j++){
                B[i][j] *= d;
            }
            for(int j = i + 1; j < r; j++){
                if(!B[j][i]) continue;
                for(int k = i + 1; k < c; k++){
                    B[j][k] -= B[i][k] * B[j][i];
                }
            }
        }
        return ans;
    }
    mat inverse() const {
        if(r != c){
            cout << "正方行列でない(逆行列定義不可)" << endl;
            exit(1);
        }
        mat B(r, 2*r);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < r; j++){
                B[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i < r; i++){
            B[i][r+i] = 1;
        }
        for(int i = 0; i < r; i++){
            int pivot = i;
            for(int j = i; j < r; j++){
                if(B[j][i]){
                    pivot = j;
                    break;
                }
            }
            if(!B[pivot][i]){
                cout << "正則でない" << endl;
                exit(1);
            }
            swap(B[i], B[pivot]);
            const T d = (T)1 / B[i][i];
            for(int j = i + 1; j < 2*r; j++){
                B[i][j] *= d;
            }
            for(int j = 0; j < r; j++){
                if(j == i || !B[j][i]) continue;
                for(int k = i + 1; k < 2*r; k++){
                    B[j][k] -= B[i][k] * B[j][i];
                }
            }
        }
        mat res(r, r);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < r; j++){
                res[i][j] = B[i][r+j];
            }
        }
        return res;
    }
    inline void print() const {
        for(int i = 0; i < r; i++){
            for(int j = 0; j < (c-1); j++){
                cout << (*this)[i][j] << ",";
            }
            cout << (*this)[i][c-1] << endl;
        }
    }
};

template<typename T> vector<T> eq_solve(const mat<T>& A, const vector<T>& b){
    if(A.row() != A.column()){
        cout << "正方行列でない(解なしor不定)" << endl;
        exit(1);
    }
    int n = A.row();
    mat<T> B(n, n+1);
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            B[i][j] = A[i][j];
        }
    }
    for(int i = 0; i < n; i++){
        B[i][n] = b[i];
    }
    for(int i = 0; i < n; i++){
        int pivot = i;
        for(int j = i; j < n; j++){
            if(B[j][i]){
                pivot = j;
                break;
            }
        }
        if(!B[pivot][i]){
            cout << "解なしor不定" << endl;
            exit(1);
        }
        swap(B[i], B[pivot]);
        const T d = (T)1 / B[i][i];
        for(int j = i + 1; j <= n; j++){
            B[i][j] *= d;
        }
        for(int j = 0; j < n; j++){
            if(i != j){
                for(int k = i + 1; k <= n; k++){
                    B[j][k] -= B[i][k] * B[j][i];
                }
            }
        }
    }
    vector<T> res(n);
    for(int i = 0; i < n; i++){
        res[i] = B[i][n];
    }
    return res;
}

template<typename T> mat<T> pow(mat<T> A, long long cnt)
{
    if(A.row() != A.column()){
        cout << "累乗不可" << endl;
    }
    int n = A.row();
    mat<T> B(n, n);
    for(int i = 0; i < n; i++){
        B[i][i] = 1;
    }
    while(cnt > 0){
        if(cnt & 1) B = B * A;
        A = A * A;
        cnt >>= 1;
    }
    return B;
}

using mod = ModInt<M>;


vector<long long> values(26);
vector<pair<long long, long long>> lis;

int f_value_name(const string& line, int& ptr) {
    // cout << line << ' ' << line[ptr] << endl;
    assert('a' <= line[ptr] && line[ptr] <= 'z');
    int res = line[ptr] - 'a';
    ++ptr;
    return res;
}
long long f_number(const string& line, int& ptr) {
    long long res = 0;
    while ('0' <= line[ptr] && line[ptr] <= '9') {
        res = (res * 10 + line[ptr] - '0') % M;
        ++ptr;
    }
    return res;
}

void f_term(const string& line, int& ptr, vector<long long>& res) {
    bool minus = false;
    if (line[ptr] == '-') {
        minus = true;
        ++ptr;
    }
    else if (line[ptr] == '+') {
        ++ptr;
    }
    if ('a' <= line[ptr] && line[ptr] <= 'z') {
        int vn = f_value_name(line, ptr);
        if (minus) {
            res[vn] = (res[vn] + M - 1) % M;
        }
        else {
            res[vn] = (res[vn] + 1) % M;
        }
    }
    else if ('0' <= line[ptr] && line[ptr] <= '9') {
        long long num = f_number(line, ptr);
        if (minus) {
            res[26] = (res[26] + M - num) % M;
        }
        else {
            res[26] = (res[26] + num) % M;
        }
    }
    else {
        // cout << line << endl;
        // cout << line[ptr] << endl;
        assert(false);
    }
}

vector<long long> f_expression(const string& line, int& ptr) {
    vector<long long> res(27);
    while (ptr < (int)line.size() && (line[ptr] == '-' || line[ptr] == '+' || '0' <= line[ptr] && line[ptr] <= '9' || 'a' <= line[ptr] && line[ptr] <= 'z')) {
        f_term(line, ptr, res);
    }
    return res;
}

pair<int, vector<long long>> f_assignment(const string& line, int& ptr) {
    int vn = f_value_name(line, ptr);
    assert(line[ptr] == '<' && line[ptr + 1] == '-');
    ptr += 2;
    vector<long long> expr = f_expression(line, ptr);
    assert(ptr == (int)line.size());
    return { vn, expr };
}

long long evaluate(const vector<long long>& c) {
    long long res = 0;
    for (int i = 0; i < 26; ++i) {
        res = (res + c[i] * values[i]) % M;
    }
    res = (res + c[26]) % M;
    return res;
}

void evaluate_assignment(int vn, const vector<long long>& c, long long for_count) {
    long long res = 0;
    for (int i = 0; i < 26; ++i) {
        if (i == vn) continue;;
        res = (res + c[i] * values[i]) % M;
    }
    res = (res + c[26]) % M;

    long long a = c[vn];
    long long b = res;

    mat<mod> mt(2, 2);
    mt[0][0] = a;
    mt[0][1] = b;
    mt[1][1] = 1;
    mt = pow(mt, for_count);

    long long x = (mt[0][0] * values[vn] + mt[0][1])();
    values[vn] = x;
}


long long f_print(const string& line, int& ptr) {
    assert(line.substr(ptr, 6) == "print(");
    ptr += 6;
    vector<long long> expr = f_expression(line, ptr);
    assert(line[ptr] == ')');
    ++ptr;
    assert(ptr == (int)line.size());
    long long val = evaluate(expr);
    return val;
}

long long f_for_element(const string& line, int& ptr) {
    assert(line.substr(ptr, 4) == "for(");
    ptr += 4;
    vector<long long> expr = f_expression(line, ptr);
    assert(line[ptr] == ')');
    ++ptr;
    long long val = evaluate(expr);
    return val;
}

void add_ans(long long val, long long count) {
    if (count == 0) return;
    if (lis.size() && lis[(int)lis.size() - 1].first == val) {
        lis[(int)lis.size() - 1].second += count;
    }
    else {
        lis.emplace_back(val, count);
    }
}

void f_for(const string& line, int& ptr) {
    long long for_count = 1;
    while (ptr + 3 < (int)line.size() && line.substr(ptr, 4) == "for(") {
        for_count *= f_for_element(line, ptr);
    }
    if (ptr + 5 < (int)line.size() && line.substr(ptr, 6) == "print(") {
        long long val = f_print(line, ptr);
        add_ans(val, for_count);
    }
    else {
        pair<int, vector<long long>> rs = f_assignment(line, ptr);
        evaluate_assignment(rs.first, rs.second, for_count);
    }
}

void initialize() {
    values = vector<long long>(26);
    lis = vector<pair<long long, long long>>();
}

vector<pair<long long, long long>> solve(int n) {
    initialize();
    for (int _ = 0; _ < n; ++_) {
        string line;
        cin >> line;

        if (line.size() == 1) continue;
        int ptr = 0;
        if (ptr + 5 < (int)line.size() && line.substr(ptr, 6) == "print(") {
            long long val = f_print(line, ptr);
            add_ans(val, 1);
        }
        else if (ptr + 3 < (int)line.size() && line.substr(ptr, 4) == "for(") {
            f_for(line, ptr);
        }
        else {
            pair<int, vector<long long>> res = f_assignment(line, ptr);
            evaluate_assignment(res.first, res.second, 1);
        }
        assert(ptr == (int)line.size());
    }
    return lis;
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);
    while (true) {
        int n, m;
        cin >> n >> m;
        if (n == 0) break;
        auto ans1 = solve(n);
        auto ans2 = solve(m);
        cout << (ans1 == ans2 ? "Yes" : "No") << '\n';
    }

    return 0;
}

