import Control.Monad
import Control.Applicative
import Data.List

data Dice = Dice{tp::Int, ft::Int, rt::Int, lt::Int, bk::Int, bm::Int} deriving (Show, Eq)

roll :: Dice -> Char -> Dice
roll (Dice tp ft rt lt bk bm) dr
  | dr == 'N' = Dice ft bm rt lt tp bk
  | dr == 'S' = Dice bk tp rt lt bm ft
  | dr == 'E' = Dice lt ft tp bm bk rt
  | dr == 'W' = Dice rt ft bm tp bk lt
  | otherwise = Dice tp ft rt lt bk bm

rolls :: Dice -> String -> Dice
rolls d s = foldl roll d s

initDice :: [Int] -> Dice
initDice [tp, ft, rt, lt, bk, bm] = Dice tp ft rt lt bk bm

main :: IO ()
main = do
    a <- map read . words <$> getLine :: IO [Int]
    let ds = initDice a
    b <- map read . words <$> getLine :: IO [Int]
    --forM_ [1..n] $ \_ -> do
    print $ mchroll ds b

mchroll  ds  b
    | b!!0 == (tp ds) && b!!1 == (ft ds) && 
        b!!2 == (rt ds) && b!!3 == (lt ds) = "Yes"
    | b!!1 == (lt ds) || b!!1 == (rt ds) = mchroll (roll ds 'W') b
    | b!!1 /= (ft ds) =  mchroll (roll ds 'S') b
    | b!!0 /= (tp ds) =  mchroll (roll ds 'W') b
    | otherwise = "No"


