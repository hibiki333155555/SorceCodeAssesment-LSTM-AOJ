#[allow(unused_macros)]
macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , " = {:?}, " ) ,* ) , $ ( $ a ) ,* ) ; } }
#[macro_export]
macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }
#[macro_export]
macro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }
#[macro_export]
macro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( "Parse error" ) } ; }
use std::io;
use std::io::BufRead;
use std::str;
pub struct Parser<R> {
    reader: R,
    buf: Vec<u8>,
    pos: usize,
}
impl Parser<io::Empty> {
    pub fn from_str(s: &str) -> Parser<io::Empty> {
        Parser {
            reader: io::empty(),
            buf: s.as_bytes().to_vec(),
            pos: 0,
        }
    }
}
impl<R: BufRead> Parser<R> {
    pub fn new(reader: R) -> Parser<R> {
        Parser {
            reader: reader,
            buf: vec![],
            pos: 0,
        }
    }
    pub fn update_buf(&mut self) {
        self.buf.clear();
        self.pos = 0;
        loop {
            let (len, complete) = {
                let buf2 = self.reader.fill_buf().unwrap();
                self.buf.extend_from_slice(buf2);
                let len = buf2.len();
                if len == 0 {
                    break;
                }
                (len, buf2[len - 1] <= 0x20)
            };
            self.reader.consume(len);
            if complete {
                break;
            }
        }
    }
    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {
        loop {
            let mut begin = self.pos;
            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {
                begin += 1;
            }
            let mut end = begin;
            while end < self.buf.len() && (self.buf[end] > 0x20) {
                end += 1;
            }
            if begin != self.buf.len() {
                self.pos = end;
                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();
            } else {
                self.update_buf();
            }
        }
    }
}

fn main() {
    input! {
        v_num: usize,
        e_num: usize,
        w_edges: [(usize, usize, usize); e_num],
    }

    let mut graph = Graph::new(v_num);
    for edge in w_edges {
        graph.add_edge(edge.0, edge.1, edge.2);
    }

    let ans = ford_fulkerson(&mut graph.g, v_num);
    println!("{}", ans);
}

#[derive(Debug, Copy, Clone)]
pub struct Edge {
    index: usize,
    rev_index: usize,
    from: usize,
    to: usize,
    cap: usize,
    // フローの初期値
    // original_capが0より大きければ、順フロー
    original_cap: usize,
}

struct Graph {
    g: Vec<Vec<Edge>>,
}

impl Graph {
    pub fn new(v_num:usize) -> Self {
        Graph { g: vec![vec![]; v_num] }
    }

    pub fn add_edge(&mut self, from: usize, to: usize, original_cap: usize) {
        //  let mut gto =  &self.g[to];
        let to_idx = self.g[to].len();
        let from_idx = self.g[from].len();
        self.g[from].push(Edge {
            index: from_idx,
            rev_index: to_idx,
            from,
            to,
            original_cap,
            cap: original_cap,
        });

        // 逆流辺の初期値は0
        self.g[to].push(Edge {
            index: to_idx,
            rev_index: from_idx,
            from: to,
            to: from,
            original_cap: 0,
            cap: 0,
        });
    }
}

// fn dfs(g: Vec<Vec<Edge>>, s: usize, v: usize) -> usize {
// }

pub fn dfs(
    graph: &mut Vec<Vec<Edge>>,
    s: usize,
    t: usize,
    used: &mut Vec<bool>,
    f: usize,
) -> usize {
    if s == t {
        return f;
    }

    used[s] = true;
    let search_edges = graph[s].clone();
    // let t = &mut graph[s];
    for ne in search_edges {
        let is_next_used = !used[ne.to];
        if is_next_used && ne.cap > 0 {
            let f = dfs(graph, ne.to, t, used, std::cmp::min(f, ne.cap));
            if f > 0 {
                graph[ne.from][ne.index].cap -= f;
                // rev_edge(graph, &ne).cap += f;
                graph[ne.to][ne.rev_index].cap += f;
                return f;
            }
        }
    }
    return 0;
}

pub fn ford_fulkerson(graph: &mut Vec<Vec<Edge>>, e_index: usize) -> usize {
    let f = std::usize::MAX;
    let mut ans = 0;
    loop {
        let f = dfs(graph, 0, e_index-1, &mut vec![false; e_index], f);
        if f == 0 {
            break;
        }
        ans += f;
    }
    ans
}

