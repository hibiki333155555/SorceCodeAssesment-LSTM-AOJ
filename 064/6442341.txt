#include<iostream>
#include<vector>
#define I 0x7fffffff

using namespace std;

int* dijkstra(vector<vector<pair<int, int> > >& list)
{
    int num = list.size();
    bool* pd = new bool[num];
    int* track = new int[num];
    for (int i = 0;i < num;++i)
    {
        track[i] = I;
        pd[i] = false;
    }
    track[0] = 0;
    pd[0] = true;
    int dot, minVal, formerDot;
    while (true)
    {
        minVal = I;
        dot = -1;
        for (int i = 0;i < num;++i)
        {
            if (pd[i])     //遍历已经走过的点
            {
                for (int j = 0;j < list[i].size();++j)
                {
                    if (!pd[list[i][j].first] && list[i][j].second < minVal)
                    {
                        formerDot = i;    //formerDot为已经走过的点的下标
                        dot = list[formerDot][j].first;
                        minVal = list[formerDot][j].second;
                    }
                }
            }
        }
        if (dot == -1)
            return track;
        track[dot] = min(minVal + track[formerDot], track[dot]);
        pd[dot] = true;
        for (int j = 0;j < list[dot].size();++j)
            if (pd[list[dot][j].first])
                track[list[dot][j].first] = min(list[dot][j].second + track[dot], track[list[dot][j].first]);
    }
}

int main()
{
    int m, n, node, value, temp;
    cin >> n;
    vector<vector<pair<int, int> > > Input(n);
    int* key = new int[n];
    while (n--)
    {
        cin >> temp >> m;
        while (m--)
        {
            cin >> node >> value;
            Input[temp].push_back(make_pair(node, value));
        }
    }
    key = dijkstra(Input);
    for (int i = 0;i < Input.size();++i)
        cout << i << " " << key[i] << endl;
    return 0;
}
