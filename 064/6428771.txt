#include <iostream>
#include <vector>
using namespace std;

// 入力
int N, A[1 << 18], B[1 << 18];
int Q, X[1 << 18], Y[1 << 18];

// べき乗
const long long mod = 998244353;
long long power2[1 << 18];

// LCA
vector<int> G[1 << 18];
vector<int> H[1 << 18];
int dist[1 << 18];
int parent[1 << 18][20];

// 全方位木 DP
long long dp1[1 << 18];
long long dp2[1 << 18];

void dfs(int pos, int par, int dep) {
	dist[pos] = dep;
	for (int to : G[pos]) {
		if (to == par) continue;
		dfs(to, pos, dep + 1);
		H[pos].push_back(to);
		parent[to][0] = pos;
	}
}

void dfs2(int pos) {
	dp1[pos] = 1;
	for (int to : H[pos]) {
		dfs2(to);
		dp1[pos] += 2LL * dp1[to];
		dp1[pos] %= mod;
	}
}

void dfs3(int pos, int par) {
	// 全体のスコアの計算
	long long Sum = 0;
	for (int to : H[pos]) { Sum += 2LL * dp1[to]; Sum %= mod; }

	// 各子に対するスコアの計算
	for (int to : H[pos]) {
		long long Up = dp2[pos];
		long long Down = (Sum - 2LL * dp1[to] + mod * mod) % mod;
		dp2[to] = (2LL * (Up + Down) + 1LL) % mod;
	}

	// 再帰
	for (int to : H[pos]) dfs3(to, pos);
}

int prevs(int pos, int x) {
	for (int i = 19; i >= 0; i--) {
		if (x >= (1 << i)) { x -= (1 << i); pos = parent[pos][i]; }
	}
	return pos;
}

int LCA(int u, int v) {
	if (dist[u] > dist[v]) swap(u, v);
	v = prevs(v, dist[v] - dist[u]);
	if (u == v) return u;

	for (int i = 19; i >= 0; i--) {
		if (parent[u][i] == parent[v][i]) continue;
		u = parent[u][i];
		v = parent[v][i];
	}
	return parent[u][0];
}

int GetDist(int u, int v) {
	int w = LCA(u, v);
	return dist[u] + dist[v] - 2 * dist[w];
}

long long Query(int x, int y) {
	if (dist[x] > dist[y]) swap(x, y);
	int w1 = prevs(y, dist[y] - dist[x]);
	int w2 = prevs(y, dist[y] - dist[x] - 1);

	// 片方がもう片方の子孫の場合
	if (w1 == x) {
		long long r1 = dp2[x] + (dp1[x] - 2LL * dp1[w2] - 1LL);
		r1 = (r1 + mod * mod) % mod;
		long long r2 = dp1[y];
		long long r3 = power2[GetDist(x, y)];
		return ((r1 * r2 % mod) * r3 % mod);
	}

	// そうでない場合
	else {
		long long r1 = dp1[x];
		long long r2 = dp1[y];
		long long r3 = power2[GetDist(x, y)];
		return ((r1 * r2 % mod) * r3 % mod);
	}
}

int main() {
	// Step #1. 入力
	cin >> N;
	for (int i = 1; i <= N - 1; i++) cin >> A[i] >> B[i];
	cin >> Q;
	for (int i = 1; i <= Q; i++) cin >> X[i] >> Y[i];

	// Step #2. LCA を求める
	for (int i = 1; i <= N - 1; i++) {
		G[A[i]].push_back(B[i]);
		G[B[i]].push_back(A[i]);
	}
	dfs(1, -1, 0);
	for (int i = 0; i < 19; i++) {
		for (int j = 1; j <= N; j++) parent[j][i + 1] = parent[parent[j][i]][i];
	}

	// Step #3. 全方位木 DP
	power2[0] = 1; dp2[1] = 1;
	for (int i = 1; i <= N; i++) power2[i] = (2LL * power2[i - 1]) % mod;
	dfs2(1);
	dfs3(1, -1);

	// Step #4. 答えを求める
	for (int i = 1; i <= Q; i++) {
		cout << Query(X[i], Y[i]) << endl;
	}
	return 0;
}
