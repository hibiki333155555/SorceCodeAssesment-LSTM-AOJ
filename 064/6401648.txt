#include "bits/stdc++.h"

#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(x) (x).begin(),(x).end()
#define INF (1LL << 60)
using namespace std;
using ll = long long;
using P = pair<int, int>;
using Pl = pair<ll, ll>;
using T = tuple<int, int, int>;



ll a, b, c, d, e;
ll N, E, y;
ll G[20][20];  // グラフ
ll dp[(1 << 20) + 1][21]; // dpテーブルは余裕をもったサイズにする


/* メモ化再帰 */
ll rec(int bit, ll v)
{
    a++;
    // すでに探索済みだったらリターン
    //if (dp[bit][v] != -1) return dp[bit][v];

    b++;
    // 初期値 (v(最後に訪れた頂点)だけが1(探索済み))
    if (bit == (1 << v)) {
        //cout << y << " " << v << endl;
        //cout << G[y][v] << endl << endl;
        return dp[bit][v] = G[y][v];

    }
    c++;
    ll res = INF; // 最短距離

    int prev_bit = bit &~ (1 << v); // ｖを探索済みに変える( &~ は Nand )
    //cout << bit << " " << (1 << v) << endl;
    //cout << prev_bit << endl << endl;


    for (ll u = 0; u < N; ++u) {
        if ((prev_bit & (1 << u)) == 0) continue; // u が探索済みなら
        d++;
        // 再帰的に探索
        if (res > rec(prev_bit, u) + G[u][v]) {
            res = rec(prev_bit, u) + G[u][v];
            //cout << res << endl;
            e++;
        }
        //cout << res << endl;
       
    }

    return dp[bit][v] = res; // メモしながらリターン
}

/*
3 3 
0 1 1 
1 2 2
2 0 3
*/

int main()
{
    // 入力
    cin >> N >> E;

    // グラフの初期化
    rep(i,0, 20) {
        rep(j,0, 20) { G[i][j] = INF; }
    }
    rep(i,0, E) {
        ll s, t, d;
        cin >> s >> t >> d;
        G[s][t] = d;
        //cout << s << t << G[s][t] << endl;
    }



    // テーブルを全部 -1 にしておく (-1 でなかったところは探索済)
    for (int bit = 0; bit < (1 << N); ++bit) for (ll v = 0; v < N; ++v) dp[bit][v] = -1;

    // 探索
    ll res = INF;
    for (ll v = 0; v < N; ++v) { // u は最後に通る頂点
        y = v;
        
        if (res > rec((1 << N) - 1, v)) {
            res = rec((1 << N) - 1, v); // 1が探索済み(逆から探索)
        }
        //cout << res << endl;
    }

    if (res >= INF) cout << -1 << endl;
    else cout << res << endl;
    
}
