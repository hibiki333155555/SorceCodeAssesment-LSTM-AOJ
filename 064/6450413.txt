#include<iostream>
#include<algorithm>    
#include<bitset>
#include<cassert>
#include<cctype>
#include<cmath>
#include<ctime>
#include<fstream>
#include<functional>
#include<map>
#include<math.h>
#include<numeric>
#include<queue>
#include<set>
#include<stack>
#include<stdio.h>
#include<string>
#include<tuple>
#include<vector>
//#include<bits/stdc++.h>
//#include <atcoder/all>
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#define rep(i, x) for(ll i = 0; i < x; i++)
#define rep2(i, x) for(ll i = 1; i <= x; i++)
#define rep3(i, x, y) for(ll i = x; i < y; i++)
#define REP(i, x) for(ll i = x - 1; i >= 0; i--)
#define REP2(i, x) for(ll i = x; i >= 1; i--)
#define fi first
#define se second
#define mpa make_pair
#define mpt make_tuple
#define pb push_back
#define all(a) (a).begin(),(a).end()
#define rall(a) (a).rbegin(),(a).rend()
#define puts(x) cout << (x) << "\n"
using ll = long long;
using ld = long double;
using namespace std;
//using namespace atcoder;
//using mint = modint998244353;
//using mint = modint1000000007;

const ll INF = 1000000000000000000;
const int intINF = 1000000000;
const ll mod = 1000000007;
const ll MOD = 998244353;
const ld pi = acos(-1);
//const ld EPS = 1e-9;
typedef string::const_iterator State;
class ParseError {};

template <typename T>
bool chmax(T& a, const T& b) {
	if (a < b) {
		a = b;  // aをbで更新
		return true;
	}
	return false;
}
// aよりもbが小さいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmin(T& a, const T& b) {
	if (a > b) {
		a = b;  // aをbで更新
		return true;
	}
	return false;
}

bool isprime(int p) {
	if (p == 1) return false;
	for (int i = 2; i < p; i++) {
		if (p % i == 0) return false;
	}
	return true;
}
//エラトステネスの篩
vector<bool> isprime_format(ll n) {
	vector<bool> P(n + 1, 1); P[0] = P[1] = 1;
	for (ll i = 2; i * i <= n; i++) {
		if (!P[i]) continue;
		for (int j = i + i; j <= n; j += i) P[j] = false;
	}
	return P;
}
vector<ll> prime_format(ll n) {
	vector<bool> P = isprime_format(n);
	vector<ll> ans;
	for (int i = 2; i <= n; i++) {
		if (P[i]) ans.push_back(i);
	}
	return ans;
}
ll gcd(ll a, ll b) {
	if (b == 0) { return a; }
	return gcd(b, a % b);
}
//ax + by = cが整数解をもつための必要十分条件は c が gcd(a,b) で割り切れること。
// 返り値: a と b の最大公約数
// ax + by = gcd(a, b) を満たす (x, y) が格納される
//main関数内に extGCD(a, b, x, y); でx, yに解が格納
ll extGCD(ll a, ll b, ll& x, ll& y) {
	if (b == 0) {
		x = 1;
		y = 0;
		return a;
	}
	ll d = extGCD(b, a % b, y, x);
	y -= a / b * x;
	return d;
}
ll lcm(ll a, ll b) {
	return a / gcd(a, b) * b;
}
ll keta(ll n) {
	ll res = 0;
	while (n >= 1) {
		//res++;
		res += n % 10;

		n /= 10;
	}
	return res;
}
ll modpow(ll x, ll y, ll m) {
	ll res = 1;
	while (y) {
		if (y % 2) { res *= x; res %= m; }
		x = x * x % m; y /= 2;
	}
	return res;
}

const int nCkMAX = 212345;
ll fac[nCkMAX], finv[nCkMAX], inv[nCkMAX];//n!、1/n!、1/n
// テーブルを作る前処理
void nCkinit(ll m) {
	fac[0] = fac[1] = 1;
	finv[0] = finv[1] = 1;
	inv[1] = 1;
	for (int i = 2; i < nCkMAX; i++) {
		fac[i] = fac[i - 1] * i % m;
		inv[i] = m - inv[m % i] * (m / i) % m;
		finv[i] = finv[i - 1] * inv[i] % m;
	}
}
// 二項係数計算
ll nCk(ll n, ll k, ll m) {
	if (n < k) return 0;
	if (n < 0 || k < 0) return 0;
	return fac[n] * (finv[k] * finv[n - k] % m) % m;
}
//nが大きくてkが小さい時
//nCkMAXはk+2まででOK
ll nCk2(ll n, ll k, ll m) {
	ll res = 1;
	for (int i = n - k + 1; i <= n; i++) {
		res *= i; res %= m;
	}
	res = res * finv[k] % m;
	return res;
}

//xorshift　from 「ビット演算 (bit 演算) の使い方を総特集！ 」
//1~6まで出したいときは
//xorshift() % 6 + 1
unsigned int xorshift() {
	static unsigned int tx = 123456789, ty = 362436069, tz = 521288629, tw = 88675123;
	unsigned int tt = (tx ^ (tx << 11));
	tx = ty; ty = tz; tz = tw;
	return (tw = (tw ^ (tw >> 19)) ^ (tt ^ (tt >> 8)));
}
uint64_t seed = 123456789;
uint64_t xorshift64() {
	seed ^= seed << 13;
	seed ^= seed >> 17;
	seed ^= seed << 7;
	return seed;
}
int rand_int(int l, int r) {
	return l + int(xorshift64() % (r - l));
}
double randouble() {
	return double(xorshift64()) / double(uint64_t(-1));
}


//printf("%.10f\n", n);
typedef pair <ll, ll> P;
typedef pair <ld, ll> pp;
ll dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };
ll ndx[4] = { 1, -1, -1, 1 }, ndy[4] = { 1, 1, -1, -1 };
char ds[4] = { 'd', 'r', 'u', 'l' };
char dl[4] = { 'D', 'R', 'U', 'L' };


vector<ll> spf;
void smallest_prime_factors(ll n) {
	spf.resize(n + 1); spf[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!spf[i]) {
			for (int j = i; j < n; j += i) { spf[j] = i; }
		}
	}
}
std::map<int, int> high_speed_prime_factor(int n) {
	std::map<int, int> res;
	while (n != 1) {
		res[spf[n]]++;
		n /= spf[n];
	}
	return res;
}

////////////////////////////////struct
struct Point {
	ll x, y;
};
bool operator<(const Point& a1, const Point& a2) {
	if (a1.x < a2.x) return true;
	if (a1.x > a2.x) return false;
	if (a1.y < a2.y) return true;
	return false;
}
struct status {
	ll c;
	ll r;

	//bool operator<(const status& rhs) const { return c < rhs.c; };
	//bool operator>(const status& rhs) const { return c > rhs.c; };
	bool operator<(const status& rhs) const { return r < rhs.r; };
	bool operator>(const status& rhs) const { return r > rhs.r; };
};
void yes(bool a) { cout << (a ? "yes" : "no") << endl; }
void YES(bool a) { cout << (a ? "YES" : "NO") << endl; }
void Yes(bool a) { cout << (a ? "Yes" : "No") << endl; }
struct edge {
	ll to; ll cost;
};

struct lazyseg {
	// 遅延評価セグメント木をソラで書きたいあなたに
	ll nn = 1; vector<ll> node, lazy;// 値配列、遅延配列

	lazyseg(ll n) {
		while (nn < n) { nn *= 2; }
		node.resize(nn * 2); lazy.resize(nn * 2);
	}

	void eval(ll k, ll l, ll r) {// k 番目のノードについて遅延評価を行う
		// 自ノード及び子ノードへの値の伝播
		if (lazy[k] != 0) {
			node[k] += lazy[k];
			// 子ノードは親ノードの 1/2 の範囲であるため、伝播のときは半分にする
			if (r - l > 1) {// 最下段かどうか
				lazy[2 * k + 1] += lazy[k] / 2;
				lazy[2 * k + 2] += lazy[k] / 2;
			}
			lazy[k] = 0;
		}
	}

	void add(ll a, ll b, ll x, ll k = 0, ll l = 0, ll r = -1) { // [a, b), x
		if (r < 0) { r = nn; }
		eval(k, l, r);// k 番目のノードに対して遅延評価を行う
		if (b <= l || r <= a) return; // 範囲外なら何もしない
		if (a <= l && r <= b) {// 完全に被覆→遅延配列に値を入れた後に評価
			lazy[k] += (r - l) * x;
			eval(k, l, r);
		}
		else { // そうでないならば、子ノードの値を再帰的に計算して、計算済みの値をもらってくる
			add(a, b, x, 2 * k + 1, l, (l + r) / 2);
			add(a, b, x, 2 * k + 2, (l + r) / 2, r);
			node[k] = node[2 * k + 1] + node[2 * k + 2];
		} //これで自分の上の頂点の値配列が更新される。
	}

	ll getsum(ll a, ll b, ll k = 0, ll l = 0, ll r = -1) { // [a, b)
		if (r < 0) { r = nn; }
		if (b <= l || r <= a) return 0;
		eval(k, l, r);// 自分の遅延配列を自分の値配列や子の遅延配列に伝番
		if (a <= l && r <= b) return node[k];
		ll vl = getsum(a, b, 2 * k + 1, l, (l + r) / 2);
		ll vr = getsum(a, b, 2 * k + 2, (l + r) / 2, r);
		return vl + vr;
	}
};

int main() {
	ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	//cout << fixed << setprecision(15);
	//priority_queue<ll, vector<ll>, greater<ll>> que;
	//priority_queue<P, vector<P>, greater<P>> que;
	//priority_queue<status, vector<status>, greater<status>> que;

	ll n, m; cin >> n >> m;
	vector<ll> a(n), b(n), c(n);
	vector<vector<status>> section_start(m + 2);
	lazyseg la(m + 2);
	rep(i, n) {
		cin >> a[i] >> b[i] >> c[i]; c[i]++;
		section_start[b[i]].push_back({ a[i],c[i] });
		la.add(b[i], c[i], a[i]);
	}
	vector<ll> d_sum(m + 2);
	ll q; cin >> q;
	rep(i, q) {
		ll d, e; cin >> d >> e;
		d_sum[e] += d;
	}
	ll ans = 0;
	priority_queue<status, vector<status>, less<status>> que;
	rep2(i, m) {
		rep(j, section_start[i].size()) {
			que.push(section_start[i][j]);
		}
		while (que.size() != 0 && que.top().r <= i) {
			que.pop();
		}

		ll sa = d_sum[i] - la.getsum(i, i + 1);
		if (sa <= 0) { continue; }

		if (que.size() == 0) { cout << -1 << endl; return 0; }

		status s = que.top();
		la.add(i, s.r, sa); ans += sa;
	}
	cout << ans << endl;
	return 0;
}

