/*
接尾辞配列（Suffix Array）
Doubling を用いて Suffix Array をソート
*/
#include <iostream>
#include <set>
#include <string>
#include <vector>
#define ll long long
using namespace std;

class SuffixArray {
private:
  string S;
  int N;
  vector<int> SA; // suffix array の index

  struct CompareSA {
    int n, k;
    const vector<int> &rank;
    CompareSA(int n, int k, const vector<int> &rank) : n(n), k(k), rank(rank) {}
    auto operator()(int i, int j) -> bool
    {
      if (rank[i] != rank[j]) {
        return rank[i] < rank[j];
      }
      else {
        int rank_ik = (i + k <= n ? rank[i + k] : -1);
        int rank_jk = (j + k <= n ? rank[j + k] : -1);
        return rank_ik < rank_jk;
      }
    }
  };

  void createSuffixArray()
  {
    vector<int> rank(N + 1), tmp(N + 1);
    for (int i = 0; i <= N; ++i) {
      SA[i] = i;
      rank[i] = i < N ? (int)S[i] : -1;
    }

    for (int k = 1; k <= N; k *= 2) {
      CompareSA csa(N, k, rank);
      sort(SA.begin(), SA.end(), csa);

      tmp[SA[0]] = 0;
      for (int i = 1; i <= N; ++i) {
        tmp[SA[i]] = tmp[SA[i - 1]];
        if (csa(SA[i - 1], SA[i])) {
          tmp[SA[i]]++;
        }
      }
      for (int i = 0; i <= N; ++i) {
        rank[i] = tmp[i];
      }
    }
  }

public:
  SuffixArray(string s)
  {
    S = s;
    N = s.length();
    SA = vector<int>(N + 1, 0); // 空も使う
    createSuffixArray();
  }

  // 部分文字列にTが含まれるかどうかを判定（二分探索）
  auto contains(string t) -> bool
  {
    int l = 0;
    int r = N;
    while (r - l > 1) {
      int mid = l + (r - l) / 2;
      int index = SA[mid];
      int cmp = S.compare(index, t.size(), t); // S.compare は S 自身が対象に対してどうか.
      if (cmp < 0) {
        l = mid;
      }
      else {
        r = mid;
      }
    }
    return S.compare(SA[r], t.size(), t) == 0;
  }
};

auto main() -> int
{
  string s;
  cin >> s;
  SuffixArray sa{s};
  int N;
  cin >> N;
  while (N--) {
    string t;
    cin >> t;
    cout << sa.contains(t) << endl;
  }
}
