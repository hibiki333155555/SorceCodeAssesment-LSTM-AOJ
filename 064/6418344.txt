#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <utility>
#include <vector>

/* macro */

#define rep(i, a, n) for (int i = (int)(a); i < (int)(n); i++)
#define rrep(i, a, n) for (int i = ((int)(n - 1)); i >= (int)(a); i--)
#define Rep(i, a, n) for (i64 i = (i64)(a); i < (i64)(n); i++)
#define RRep(i, a, n) for (i64 i = ((i64)(n - i64(1))); i >= (i64)(a); i--)
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define Bit(n) (1LL << (n))

/* macro end */

/* template */

namespace ebi {

#ifdef LOCAL
#define debug(...)                                                      \
    std::cerr << "LINE: " << __LINE__ << "  [" << #__VA_ARGS__ << "]:", \
        debug_out(__VA_ARGS__)
#else
#define debug(...)
#endif

void debug_out() { std::cerr << std::endl; }

template <typename Head, typename... Tail>
void debug_out(Head h, Tail... t) {
    std::cerr << " " << h;
    if (sizeof...(t) > 0) std::cout << " :";
    debug_out(t...);
}

template <typename T1, typename T2>
std::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &pa) {
    return os << pa.first << " " << pa.second;
}

template <typename T1, typename T2>
std::istream &operator>>(std::istream &os, std::pair<T1, T2> &pa) {
    return os >> pa.x >> pa.y;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {
    for (std::size_t i = 0; i < vec.size(); i++)
        os << vec[i] << (i + 1 == vec.size() ? "" : " ");
    return os;
}

template <typename T>
std::istream &operator>>(std::istream &os, std::vector<T> &vec) {
    for (T &e : vec) std::cin >> e;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::optional<T> &opt) {
    if (opt) {
        os << opt.value();
    } else {
        os << "invalid value";
    }
    return os;
}

using size_t = std::size_t;
using i32 = std::int32_t;
using u32 = std::uint32_t;
using i64 = std::int64_t;
using u64 = std::uint64_t;

template <class T>
void fill(std::vector<T> &v) {
    for (T &e : v) std::cin >> e;
}

template <class T>
inline bool chmin(T &a, T b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
inline bool chmax(T &a, T b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
T gcd(T a, T b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

template <class T>
T lcm(T a, T b) {
    a /= gcd(a, b);
    return a * b;
}

template <class T>
T Pow(T x, i64 n) {
    T res = 1;
    while (n > 0) {
        if (n & 1) res = res * x;
        x = x * x;
        n >>= 1;
    }
    return res;
}

template <class T>
T mod_pow(T x, i64 n, i64 mod) {
    T res = 1;
    while (n > 0) {
        if (n & 1) res = (res * x) % mod;
        x = (x * x) % mod;
        n >>= 1;
    }
    return res;
}

template <class T>
T scan() {
    T val;
    std::cin >> val;
    return val;
}

template <class T>
struct Edge {
    int to;
    T cost;
    Edge(int _to, T _cost = 1) : to(_to), cost(_cost) {}
};

template <class T>
struct Graph : std::vector<std::vector<Edge<T>>> {
    using std::vector<std::vector<Edge<T>>>::vector;
    void add_edge(int u, int v, T w, bool directed = false) {
        (*this)[u].emplace_back(v, w);
        if (directed) return;
        (*this)[v].emplace_back(u, w);
    }
};

struct graph : std::vector<std::vector<int>> {
    using std::vector<std::vector<int>>::vector;
    void add_edge(int u, int v, bool directed = false) {
        (*this)[u].emplace_back(v);
        if (directed) return;
        (*this)[v].emplace_back(u);
    }
};

constexpr i64 LNF = std::numeric_limits<i64>::max() / 4;

constexpr int INF = std::numeric_limits<int>::max() / 2;

const std::vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
const std::vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};

}  // namespace ebi

/*
    reference: https://gist.github.com/draftcode/1357281
*/

namespace ebi {

typedef std::string::const_iterator State;
class ParseError {};

bool expect(State &begin, char expected) {
    if (*begin == expected) {
        return true;
    } else {
        return false;
    }
}

// beginがexpectedを指していたらbeginを一つ進める。
void consume(State &begin, char expected) {
    if (*begin == expected) {
        begin++;
    } else {
        std::cerr << "Expected '" << expected << "' but got '" << *begin << "'"
                  << std::endl;
        std::cerr << "Rest string is '";
        while (*begin) {
            std::cerr << *begin++;
        }
        std::cerr << "'" << std::endl;
        throw ParseError();
    }
}

void consume_string(State &begin, std::string s) {
    int sz = s.size();
    rep(i, 0, sz) { consume(begin, s[i]); }
    return;
}

bool isdigit(char c) { return '0' <= c && c <= '9'; }

bool isAlpha(char c) { return 'A' <= c && c <= 'Z'; }

bool isalpha(char c) { return 'a' <= c && c <= 'z'; }

}  // namespace ebi

#include <atcoder/modint>

namespace ebi {

using mint = atcoder::modint998244353;

std::vector<mint> ver;
std::vector<bool> valid;

std::vector<std::pair<mint, i64>> print_value;

std::vector<std::pair<mint,i64>> program(std::vector<std::string> &);
void declaration(State &);
void assignment(State &, i64);
void print(State &, i64);
void for_statement(State &);
mint for_element(State &);
std::vector<mint> express(State &);
std::pair<int, mint> term1(State &);
std::pair<int, mint> term2(State &);
mint number(State &);
int value_name(State &, bool);

mint value(const std::vector<mint> &exp) {
    mint ret = exp[26];
    rep(i,0,26) {
        ret += exp[i] * ver[i];
    }
    return ret;
}

std::vector<std::pair<mint,i64>> program(std::vector<std::string> &prog) {
    ver.assign(26, 0);
    valid.assign(26, false);
    print_value.clear();
    for(auto s: prog) {
        State begin = s.begin();
        if(s[0] == 'p' && s[1] == 'r') {
            print(begin, 1);
        }
        else if(s[0] == 'f' && s[1] == 'o') {
            for_statement(begin);
        }
        else {
            if(s[1] == '<') {
                assignment(begin, 1);
            }
            else {
                declaration(begin);
            }
        }
        consume(begin, ';');
    }
    return print_value;
}

void declaration(State& begin) {
    value_name(begin, false);
}

void assignment(State &begin, i64 loop) {
    int idx = value_name(begin, true);
    consume_string(begin, "<-");
    const auto vec = express(begin);
    mint x = value(vec);
    mint a = ver[idx];
    mint k = vec[idx];
    x -= k * a;
    if(loop == 0) return;
    if(vec[idx].val() == 1) {
        x *= loop;
    } 
    else if(vec[idx].val() > 1) {
        x *= (k.pow(loop) - 1) / mint(k - 1);
        a *=  k.pow(loop);
    }
    ver[idx] = a + x;
}

void print(State &begin, i64 loop) {
    consume_string(begin, "print");
    consume(begin, '(');
    auto vec = express(begin);
    consume(begin, ')');
    mint ret = value(vec);
    if(loop == 0) return;
    print_value.emplace_back(ret, loop);
}

void for_statement(State &begin) {
    mint ret = 1;
    while (expect(begin, 'f') && *(begin + 1) == 'o') {
        ret *= for_element(begin);
    }
    if (expect(begin, 'p') && *(begin + 1) == 'r') {
        print(begin, ret.val());
    }
    else {
        assignment(begin, ret.val());
    }
}

mint for_element(State &begin) {
    consume_string(begin, "for");
    consume(begin, '(');
    auto vec = express(begin);
    consume(begin, ')');
    return value(vec);
}

std::vector<mint> express(State &begin) {
    std::vector<mint> ret(27, 0);
    {
        auto [idx, val] = term1(begin);
        ret[idx] += val;
    }
    while (expect(begin, '+') || expect(begin, '-')) {
        auto [idx, val] = term2(begin);
        ret[idx] += val;
    }
    return ret;
}

std::pair<int, mint> term1(State &begin) {
    mint sign = 1;
    if (expect(begin, '-')) {
        consume(begin, '-');
        sign = -1;
    }
    std::pair<int, mint> ret = {26, sign};
    if (isdigit(*begin)) {
        ret.second = sign * number(begin);
    } else {
        ret.first = value_name(begin, true);
    }
    return ret;
}

std::pair<int, mint> term2(State &begin) {
    mint sign = 1;
    if (expect(begin, '+')) {
        consume(begin, '+');
    } else {
        consume(begin, '-');
        sign = -1;
    }
    std::pair<int, mint> ret = {26, sign};
    if (isdigit(*begin)) {
        ret.second = sign * number(begin);
    } else {
        ret.first = value_name(begin, true);
    }
    return ret;
}

mint number(State &begin) {
    mint ret = 0;
    while (isdigit(*begin)) {
        ret *= 10;
        ret += (*begin - '0');
        consume(begin, *begin);
    }
    return ret;
}

int value_name(State &begin, bool flag) {
    assert(isalpha(*begin));
    int idx = *begin - 'a';
    consume(begin, *begin);
    assert(valid[idx] == flag);
    if (flag) {
        return idx;
    } else {
        valid[idx] = true;
        ver[idx] = 0;
        return idx;
    }
}

void main_() {
    int n, m;
    while (std::cin >> n >> m, !(n == 0 && m == 0)) {
        std::vector<std::string> s(n), t(m);
        rep(i, 0, n) {
            std::cin >> s[i];
            s[i] += ';';
        }
        rep(i, 0, m) {
            std::cin >> t[i];
            t[i] += ';';
        }
        auto sexec = program(s);
        auto texec = program(t);
        int sdx = 0, tdx = 0;
        int flag = 1;
        int ssz = sexec.size();
        int tsz = texec.size();
        while(sdx < ssz && tdx < tsz) {
            if(sexec[sdx].first.val() == texec[tdx].first.val()) {
                i64 min = std::min(sexec[sdx].second, texec[tdx].second);
                assert(min > 0);
                sexec[sdx].second -= min;
                texec[tdx].second -= min;
                if(sexec[sdx].second == 0) {
                    sdx++;
                }
                if(texec[tdx].second == 0) {
                    tdx++;
                }
            }
            else {
                flag = 0;
                break;
            }
        }
        if(sdx == ssz && tdx == tsz && flag > 0) {
            std::cout << "Yes\n";
        }
        else {
            std::cout << "No\n";
        }
    }
}

}  // namespace ebi

int main() {
    std::cout << std::fixed << std::setprecision(15);
    std::cin.tie(nullptr);
    std::ios::sync_with_stdio(false);
    int t = 1;
    // std::cin >> t;
    while (t--) {
        ebi::main_();
    }
    return 0;
}
