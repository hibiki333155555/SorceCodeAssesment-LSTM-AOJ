#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)
#define all(x) (x).begin(), (x).end()
#define sz(x) int(x.size())
using namespace std;
using ll = long long;
const int INF = 1e9;
const ll LINF = 1e18;
template <class T>
bool chmax(T& a, const T& b) {
    if (a < b) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T>
bool chmin(T& a, const T& b) {
    if (b < a) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T>
vector<T> make_vec(size_t a) {
    return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}
template <typename T>
istream& operator>>(istream& is, vector<T>& v) {
    for (int i = 0; i < int(v.size()); i++) {
        is >> v[i];
    }
    return is;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
    for (int i = 0; i < int(v.size()); i++) {
        os << v[i];
        if (i < int(v.size()) - 1) os << ' ';
    }
    return os;
}
template <typename T>
vector<pair<T, T>> ConvexHull(vector<pair<T, T>> p) {
    int n = int(p.size());
    if (n < 3) return p;

    using P = pair<T, T>;
    auto sub = [](P a, P b) -> P {
        return P(a.first - b.first, a.second - b.second);
    };
    auto cross = [](P a, P b) -> T {
        return a.first * b.second - a.second * b.first;
    };
    sort(p.begin(), p.end());
    vector<P> ret(2 * n);
    int k = 0;
    for (int i = 0; i < n; ret[k++] = p[i++]) {
        while (k >= 2 &&
               cross(sub(ret[k - 1], ret[k - 2]), sub(p[i], ret[k - 1])) < 0) {
            k--;
        }
    }
    for (int i = n - 2, t = k + 1; i >= 0; ret[k++] = p[i--]) {
        while (k >= t &&
               cross(sub(ret[k - 1], ret[k - 2]), sub(p[i], ret[k - 1])) < 0) {
            k--;
        }
    }
    ret.resize(k - 1);
    return ret;
}
using P = pair<ll, ll>;
int area(P a) {
    if (a.second < 0) return -1;
    if (a.second == 0 && a.first >= 0) return 0;
    return 1;
}
bool cmp(P a, P b) {
    if (area(a) != area(b)) return area(a) < area(b);
    return a.second * b.first < a.first * b.second;
}
ll calc(P a, P b, P c) {
    return abs((b.first - a.first) * (c.second - a.second) -
               (b.second - a.second) * (c.first - a.first));
}
int main() {
    int n;
    cin >> n;
    vector<ll> a(n);
    cin >> a;
    vector<P> ps(n);
    rep(i, n) {
        ll x, y;
        cin >> x >> y;
        ps[i] = P(x, y);
    }
    rep(i, n) {
        ll ans = 0;
        auto [x0, y0] = ps[i];
        vector<P> nps;
        rep(j, n) if (i != j) {
            auto [x, y] = ps[j];
            ll dx = x - x0, dy = y - y0;
            dx *= a[j], dy *= a[j];
            x = x0 + dx, y = y0 + dy;
            nps.emplace_back(x, y);
        }

        auto ch = ConvexHull(nps);
        // sort(all(ch), cmp);
        int m = sz(ch);
        // rep(_, 2) rep(j, m) ch.push_back(ch[j]);

        int r = 0;
        rep(_, 2) {
            rep(l, m) {
                while (calc(ps[i], ch[l], ch[(r + 1) % m]) >
                       calc(ps[i], ch[l], ch[r % m])) {
                    r++;
                }
                chmax(ans, calc(ps[i], ch[l], ch[r % m]));
                if (l == r) r++;
            }
            reverse(all(ch));
        }
        ans *= a[i];
        cout << ans << '\n';
    }
}
