#include<bits/stdc++.h>
using namespace std;

int op(int a, int b){
    return a + b;
}
const int e = 0;


template<typename T>
struct segtree{
    vector<T> s;
    int bitsize; //bitsizeがs.size()のbit長
    //葉は、s[s.size() / 2] - s[s.size() - 1]
    //s[a]の子ノードはs[2 * a + 1]、s[2 * a + 2]
    segtree<T>(const int n){
        int d = 1;
        bitsize = 0;
        while (2 * n > d) {
            d <<= 1;
            bitsize++;
        }
        s.resize(d - 1);

        for (T &x : s) x = e;
    }

    int upper(){
        //元の要素数(system)
        return s.size() / 2 + 1; 
    }

    pair<int, int> child(int a){
        //子ノードのindex取得(system)
        return {2 * a + 1, 2 * a + 2};
    }

    int parent(int a){
        //親ノードのindex取得(system)
        return (a - 1) / 2;
    }

    int leaf(int a){
        //vectorのindexを補正(system)
        return a + s.size() / 2;
    }

    bool isleaf(int a){
        //ノードが葉かどうか(system)
        return (s.size() / 2 <= a && a < s.size());
    }

    void __set(int a){
        //値の設定(system)
        if(a == 0) return;
        a = parent(a);
        auto ch = child(a);
        s[a] = op(s[ch.first], s[ch.second]);

        __set(a);
        return;
    }

    void set(int a, T b){
        //値の設定、a番目をbにする(0indexed)
        s[leaf(a)] = b;
        __set(leaf(a));
        return;
    }

    T __get(int now, int l, int r, int bit, int mid, int L, int R){
        //値の取得(system)
        //cout << "get: " << now << " | [" << l << " , " << r << ") / " << mid << endl; //デバッグ用
        if (l >= r) return e;
        if (isleaf(now)) return s[now];

        int mask = (1<<bit) - 1;
        if (((l ^ r) & 1<<bit) && !((l | r) & mask)) return s[now];
        else {
            auto ch = child(now);
            bit--;
            int mid1 = (L + mid) / 2, mid2 = (R + mid) / 2;
            return op(__get(ch.first, l, min(r, mid), bit, mid1, L, (L + R) / 2), __get(ch.second, max(l, mid), r, bit, mid2, (L + R) / 2, R));
        }
    }

    T get(int l, int r){
        //半開空間[l, r)について二項演算opをした結果を取得(0-indexed)
        assert(0 <= l && 0 < r && leaf(l) < s.size() && leaf(r) <= s.size());
        if (l >= r) return e;
        return __get(0, l, r, bitsize - 1, upper() / 2, 0, upper());
    }

    T at(int a){
        //vectorとみなした時、a番目を返す(0-indexed)
        return s[leaf(a)];
    }

    T& operator [](int a){
        return s[leaf(a)];
    }
};

int main() {
    int n, q;
    cin >> n >> q;
    segtree<int> seg(n);
    for (int i = 0; i < q; i++){
        int c, a, b;
        cin >> c >> a >> b;
        a--;
        if (c == 0) seg.set(a, seg[a] + b);
        else cout << seg.get(a, b) << endl;
    }
}

