#include <iostream>
#include <iomanip>
#include <vector>
#include <complex>

using namespace std;

complex<double> in() {double x, y; cin >> x >> y; return {x, y};}

int main()
{
	int n; cin >> n;
	vector<complex<double>> P(n);
	for (auto& p : P) p = in();
	int q; cin >> q;
	for (; q > 0; --q) {
		complex<double> p1 = in(), p2 = in();
		auto PP = P;
		for (auto& pp : PP) pp = (pp - p1) / (p2 - p1);
		double a = 0;
		int i = 0;
		for (; i < n && PP[i].imag() > 0; ++i) ;
		if (i >= n) {
			for (int i = 1; i <= n; ++i) {
				a += (PP[i % n].real() - PP[(i - 1) % n].real()) * (PP[i % n].imag() + PP[(i - 1) % n].imag());
			}
			cout << fixed << setprecision(8) << a << endl;
			continue;
		}

		for (; i < n && PP[i % n].imag() <= 0; ++i) ;
		if (i >= n) {
			cout << 0.00000000 << endl;
			continue;
		}
		auto dp = PP[i % n] - PP[(i - 1) % n];
		a = dp.real() * (PP[i % n].imag() - 0) / dp.imag() * PP[i % n].imag();
		for (++i; PP[i % n].imag() > 0; ++i) {
			a += (PP[i % n].real() - PP[(i - 1) % n].real()) * (PP[i % n].imag() + PP[(i - 1) % n].imag());
		}
		dp = PP[i % n] - PP[(i - 1) % n];
		a += dp.real() * (0 - PP[(i - 1) % n].imag()) / dp.imag() * PP[(i - 1) % n].imag();
		a *= -0.5 * abs(p2 - p1) * abs(p2 - p1);
		cout << fixed << setprecision(8) << a << endl;
	}
	return 0;
}

