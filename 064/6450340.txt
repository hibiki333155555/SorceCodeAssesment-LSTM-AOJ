#include <bits/stdc++.h>


#include <cassert>
#include <vector>

template <class S, S (*op)(S, S), S (*e)()>
struct DualSegTree {
   public:
    DualSegTree() : DualSegTree(0) {}
    DualSegTree(int n) : DualSegTree(std::vector<S>(n, e())) {}
    DualSegTree(const std::vector<S> &v) : _n(int(v.size())) {
        size = 1;
        log = 0;
        while (size < _n) size <<= 1, ++log;
        d = std::vector<S>(2 * size, e());
        for (int i = 0; i < _n; i++) d[size + i] = v[i];
    }

    S get(int p) {
        assert(0 <= p && p < _n);
        p += size;
        S sum = e();
        for (int i = 0; i <= log; i++) sum = op(sum, d[p >> i]);
        return sum;
    }

    void prod(int l, int r, S x) {
        assert(0 <= l && l <= r && r <= _n);
        l += size;
        r += size;

        while (l < r) {
            if (l & 1) d[l] = op(d[l], x), ++l;
            if (r & 1) --r, d[r] = op(d[r], x);
            l >>= 1;
            r >>= 1;
        }
    }

    void all_prod(S x) { d[1] = op(d[1], x); }

   private:
    int _n, size, log;
    std::vector<S> d;
};


#include <algorithm>
#include <cassert>
#include <vector>

template <class T>
bool chmax(T &a, const T &b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
bool chmin(T &a, const T &b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
T div_floor(T a, T b) {
    if (b < 0) a *= -1, b *= -1;
    return a >= 0 ? a / b : (a + 1) / b - 1;
}

template <class T>
T div_ceil(T a, T b) {
    if (b < 0) a *= -1, b *= -1;
    return a > 0 ? (a - 1) / b + 1 : a / b;
}

template <typename T>
struct CoordComp {
    std::vector<T> v;
    bool sorted;

    CoordComp() : sorted(false) {}

    int size() { return v.size(); }

    void add(T x) { v.push_back(x); }

    void build() {
        std::sort(v.begin(), v.end());

        v.erase(std::unique(v.begin(), v.end()), v.end());
        sorted = true;
    }

    int get_idx(T x) {
        assert(sorted);
        return lower_bound(v.begin(), v.end(), x) - v.begin();
    }

    T &operator[](int i) { return v[i]; }
};


#define For(i, a, b) for (int i = (int)(a); (i) < (int)(b); ++(i))
#define rFor(i, a, b) for (int i = (int)(a)-1; (i) >= (int)(b); --(i))
#define rep(i, n) For(i, 0, n)
#define rrep(i, n) rFor(i, n, 0)
#define fi first
#define se second

using namespace std;

using lint = long long;
using pii = pair<int, int>;
using pll = pair<lint, lint>;

lint op(lint a, lint b) { return a + b; }

lint e() { return 0; }

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    lint a[n];
    int L[n], R[n];
    rep(i, n) scanf("%lld%d%d", &a[i], &L[i], &R[i]), --L[i];

    int rightmost[m];
    rep(i, m) rightmost[i] = i;
    {
        pii p[n];
        rep(i, n) p[i].fi = L[i], p[i].se = R[i];
        sort(p, p + n);
        multiset<int> S;
        int cur = 0;
        rep(i, m) {
            while (!S.empty() && *S.begin() == i) {
                S.erase(S.begin());
            }
            while (cur < n && p[cur].fi == i) {
                S.insert(p[cur].se);
                ++cur;
            }
            if (!S.empty()) rightmost[i] = *S.rbegin();
        }
    }

    int q;
    scanf("%d", &q);
    pii p[q];
    rep(i, q) scanf("%d%d", &p[i].se, &p[i].fi), --p[i].fi;
    sort(p, p + q);

    DualSegTree<lint, op, e> st(vector<lint>(m, 0));
    rep(i, n) st.prod(L[i], R[i], a[i]);
    lint ans = 0;
    rep(i, q) {
        auto [pos, power] = p[i];
        if (st.get(pos) == 0) {
            puts("-1");
            return 0;
        }
        lint diff = power - st.get(pos);
        if (diff > 0) {
            ans += diff;
            st.prod(pos, rightmost[pos], diff);
        }
    }
    printf("%lld\n", ans);
}

