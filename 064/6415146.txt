#include <bits/stdc++.h>
using namespace std;
template<const int MOD> struct modint{
    long long val;
    modint(): val(0) {}
    modint(long long x){
        if(x < 0) val = x % MOD + MOD;
        else val = x % MOD;
    }
    modint(const modint &t){
        val = t.val;
    }
    modint& operator =(const modint m){
        val = m.val;
        return *this;
    }
    modint operator -(){
        return modint(-val);
    }
    modint& operator-=(const modint &m){
        val -= m.val;
        if(val < 0) val += MOD;
        return *this;
    }
    modint& operator+=(const modint &m){
        val += m.val;
        if(val >= MOD) val -= MOD;
        return *this;
    }
    modint& operator*=(const modint &m){
        val *= m.val;
        val %= MOD;
        return *this;
    }
    modint& operator/=(modint m){
        *this *= m.inv();
        return *this;
    }
    modint inv(){
        long long x = 1, y = 0;
        long long a = val, b = MOD;
        while(b != 0){
            long long t = a / b;
            a -= t * b;
            x -= t * y;
            swap(a, b);
            swap(x, y);
        }
        x %= MOD;
        if(x < 0) x += MOD;
        return modint(x);
    }
    modint pow(long long k){
        long long res = 1;
        long long v = val;
        if(v == 0) return modint(0);
        while(k > 0){
            if(k & 1) res = res * v % MOD;
            v = v * v % MOD;
            k >>= 1;
    }
        return modint(res);
    }
    bool operator==(const modint &m){
        return val == m.val;
    }
    modint operator+(const modint &m){
        return modint(*this) += m;
    }
    modint operator-(const modint &m){
        return modint(*this) -= m;
    }
    modint operator*(const modint &m){
        return modint(*this) *= m;
    }
    modint operator/(const modint &m){
        return modint(*this) /= m;
    }
    bool operator!=(const modint &m){
        return modint(*this).val != m.val;
    }
    bool operator!=(const int &m){
        return modint(*this).val != m;
    }
};
const int MOD = 998244353;
using mint = modint<MOD>;
const int MAX = 410000;
mint fac[MAX], finv[MAX], inv[MAX];
//MAX < MOD
void COMinit(){
    fac[0] = fac[1] = 1;
    finv[0] = finv[1] = 1;
    inv[1] = 1;
    for(int i = 2; i < MAX; i++){
        fac[i] = fac[i - 1] * i;
        inv[i] = mint(MOD) - inv[MOD % i] * (MOD / i);
        finv[i] = finv[i - 1] * inv[i];
    }
}
mint COM(int n, int k){
    if (n < k) return 0;
    if (n < 0 || k < 0) return 0;
    return fac[n] * finv[k] * finv[n - k];
}
int main(){
    int N;
    cin >> N;
    vector<int> A(N);
    for(int i = 0; i < N; i++) cin >> A[i];
    vector<vector<int>> p(10);
    for(int i = 0; i < N; i++){
        if(A[i] == 1) p[A[i]].push_back(i);
        if(A[i] % 2 == 0) p[2].push_back(i);
        if(A[i] % 3 == 0) p[3].push_back(i);
        if(A[i] % 5 == 0) p[5].push_back(i);
        if(A[i] % 7 == 0) p[7].push_back(i);
        if(A[i] == 6) p[6].push_back(i);
    }
    COMinit();
    p[6].push_back(N);
    p[2].push_back(N);
    p[3].push_back(N);
    mint ans = 1;
    int sum = 0;
    for(int i = 0; i < (int)p[6].size(); i++){
        if(i == 0){
            int ni = lower_bound(p[2].begin(), p[2].end(), p[6][i]) - p[2].begin();
            int san = lower_bound(p[3].begin(), p[3].end(), p[6][i]) - p[3].begin();
            ans *= COM(ni + san, san);
            sum += ni + san;
        }
        else{
            int ni = lower_bound(p[2].begin(), p[2].end(), p[6][i]) - upper_bound(p[2].begin(), p[2].end(), p[6][i - 1]);
            int san = lower_bound(p[3].begin(), p[3].end(), p[6][i]) - upper_bound(p[3].begin(), p[3].end(), p[6][i - 1]);
            ans *= COM(ni + san, san);
            sum += ni + san;
        }
    }
    sum += p[6].size() - 1;
    for(int i = 0; i < 10; i++){
        if(i % 2 == 0) continue;
        if(i % 3 == 0) continue;
        ans *= COM(sum + p[i].size(), sum);
        sum += p[i].size();
    }
    cout << ans.val << endl;
}
