def range_overlap_eq?(x1s, x1e, x2s, x2e)
  x1s <= x2e && x2s <= x1e
end

def range_overlap_lt?(x1s, x1e, x2s, x2e)
  x1s < x2e && x2s < x1e
end

def coverd_range(x1s, x1e, x2s, x2e)
  [[x1s, x2s].min, [x1e, x2e].max]
end

def merge_ranges(ranges)
  v = ranges.dup
  out_r = []
  loop{
    r1 = v.shift
    break if r1.nil?
    new_v = []
    same_flg = true
    v.each{|r2|
      if range_overlap_eq?(*r1, *r2)
        new_v << coverd_range(*r1, *r2)
        same_flg = false
      else
        new_v << r2
      end
    }
    if same_flg  # new_v == v
      out_r << r1
    else
      v = new_v
    end
  }
  return out_r
end  

# r1 - ranges2
def subtract_range(r1, ranges2)
  ranges2.each{|r2|
    if range_overlap_lt?(*r1, *r2)
      ans_range = []
      if r1[0] < r2[0]
        ans_range << [r1[0], r2[0]]
      end
      if r1[1] > r2[1]
        ans_range << [r2[1], r1[1]]
      end
      return ans_range, true
    end
  }

  return [r1], false
end
  

# ranges1 - ranges2
def subtract_ranges(ranges1, ranges2)
  out_ranges = []
  v1 = ranges1.dup
  # p "*** #{ranges1} #{ranges2}"
  loop{
    # p v1
    break if v1.empty?
    new_v1 = []
    v1.each{|r1|
      sub_range, is_overlap = subtract_range(r1, ranges2)
      if is_overlap
        new_v1 += sub_range
      else
        out_ranges << r1
      end
    }
    v1 = new_v1
  }
  return out_ranges
end

loop{
  line = gets
  n, r = line.chomp.split.map(&:to_i)
  break if n == 0 && r == 0
  hash = Hash.new{[]}
  n.times{
    line = gets
    x1, y1, x2, y2 = line.chomp.split.map(&:to_i)
    (y1...y2).each{|y|
      hash[y] = hash[y] << [x1, x2]
    }
  }
  hash.each{|k, v| v.replace(merge_ranges(v))}
  puts hash.map{|k, v| v.map{|xs, xe| xe-xs}.sum }.sum
  if r == 2
    contour = 0
    hash.each{|k, v|
      contour += subtract_ranges(v, hash[k-1]).map{|xs, xe| xe-xs}.sum
      contour += subtract_ranges(v, hash[k+1]).map{|xs, xe| xe-xs}.sum
      contour += v.size * 2
    }
    puts contour
  end
}

