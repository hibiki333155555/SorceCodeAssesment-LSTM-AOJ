# T90 021

from collections import deque
import bisect

class DirectedGraph():

    def __init__(self, n, m):
        """
        n: 頂点数
        m: 辺の数
        """

        self.n = n
        self.m = m
        self.G = [[] for _ in range(N)]
        self.G_rvrs = [[] for _ in range(N)]

        self.INF = 10**15

        return

    def input(self, to_zero_index=True):
        """
        a -> b
        """

        for _ in range(self.m):
            a, b = map(int, input().split())
            if to_zero_index:
                a -= 1
                b -= 1
            if b not in self.G[a]:
                self.G[a].append(b)
                self.G_rvrs[b].append(a)

    def scc(self):
        """
        強連結成分分解 (SCC)
        """
        
        def dfs(x, G, i_init=0):
            
            i = i_init
            seen[x][0] = i
            dq = deque([x])
            while dq:
                x = dq.popleft()
                seen[x][1] = i
                j = 1
                for y in G[x]:
                    if seen[y][0] == 0:
                        seen[y][0] = i + j
                        dq.appendleft(x)
                        dq.appendleft(y)
                        j += 1
                i += j
            return i

        i = 1
        # seen[i] = [はじめに訪れたとき, 最後に訪れたとき]
        seen = [[0]*2 for _ in range(self.n)]
        for x in range(self.n):
            if seen[x][0] > 0:
                continue
            i = dfs(x, G=self.G, i_init=i)

        # 帰りがけの遅い順にソートする
        # seen[x][1]: x に訪れた最後のターン
        seen1 = [seeni[1] for seeni in seen]
        idxs = self._agsort(seen1, reverse=True)

        # 帰りが遅い順に，辺を逆向きに張った有向グラフでDFS
        seen = [[0]*2 for _ in range(self.n)]
        i_separetes = []
        i = 1
        for x in idxs:
            if seen[x][0] > 0:
                continue
            i_separetes.append(i)
            i = dfs(x, G=self.G_rvrs, i_init=i)
        # DFSが途切れた時が強連結成分
        n_group = len(i_separetes)
        self.group = [[] for _ in range(n_group)]
        self.group_idx = [None] * self.n
        for x, (si, _) in enumerate(seen):
            i = bisect.bisect_right(i_separetes, si) - 1
            self.group[i].append(x)
            self.group_idx[x] = i
        return self.group

    def _agsort(self, a, reverse=False):
        tmp = [[ai, i] for i, ai in enumerate(a)]
        tmp.sort(reverse=reverse)
        return [tmpi[1] for tmpi in tmp]

N, M = map(int, input().split())
dg = DirectedGraph(N, M)
dg.input(to_zero_index=False)
dg.scc()

Q = int(input())
for _ in range(Q):
    a, b = map(int, input().split())
    if dg.group_idx[a] == dg.group_idx[b]:
        print(1)
    else:
        print(0)
