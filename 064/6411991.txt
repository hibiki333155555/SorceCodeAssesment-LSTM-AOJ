#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Union-Find
struct UnionFind
{
  vector<int> par;

  UnionFind() {}
  UnionFind(int n) : par(n, -1) {}
  void init(int n) { par.assign(n, -1); }

  int root(int x)
  {
    if (par[x] < 0)
      return x;
    else
      return par[x] = root(par[x]);
  }

  bool issame(int x, int y)
  {
    return root(x) == root(y);
  }

  bool merge(int x, int y)
  {
    x = root(x);
    y = root(y);
    if (x == y)
      return false;
    if (par[x] > par[y])
      swap(x, y);     //
    par[x] += par[y]; // technique:xのrootにyのrootを足す
    par[y] = x;       // yの親をxにする,xの子をyとする
    return true;
  }

  int size(int x)
  {
    return -par[root(x)];
  }
};

int main()
{
    // 辺を表す構造体
    using pint = pair<int, int>;        //両端点
    using Edge = pair<long long, pint>; //重み,両端点
  // 辺数
  int N, M;
  cin >> N >> M;
  // 入力
  vector<Edge> edges(M);
  vector<Edge> min_edges;
  for (int i = 0; i < M; ++i)
  {
    cin >> edges[i].second.first >> edges[i].second.second >> edges[i].first;
    --edges[i].second.first;
    --edges[i].second.second;
  }

  // 辺を重み順にソート
  sort(edges.begin(), edges.end());

  // Kruskal法
  UnionFind uf(N);
  int res = 0; //重み
  for (auto e : edges)
  {
    long long w = e.first;
    int u = e.second.first, v = e.second.second;
    // 辺(u,v)は追加できない場合
    if (uf.issame(u, v))
      continue;
    // 辺(u,v)を追加するとき
    uf.merge(u, v);
    res += w;
    // 最小全域木の辺
    pint p = {u, v};
    Edge me = {w, p};
    min_edges.push_back(me);
  }

  int ans_edge = 0;
  int ans_weight = 0;
  for (auto m : min_edges)
  {
    UnionFind uf(N);
    int res_m = 0;
    for (auto e : edges)
    {
      // skipする辺は飛ばす
      if (e == m)
        continue;
      long long w = e.first;
      int u = e.second.first, v = e.second.second;
      // 辺(u,v)は追加できない場合
      if (uf.issame(u, v))
        continue;
      // 辺(u,v)を追加するとき
      uf.merge(u, v);
      res_m += w;
    }

    if (res != res_m)
    {
      ans_edge++;
      ans_weight += m.first;
    }
  }
  cout << ans_edge << " " << ans_weight << endl;
}

