

#include <bits/stdc++.h>
#include <iostream>
#include <limits>
#include <numeric>
#include <type_traits>
#include <bitset>
#include <map>
#include <unordered_map>
#include <set>

using namespace std;

#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)
#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)
using ll = long long;
const ll mod = 998244353;
const ll inf = 1e9;
const ll INF = 1e18;


void pline(vector<ll> lis){
    rep(i,0,lis.size()){
        printf ("%lld",lis[i]);
        if (i != lis.size()-1) printf(" ");
        else printf("\n");
    }
}

int main(){

    ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    //ModFac mf(200000);

    ll N;
    cin >> N;

    string s;
    cin >> s;

    vector<ll> S(N);
    rep(i,0,N){
        if (s[i] == '(') S[i] = 1;
        else S[i] = -1;
    }

    vector<ll> A(N);
    rep(i,0,N) cin >> A[i];

    //前から見て行って、累積和が負になったら )を1個反転する
    ll ans = 0;

    {
        ll sum = 0;
        priority_queue<pair<ll,ll>> q;

        rep(i,0,N){
            if (S[i] == -1){
                q.push(make_pair(-A[i],i));
            }
            sum += S[i];

            if (sum < 0){
                ll ind = q.top().second;
                ans -= q.top().first;
                S[ind] *= -1;
                sum += 2; 
                q.pop();
            }
        }
    }


    {
        ll sum = 0;
        priority_queue<pair<ll,ll>> q;

        rrep(i,N-1,-1){
            if (S[i] == 1){
                q.push(make_pair(-A[i],i));
            }
            sum += S[i];

            if (sum > 0){
                ll ind = q.top().second;
                ans -= q.top().first;
                S[ind] *= -1;
                sum -= 2; 
                q.pop();
            }
        }
    }

    cout << ans << endl;



}

/*

https://drive.google.com/drive/u/2/folders/1gZBJHglPKtJR9h8ZRL2vd6MSQTxiqamZ

*/
