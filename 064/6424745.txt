#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <numeric>
#include <algorithm>
#include <queue>
#include <string>
#include <random>
#include <array>
#include <climits>
#include <map>
#include <cassert>
#include <stack>
#include <iomanip>
#include <cfloat>
#include <bitset>
#include <fstream>
#include <chrono>
struct Point {
	int x, y, color;
};

class MaxBit {
	std::vector<int> vec;
public:
	MaxBit(const int size) :vec(size, INT_MIN) {};
	int get(int position) const {
		int result = INT_MIN;
		while (0 <= position) {
			result = std::max(result, vec[position]);
			position -= ~position & (position + 1);
		}
		return result;
	}
	void add(int position, const int value) {
		while (position < vec.size()) {
			vec[position] = std::max(vec[position], value);
			position += ~position & (position + 1);
		}
	}
};

int main() {
	int n; std::cin >> n;
	std::vector<Point> points(n);
	for (auto& [x, y, color] : points) {
		std::cin >> x >> y >> color;
	}
	std::vector<int> all_x, all_y;
	std::transform(points.begin(), points.end(), std::back_inserter(all_x), [](const auto a) {return a.x; });
	std::transform(points.begin(), points.end(), std::back_inserter(all_y), [](const auto a) {return a.y; });
	std::sort(all_x.begin(), all_x.end()); all_x.erase(std::unique(all_x.begin(), all_x.end()), all_x.end());
	std::sort(all_y.begin(), all_y.end()); all_y.erase(std::unique(all_y.begin(), all_y.end()), all_y.end());
	for (auto& [x, y, _] : points) {
		x = std::distance(all_x.begin(), std::lower_bound(all_x.begin(), all_x.end(), x));
		y = std::distance(all_y.begin(), std::lower_bound(all_y.begin(), all_y.end(), y));
	}
	int result = INT_MAX;
	for (auto _i = 0; _i < 4; ++_i) {
		for (auto& [x, y, _]: points) {
			const auto next_x = y;
			const auto next_y = all_x.size() - 1 - x;
			x = next_x;
			y = next_y;
		}
		std::swap(all_x, all_y);
		std::reverse(all_y.begin(), all_y.end());
		for (auto& y : all_y) {
			y *= -1;
		}
		std::vector<std::vector<Point>> by_x(n);
		for (const auto& point : points) {
			by_x[point.x].push_back(point);
		}
		std::vector<std::map<int, int>> most_right_y(3);
		std::vector<std::vector<std::vector<std::pair<int, int>>>> left_tops(n, std::vector<std::vector<std::pair<int, int>>>(3));
		std::vector<MaxBit> max_single(3, MaxBit(n)), max_double(3, MaxBit(n));
		for (auto& line : by_x) {
			std::sort(line.begin(), line.end(), [](const auto a, const auto b) {return a.y < b.y; });
			for (const auto point : line) {
				auto& set = most_right_y[point.color];
				for (auto iter = set.upper_bound(point.y); iter != set.end(); iter = set.erase(iter));
				set.insert_or_assign(point.y, point.x);
				max_single[point.color].add(point.y, all_x[point.x] + all_y[point.y]);
				for (auto left_color = 0; left_color < 3; ++left_color) {
					if (point.color == left_color) continue;
					const auto left_iter = most_right_y[left_color].upper_bound(point.y);
					if (left_iter != most_right_y[left_color].begin()) {
						const auto [y, x] = *std::prev(left_iter);
						left_tops[point.x][3 - point.color - left_color].emplace_back(y, all_y[point.y] - all_x[x]);
					}
					const auto left_bottom = max_single[left_color].get(point.y);
					if (left_bottom != INT_MIN) {
						max_double[3 - point.color - left_color].add(point.y, left_bottom);
					}
				}
				const auto left_bottom = max_double[point.color].get(point.y);
				if (left_bottom != INT_MIN) {
					const auto perimeter = (all_x[point.x] + all_y[point.y] - left_bottom) * 2;
					result = std::min(result, perimeter);
				}
			}
		}
		std::vector<MaxBit> right_bottom(3, MaxBit(n));
		std::reverse(by_x.begin(), by_x.end());
		for (const auto& line : by_x) {
			if (line.empty()) continue;
			for (const auto point : line) {
				right_bottom[point.color].add(point.y, all_y[point.y] - all_x[point.x]);
			}
			const auto& left_top = left_tops[line.front().x];
			for (auto color = 0; color < 3; ++color) {
				for (const auto [y, yx] : left_top[color]) {
					const auto rb = right_bottom[color].get(y);
					if (rb != INT_MIN) {
						const auto perimeter = (yx - rb) * 2;
						result = std::min(result, perimeter);
					}
				}
			}
		}
	}
	std::cout << result << '\n';
}
