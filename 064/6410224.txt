# include <bits/stdc++.h>
# define rep(i, a, b) for (int i = a; i < int(b); ++i)
using namespace std;

int main() {
   // 1. 入力
   int h, w, n;
   cin >> h >> w >> n;
   pair<int, int> start, goal;
   cin >> start.first >> start.second >> goal.first >> goal.second;
   start.first--, start.second--, goal.first--, goal.second--; 
   vector<array<int, 3>> watchers(n);
   for (auto& [y, x, k] : watchers) {
      cin >> y >> x >> k;
      y--, x--;
   }

   // 2. いもす法
   map<int, map<int, int>> imos;
   for (auto [y, x, k] : watchers) {
      imos[y - k][x] += 1;
      imos[y - k + 1][x] += 1;
      imos[y + 1][x - k] -= 1;
      imos[y + 1][x - k - 1] -= 1;
      imos[y + k + 1][x] += 1;
      imos[y + k + 2][x] += 1;
      imos[y + 1][x + k] -= 1;
      imos[y + 1][x + k + 1] -= 1;
   }
   rep (x, -2*w, 2*w + 1) rep (y, -2*h, 2*h) imos[y + 1][x - y - 1] += imos[y][x - y];
   rep (x, -2*w, 2*w + 1) rep (y, -2*h, 2*h) imos[y + 1][x + y + 1] += imos[y][x + y];

   // 3. 幅優先探索で到達できるかを判定
   vector<vector<int>> dist(h, vector<int>(w, -1));
   dist[start.first][start.second] = 0;
   for (queue<pair<int, int>> que({start}); not que.empty();) {
      pair<int, int> now = que.front();
      que.pop();
      constexpr array<int, 5> delta = { 0, 1, 0, -1, 0 };
      rep (i, 0, 4) {
         pair<int, int> nxt = { now.first + delta[i], now.second + delta[i + 1] };
         if (nxt.first < 0 or nxt.first >= h or nxt.second < 0 or nxt.second >= w) {
            continue;
         }
         if (dist[nxt.first][nxt.second] != -1) continue;
         if (imos[nxt.first][nxt.second]) continue;
         
         dist[nxt.first][nxt.second] = dist[now.first][now.second] + 1;
         que.push(nxt);
      }
   }

   // 4. 答えの出力
   puts(dist[goal.first][goal.second] != -1 ? "Yes" : "No");
}
