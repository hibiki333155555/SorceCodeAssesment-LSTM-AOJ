#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
template<class T> using V = vector<T>;
using VI = V<int>;
using VL = V<ll>;
using VS = V<string>;
template<class T> using PQ = priority_queue<T, V<T>, greater<T>>;
using graph = V<VI>;
template<class T> using w_graph = V<V<pair<int, T>>>;
#define FOR(i,a,n) for(int i=(a);i<(n);++i)
#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)
#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)
#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define inside(h,w,y,x) (unsigned(y)<h&&unsigned(x)<w)
#ifdef _DEBUG
#define line cout << "-----------------------------\n"
#define stop system("pause")
#endif
constexpr ll INF = 1000000000;
constexpr ll LLINF = 1LL << 61;
constexpr ll mod = 1000000007;
constexpr ll MOD = 998244353;
constexpr ld eps = 1e-10;
constexpr int dy[]{ -1,0,1,0 }, dx[]{ 0,1,0,-1 };
template<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }
template<class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }
inline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }
template<class T> inline istream& operator>>(istream& is, V<T>& v) { for (auto& a : v)is >> a; return is; }
template<class T, class U> inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template<class T> inline V<T> vec(size_t a) { return V<T>(a); }
template<class T> inline V<T> defvec(T def, size_t a) { return V<T>(a, def); }
template<class T, class... Ts> inline auto vec(size_t a, Ts... ts) { return V<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }
template<class T, class... Ts> inline auto defvec(T def, size_t a, Ts... ts) { return V<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }
template<class T> inline void print(const T& a) { cout << a << "\n"; }
template<class T, class... Ts> inline void print(const T& a, const Ts&... ts) { cout << a << " "; print(ts...); }
template<class T> inline void print(const V<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? "\n" : " "); }
template<class T> inline void print(const V<V<T>>& v) { for (auto& a : v)print(a); }
template<class T> inline constexpr const T cumsum(const V<T>& a, int l, int r) { return 0 <= l && l <= r && r < a.size() ? a[r] - (l == 0 ? 0 : a[l - 1]) : 0; }//[l,r]
template<class T> inline constexpr const T min(const V<T>& v) { return *min_element(all(v)); }
template<class T> inline constexpr const T max(const V<T>& v) { return *max_element(all(v)); }

int main() {
    init();

    string s, t; int a, b; cin >> s >> a >> t >> b;
    int x = s[0] - 'A';
    if (s.size() == 2)x = x * 26 + s[1] - 'A' + 26;
    int y = t[0] - 'A';
    if (t.size() == 2)y = y * 26 + t[1] - 'A' + 26;
    print((b - a + 1) * (y - x + 1));

    return 0;
}
