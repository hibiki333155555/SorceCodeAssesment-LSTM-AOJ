#line 1 "g.cpp"
#pragma region Macros
#include <bits/stdc++.h>
using namespace std;
template <class T> inline bool chmax(T &a, T b) {
    if(a < b) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T> inline bool chmin(T &a, T b) {
    if(a > b) {
        a = b;
        return 1;
    }
    return 0;
}
#ifdef DEBUG
template <class T, class U>
ostream &operator<<(ostream &os, const pair<T, U> &p) {
    os << '(' << p.first << ',' << p.second << ')';
    return os;
}
template <class T> ostream &operator<<(ostream &os, const vector<T> &v) {
    os << '{';
    for(int i = 0; i < (int)v.size(); i++) {
        if(i) { os << ','; }
        os << v[i];
    }
    os << '}';
    return os;
}
void debugg() { cerr << endl; }
template <class T, class... Args>
void debugg(const T &x, const Args &... args) {
    cerr << " " << x;
    debugg(args...);
}
#define debug(...)                                                             \
    cerr << __LINE__ << " [" << #__VA_ARGS__ << "]: ", debugg(__VA_ARGS__)
#define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
#else
#define debug(...) (void(0))
#define dump(x) (void(0))
#endif

struct Setup {
    Setup() {
        cin.tie(0);
        ios::sync_with_stdio(false);
        cout << fixed << setprecision(15);
    }
} __Setup;

using ll = long long;
#define OVERLOAD3(_1, _2, _3, name, ...) name
#define ALL(v) (v).begin(), (v).end()
#define RALL(v) (v).rbegin(), (v).rend()
#define REP1(i, n) for(int i = 0; i < int(n); i++)
#define REP2(i, a, b) for(int i = (a); i < int(b); i++)
#define REP(...) OVERLOAD3(__VA_ARGS__, REP2, REP1)(__VA_ARGS__)
#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())
#define SZ(v) ((int)(v).size())
const int INF = 1 << 30;
const ll LLINF = 1LL << 60;
constexpr int MOD = 1000000007;
constexpr int MOD2 = 998244353;
const int dx[4] = {1, 0, -1, 0};
const int dy[4] = {0, 1, 0, -1};

void Case(int i) { cout << "Case #" << i << ": "; }
int popcount(int x) { return __builtin_popcount(x); }
ll popcount(ll x) { return __builtin_popcountll(x); }
#pragma endregion Macros

#line 1 "/Users/siro53/kyo-pro/compro_library/math/modint.hpp"
template <int mod> struct ModInt {
    int x;
    ModInt() : x(0) {}
    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}
    ModInt &operator+=(const ModInt &p) {
        if((x += p.x) >= mod)
            x -= mod;
        return *this;
    }
    ModInt &operator-=(const ModInt &p) {
        if((x += mod - p.x) >= mod)
            x -= mod;
        return *this;
    }
    ModInt &operator*=(const ModInt &p) {
        x = (int)(1LL * x * p.x % mod);
        return *this;
    }
    ModInt &operator/=(const ModInt &p) {
        *this *= p.inv();
        return *this;
    }
    ModInt operator-() const { return ModInt(-x); }
    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }
    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }
    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }
    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }
    bool operator==(const ModInt &p) const { return x == p.x; }
    bool operator!=(const ModInt &p) const { return x != p.x; }
    ModInt inv() const {
        int a = x, b = mod, u = 1, v = 0, t;
        while(b > 0) {
            t = a / b;
            swap(a -= t * b, b);
            swap(u -= t * v, v);
        }
        return ModInt(u);
    }
    ModInt pow(int64_t n) const {
        ModInt ret(1), mul(x);
        while(n > 0) {
            if(n & 1)
                ret *= mul;
            mul *= mul;
            n >>= 1;
        }
        return ret;
    }
    friend ostream &operator<<(ostream &os, const ModInt &p) {
        return os << p.x;
    }
    friend istream &operator>>(istream &is, ModInt &a) {
        int64_t t;
        is >> t;
        a = ModInt<mod>(t);
        return (is);
    }
    static int get_mod() { return mod; }
};
#line 77 "g.cpp"
using mint = ModInt<MOD2>;
#line 1 "/Users/siro53/kyo-pro/compro_library/math/matrix.hpp"
// 行列ライブラリ
template <class T> struct Matrix {
    vector<vector<T>> A;

    Matrix() {}

    Matrix(size_t n, size_t m) : A(n, vector<T>(m, 0)) {}

    Matrix(size_t n) : A(n, vector<T>(n, 0)){};

    size_t height() const { return (A.size()); }

    size_t width() const { return (A[0].size()); }

    inline const vector<T> &operator[](int k) const { return (A.at(k)); }

    inline vector<T> &operator[](int k) { return (A.at(k)); }

    // 単位行列
    static Matrix I(size_t n) {
        Matrix mat(n);
        for(int i = 0; i < n; i++)
            mat[i][i] = 1;
        return (mat);
    }

    Matrix &operator+=(const Matrix &B) {
        size_t n = height(), m = width();
        assert(n == B.height() && m == B.width());
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                (*this)[i][j] += B[i][j];
        return (*this);
    }

    Matrix &operator-=(const Matrix &B) {
        size_t n = height(), m = width();
        assert(n == B.height() && m == B.width());
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                (*this)[i][j] -= B[i][j];
        return (*this);
    }

    Matrix &operator*=(const Matrix &B) {
        size_t n = height(), m = B.width(), p = width();
        assert(p == B.height());
        vector<vector<T>> C(n, vector<T>(m, 0));
		T sum;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
				sum = 0;
                for(int k = 0; k < p; k++){
                    sum += (*this)[i][k] * B[k][j];
				}
				C[i][j] = sum;
			}
		}
        A.swap(C);
        return (*this);
    }

    // 累乗
    Matrix &operator^=(long long k) {
        Matrix B = Matrix::I(height());
        while(k > 0) {
            if(k & 1)
                B *= *this;
            *this *= *this;
            k >>= 1LL;
        }
        A.swap(B.A);
        return (*this);
    }

    Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }

    Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }

    Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }

    Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }

    friend ostream &operator<<(ostream &os, Matrix &p) {
        size_t n = p.height(), m = p.width();
        for(int i = 0; i < n; i++) {
            os << "[";
            for(int j = 0; j < m; j++) {
                os << p[i][j] << (j + 1 == m ? "]\n" : ",");
            }
        }
        return (os);
    }

    // 行列式
    T determinant() {
        Matrix B(*this);
        assert(width() == height());
        T ret = 1;
        for(int i = 0; i < width(); i++) {
            int idx = -1;
            for(int j = i; j < width(); j++) {
                if(B[j][i] != 0)
                    idx = j;
            }
            if(idx == -1)
                return (0);
            if(i != idx) {
                ret *= -1;
                swap(B[i], B[idx]);
            }
            ret *= B[i][i];
            T vv = B[i][i];
            for(int j = 0; j < width(); j++) {
                B[i][j] /= vv;
            }
            for(int j = i + 1; j < width(); j++) {
                T a = B[j][i];
                for(int k = 0; k < width(); k++) {
                    B[j][k] -= B[i][k] * a;
                }
            }
        }
        return (ret);
    }
};
#line 79 "g.cpp"
using matrix = Matrix<mint>;
using Array = array<mint, 26>;
using Data = pair<ll, mint>;

int N, M;
int n;
vector<string> s;
vector<Data> v;
ll nowl;
Array vals;

void program(int& i, int& j);
void declaration(int& i, int& j);
void assignment(int& i, int& j);
mint print(int& i, int& j);
void For(int& i, int& j);
// void for_element(int& i, int& j);
pair<array<int, 26>, mint> expression(int& i, int& j);
void term1(int& i, int& j);
void term2(int& i, int& j);
mint number(int& i, int& j);
int value_name(int& i, int& j);

int main() {
    while(1) {
        cin >> N >> M;
        if(N == M and M == 0) break;
        vector<string> S(N), T(M);
        REP(i, N) cin >> S[i];
        REP(i, M) cin >> T[i];
        // S
        n = N;
        s = S;
        v.clear();
        REP(i, 26) vals[i] = 0;
        int ii = 0, jj = 0;
        program(ii, jj);
        auto vs = v;
        // T
        n = M;
        s = T;
        v.clear();
        REP(i, 26) vals[i] = 0;
        ii = 0, jj = 0;
        program(ii, jj);
        auto vt = v;
        // 一致判定
        auto compress = [&](vector<Data>& a) {
            if(a.empty()) return;
            vector<Data> res;
            res.push_back(a[0]);
            REP(i, 1, SZ(a)) {
                if(a[i].second == res.back().second) res.back().first += a[i].first;
                else res.emplace_back(a[i]);
            }
            a = res;
        };
        compress(vs);
        compress(vt);
        debug(vs);
        debug(vt);
        if(vs == vt) cout << "Yes\n";
        else cout << "No\n";
    }
}

mint number(int& i, int& j) {
    mint res = 0;
    while(j < SZ(s[i]) and isdigit(s[i][j])) {
        res = res * 10 + (s[i][j] - '0');
        j++;
    }
    return res;
}

void program(int& i, int& j) {
    while(i < n) {
        if(s[i][j] == 'p') {
            if(j + 1 < SZ(s[i])) {
                if(s[i][j+1] == 'r') {
                    v.emplace_back(1, print(i, j));
                }
                else {
                    assert(s[i][j+1] == '<');
                    assignment(i, j);
                }
            } else {
                declaration(i, j);
            }
        } else if(s[i][j] == 'f') {
            if(j + 1 < SZ(s[i])) {
                if(s[i][j+1] == 'o') For(i, j);
                else {
                    assert(s[i][j+1] == '<');
                    assignment(i, j);
                }
            } else {
                declaration(i, j);
            }
        } else {
            if(j + 1 < SZ(s[i]) and s[i][j+1] == '<') {
                assignment(i, j);
            } else {
                debug(i, j);
                declaration(i, j);
            }
        }
    }
}

void declaration(int& i, int& j) {
    i++; j = 0;
}

int value_name(int& i, int& j) {
    int res = s[i][j++] - 'a';
    return res;
}

void assignment(int& i, int& j) {
    int l = value_name(i, j);
    j += 2;
    auto [cntr, cons] = expression(i, j); // 文字が何回たされたかの配列
    
    mint x = 0, y = cons;
    REP(i, 26) {
        if(i == l) x += cntr[i];
        else y += vals[i] * cntr[i];
    }

    vals[l] = vals[l] * x + y;
    i++; j = 0;
}

mint print(int& i, int& j) {
    j += 6;
    auto [cntr, cons] = expression(i, j);
    mint res = cons;
    REP(i, 26) res += vals[i] * cntr[i];
    i++; j=0;
    return res;
}

void For(int& i, int& j) {
    int L = 1;
    debug(i, j, L);
    while(j+1 < SZ(s[i]) and s[i][j] == 'f' and s[i][j+1] == 'o') {
        debug(i, j, L);
        j += 4;
        auto [cntr, cons] = expression(i, j);
        mint tmp = cons;
        REP(i, 26) tmp += vals[i] * cntr[i];
        j += 1;
        L *= tmp.x;
    }
    debug(i, j, L);
    if(j + 1 < SZ(s[i]) and s[i][j] == 'p' and s[i][j+1] == 'r') {
        mint printValue = print(i, j);
        if(L > 0) {
            v.emplace_back(L, printValue);
            nowl += L;
        }
    } else {
        int l = value_name(i, j);
        j += 2;
        auto [cntr, cons] = expression(i, j); // 文字が何回たされたかの配列
        
        mint x = 0, y = cons;
        REP(i, 26) {
            if(i == l) x += cntr[i];
            else y += vals[i] * cntr[i];
        }

        matrix A(2, 2);
        A[0][0] = x, A[0][1] = y, A[1][0] = 0, A[1][1] = 1;
        matrix init(2, 1);
        init[0][0] = vals[l], init[1][0] = 1;
        A ^= L;
        auto res = A * init;
        debug(res[0][0], x, y);
        vals[l] = res[0][0];
        i++; j=0;
    }
}

pair<array<int, 26>, mint> expression(int& i, int& j) {
    array<int, 26> cnt;
    REP(i, 26) cnt[i] = 0;
    mint cons = 0;
    int firstSgn = 1;
    if(s[i][j] == '-') {
        firstSgn = -1;
        j++;
    }
    if(isdigit(s[i][j])) cons += number(i, j) * firstSgn;
    else cnt[value_name(i, j)] += firstSgn;
    while(j < SZ(s[i]) and s[i][j] == '-' or s[i][j] == '+') {
        int sgn = 1;
        if(s[i][j] == '-') sgn = -1;
        j++;
        if(isdigit(s[i][j])) cons += number(i, j) * sgn;
        else cnt[value_name(i, j)] += sgn;
    }
    return {cnt, cons};
}


