#!usr/bin/env python3
from collections import defaultdict, deque
from heapq import heappush, heappop
from itertools import permutations, accumulate
import sys
import math
import bisect
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def IR(n):
    return [I() for _ in range(n)]
def LIR(n):
    return [LI() for _ in range(n)]

sys.setrecursionlimit(1000000)
mod = 1000000007

def main():
    D = [(1,0),(0,1),(-1,0),(0,-1)]
    h,w = LI()
    s = [input() for _ in range(h)]
    d = [[-1]*w for _ in range(h)]
    q = deque()
    for y in range(h):
        for x in range(w):
            if s[y][x] == "S":
                d[y][x] = 0
                sy,sx = y,x
                q.append((y,x))
            elif s[y][x] == "V":
                gy,gx = y,x
    f = defaultdict(lambda : float("inf"))
    m = I()
    for _ in range(m):
        a,b,t = LI()
        f[(a-1,b-1)] = t
    while q:
        y,x = q.popleft()
        nd = d[y][x]+1
        for dy,dx in D:
            ny,nx = y+dy,x+dx
            if 0 <= ny < h and 0 <= nx < w and s[ny][nx] != "#" and d[ny][nx] < 0 and nd < f[(ny,nx)]:
                d[ny][nx] = nd
                q.append((ny,nx))
    nd = d[gy][gx]
    if nd < 0:
        print("No")
        return
    q = deque([(gy,gx)])
    d = [[-1]*w for _ in range(h)]
    d[gy][gx] = nd
    while q:
        y,x = q.popleft()
        nd = d[y][x]+1
        for dy,dx in D:
            ny,nx = y+dy,x+dx
            if 0 <= ny < h and 0 <= nx < w and s[ny][nx] != "#" and d[ny][nx] < 0 and nd < f[(ny,nx)]:
                d[ny][nx] = nd
                q.append((ny,nx))
    ans = d[sy][sx]
    if ans < 0:
        print("No")
    else:
        print("Yes")

    return


if __name__ == "__main__":
    main()

