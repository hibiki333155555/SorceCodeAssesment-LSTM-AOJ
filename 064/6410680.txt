#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

// 1-indexed
template<typename T>
struct BIT{
    int n;
    vector<T> bit;
    BIT(int n_=0):n(n_),bit(n+1){}
    T sum(int i){
        T res=0;
        for(;i>0;i-=(i&-i))res+=bit[i];
        return res;
    }
    void add(int i,T a){
        if(i==0)return;
        for(;i<=n;i+=(i&-i)){bit[i]+=a;}
    }
    int lower_bound(T k){ // k<=sum(res)
        if(k<=0)return 0;
        int res=0,i=1;
        while((i<<1)<=n)i<<=1;
        for(;i;i>>=1){
            if(res+i<=n&&bit[res+i]<k)k-=bit[res+=i];
        }
        return res+1;
    }
};

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<ll> a(n);
    ll K; cin >> K;
    vector<ll> s(n+1);
    for(int i=0;i<n;i++){
        cin >> a[i];
        a[i] -= K;
        s[i+1] = s[i] + a[i];
    }
    ll res = 0;
    vector<ll> v;
    for(int i=0;i<=n;i++){
        v.push_back(s[i]);
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()),v.end());
    int m = v.size();
    BIT<int> bit(m);
    auto idx=[&](ll x)->int{
        return lower_bound(v.begin(), v.end(), x) - v.begin();
    };
    bit.add(idx(0)+1,1);
    for(int i=1;i<=n;i++){
        res += bit.sum(idx(s[i])+1);
        bit.add(idx(s[i])+1,1);
    }
    cout << res << endl;
}

