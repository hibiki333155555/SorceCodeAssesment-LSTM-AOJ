
#if 1
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <stack>
#include <array>
#include <deque>
#include <algorithm>
#include <utility>
#include <cstdint>
#include <functional>
#include <iomanip>
#include <numeric>
#include <assert.h>
#include <bitset>
#include <list>
#include <cmath>

auto& in = std::cin;
auto& out = std::cout;
#define all_range(C) std::begin(C), std::end(C)
const double PI = 3.141592653589793238462643383279502884197169399375105820974944;

int32_t N;
std::vector<std::tuple<int, int, int>> pos;
double result[200000];

template< typename T, bool isMin >
struct ConvexHullTrickAddMonotone {
#define F first
#define S second
    using P = std::pair< T, T >;
    std::deque< P > H;

    ConvexHullTrickAddMonotone() = default;

    bool empty() const { return H.empty(); }

    void clear() { H.clear(); }

    inline int sgn(T x) { return x == 0 ? 0 : (x < 0 ? -1 : 1); }

    using D = long double;

    inline bool check(const P& a, const P& b, const P& c) {
        if (b.S == a.S || c.S == b.S)
            return sgn(b.F - a.F) * sgn(c.S - b.S) >= sgn(c.F - b.F) * sgn(b.S - a.S);

        //return (b.F-a.F)*(c.S-b.S) >= (b.S-a.S)*(c.F-b.F);
        return
            D(b.F - a.F) * sgn(c.S - b.S) / D(abs(b.S - a.S)) >=
            D(c.F - b.F) * sgn(b.S - a.S) / D(abs(c.S - b.S));
    }

    void add(T a, T b) {
        if (!isMin) a *= -1, b *= -1;
        P line(a, b);
        if (empty()) {
            H.emplace_front(line);
            return;
        }
        if (H.front().F <= a) {
            if (H.front().F == a) {
                if (H.front().S <= b) return;
                H.pop_front();
            }
            while (H.size() >= 2 && check(line, H.front(), H[1])) H.pop_front();
            H.emplace_front(line);
        }
        else {
            assert(a <= H.back().F);
            if (H.back().F == a) {
                if (H.back().S <= b) return;
                H.pop_back();
            }
            while (H.size() >= 2 && check(H[H.size() - 2], H.back(), line)) H.pop_back();
            H.emplace_back(line);
        }
    }

    inline T get_y(const P& a, const T& x) {
        return a.F * x + a.S;
    }

    T query(T x) {
        assert(!empty());
        int l = -1, r = H.size() - 1;
        while (l + 1 < r) {
            int m = (l + r) >> 1;
            if (get_y(H[m], x) >= get_y(H[m + 1], x)) l = m;
            else r = m;
        }
        if (isMin) return get_y(H[r], x);
        return -get_y(H[r], x);
    }

    T query_monotone_inc(T x) {
        assert(!empty());
        while (H.size() >= 2 && get_y(H.front(), x) >= get_y(H[1], x)) H.pop_front();
        if (isMin) return get_y(H.front(), x);
        return -get_y(H.front(), x);
    }

    T query_monotone_dec(T x) {
        assert(!empty());
        while (H.size() >= 2 && get_y(H.back(), x) >= get_y(H[H.size() - 2], x)) H.pop_back();
        if (isMin) return get_y(H.back(), x);
        return -get_y(H.back(), x);
    }

#undef F
#undef S
};


int main()
{
    using std::endl;
    in.sync_with_stdio(false);
    out.sync_with_stdio(false);
    in.tie(nullptr);
    out.tie(nullptr);

    in >> N;
    for (int i = 0; i < N; i++)
    {
        int c, r;
        in >> c >> r;
        pos.push_back({ c, c, c + r });
    }
    int q;
    in >> q;
    for (int i = 0; i < q; i++){
        int x;
        in >> x;
        pos.push_back({x , -i, 0 });
    }
    std::sort(pos.begin(), pos.end());

    using std::get;
    auto dist = [](const std::tuple<double, int, int>& pos, int npos)->double {
        using std::get;
        double r = get<2>(pos) - get<1>(pos);
        return std::sqrt(std::max(0.0, r * r - (double)(npos - get<1>(pos)) * (double)(npos - get<1>(pos))));
    };
    ConvexHullTrickAddMonotone<int64_t, false> lines;
    lines.add(-1, -1000000000);
    for (size_t i = 0; i < pos.size(); i++)
    {
        if (get<1>(pos[i]) > 0) {
            int64_t r2 = get<2>(pos[i]) - get<1>(pos[i]);
            int64_t c2 = get<1>(pos[i]);
            lines.add(2 * c2, r2 * r2 - c2 * c2);
        }
    }
    for (size_t i = 0; i < pos.size(); i++)
    {
        int64_t npos = get<0>(pos[i]);
        if (get<1>(pos[i]) <= 0) {
            double max = 0;
            //if (!first.empty()) {
            //    max = std::max(max, dist(first.back(), npos));
            //}

            result[-get<1>(pos[i])] = std::sqrt(std::max<int64_t>(0, lines.query_monotone_inc(npos) - npos * npos));
        }
    }
    for (size_t i = 0; i < q; i++)
    {
        out
            << std::fixed << std::setprecision(9)
            << result[i] << '\n';

    }

    return 0;
}
#endif

