#include <iostream>
#include <cassert>
#include <map>
#include <tuple>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;
using ll = long long;
const int FOOTWAY = 0;
const int ROADWAY = 1;
const ll mod = 1000LL * 1000LL * 1000LL + 7LL;
const int INFI = 1<<28;
const ll INFL = 1LL<<60;

namespace {

    struct Edge {
        int from, to;
        ll cost;
        int type;
        Edge(int from, int to, ll cost, int type) : from(from), to(to), cost(cost), type(type) {}
    };

    ll cost_waiting_taxi(int z) {
        return (1LL<<z) - 1LL;
    }
    ll cost_waiting_taxi_mod(int z) {
        ll x = 1LL;
        ll ans = 0LL;
        for (int i = 0; i < z; i++) {
            ans = (ans + x) % mod;
            x = (x * 2LL) % mod;
        }
        return ans;
    }

    int N, P, Q;
    vector<vector<Edge>> G;

    bool input() {
        cin >> N >> P >> Q;
        if (N == 0 && P == 0 && Q == 0) return false;
        G = vector<vector<Edge>>(N);
        for (int i = 0; i < P; i++) {
            // 歩道
            int a, b, c; {
                cin >> a >> b >> c;
                a--; b--;
            }
            G[a].emplace_back(a, b, c, FOOTWAY);
            G[b].emplace_back(b, a, c, FOOTWAY);
        }
        for (int i = 0; i < Q; i++) {
            // 車道
            int d, e, f; {
                cin >> d >> e >> f;
                d--; e--;
            }
            G[d].emplace_back(d, e, f, ROADWAY);
            G[e].emplace_back(e, d, f, ROADWAY);
        }
        return true;
    }

    struct Cost {
        int n;
        ll c;
        Cost(int n, ll c) : n(n), c(c) {}
    };
    bool operator<(const Cost& a, const Cost& b) {
        if (a.n < b.n) return true;
        if (a.n > b.n) return false;
        return a.c < b.c;
    }
    bool operator>(const Cost& a, const Cost& b) {
        if (a.n > b.n) return true;
        if (a.n < b.n) return false;
        return a.c > b.c;
    }
    Cost operator+(const Cost& a, const Cost& b) {
        return Cost(a.n + b.n, a.c + b.c);
    }
    struct State {
        int v;
        int t;
        Cost cost;
        State(int v, int t, Cost cost) : v(v), t(t), cost(cost) {}
    };
    bool operator<(const State& s, const State& t) {
        return s.cost > t.cost;
    }
    Cost calc_z0() {
        // (z0, c)を返す
        // z0: 0からN-1に移動する際、最小のタクシー乗車回数, c:そのときの最小移動時間
        priority_queue<State> PQ;
        vector<vector<Cost>> d(2, vector<Cost>(N, Cost(INFI, INFL)));
        d[0][0] = Cost(0, 0LL);
        PQ.emplace(0, 0, Cost(0, 0LL));
        while (not PQ.empty()) {
            auto cur = PQ.top(); PQ.pop();
            if (cur.t == 0) {
                for (auto&& e : G[cur.v]) {
                    int nv = e.to;
                    int nt = e.type;
                    auto cost_add = Cost(e.type, e.cost);
                    auto ncost = cur.cost + cost_add;
                    if (d[nt][nv] > ncost) {
                        d[nt][nv] = ncost;
                        PQ.emplace(nv, nt, ncost);
                    }
                }
            } else {
                for (auto&& e : G[cur.v]) {
                    int nv = e.to;
                    int nt = e.type;
                    auto cost_add = Cost(0, e.cost);
                    auto ncost = cur.cost + cost_add;
                    if (d[nt][nv] > ncost) {
                        d[nt][nv] = ncost;
                        PQ.emplace(nv, nt, ncost);
                    }
                }
            }
        }
        return min(d[0][N-1], d[1][N-1]);
    }

    struct CState {
        int t, v; // t: タクシーに乗車しているかどうか、v: 今どの頂点にいるか
        int z; // z: タクシー乗車回数
        ll cost;
        CState(int t, int v, int z, ll cost) : t(t), v(v), z(z), cost(cost) {}
    };
    bool operator<(const CState& a, const CState& b) {
        return a.cost > b.cost;
    }

    ll d[2][20001][42];
    ll calc_cost(int zlim) {
        // z回までタクシー乗車を許容するときの最小コスト
        priority_queue<CState> PQ;
        {
            for (int t = 0; t < 2; t++) for (int v=0; v < N; v++){
               for (int z = 0; z <= zlim; z++) {
                   d[t][v][z] = INFL;
               }
            }
            d[0][0][0] = 0LL;
        }
        PQ.emplace(0, 0, 0, 0LL);
        while (not PQ.empty()) {
            auto cur = PQ.top(); PQ.pop();
            auto t = cur.t, v = cur.v, z = cur.z;
            if (t == 0) {
                for (auto&& e : G[cur.v]) {
                    int nt = e.type; // e.typeがROADWAY(1)なら1, FOOTWAY(0)なら0
                    int nv = e.to;
                    int nz = z + nt;
                    if (nz > zlim) continue;
                    ll ncost = cur.cost + e.cost;
                    if (d[nt][nv][nz] > ncost) {
                        PQ.emplace(nt, nv, nz, ncost);
                        d[nt][nv][nz] = ncost;
                    }
                }
            } else if (t == 1) {
                for (auto&& e : G[cur.v]) {
                    int nt = e.type; // e.typeがROADWAY(1)なら1, FOOTWAY(0)なら0
                    int nv = e.to;
                    int nz = z;
                    ll ncost = cur.cost + e.cost;
                    if (d[nt][nv][nz] > ncost) {
                        PQ.emplace(nt, nv, nz, ncost);
                        d[nt][nv][nz] = ncost;
                    }
                }
            } else { assert(false); }
        }

        ll ans = INFL;
        for (int t = 0; t <= 1; t++) {
            for (int z = 0; z <= zlim; z++) {
                if (d[t][N-1][z] == INFL) continue;
                ans = min(ans, d[t][N-1][z] + cost_waiting_taxi(z));
            }
        }
        return ans;
    }

    void solve() {
        Cost c_z0 = calc_z0();
        auto z0 = c_z0.n;
        if (z0 == INFI) {
            cout << -1 << endl;
            return;
        }
        ll ans = INFL;
        int k = 40;
        //cout << "z0: " << z0 << endl;
        if (z0 > k) {
            ans = (c_z0.c + cost_waiting_taxi_mod(z0)) % mod;
        } else {
            ans = calc_cost(k);
        }
        cout << ans % mod << endl;
    }

}

int main() {
    int t = 0;
    while (t++, input()) {
        //cout << "t: " << t << endl;
        solve();
    }
}

