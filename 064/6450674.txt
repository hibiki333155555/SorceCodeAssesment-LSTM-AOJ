#include <iostream>
#include <tuple>
using namespace std;

#include <iostream>
#include <cassert>

template<long long mod>
class modint{
private:
  using T = long long;
  T a;
public:
  constexpr modint(const long long x = 0) noexcept : a((x%mod+mod)%mod) {}
  constexpr T& value() noexcept { return a; }
  constexpr const T& value() const noexcept { return a; }
  constexpr modint operator-() const noexcept {
    return modint(0) -= *this;
  }
  constexpr modint operator+(const modint& rhs) const noexcept {
    return modint(*this) += rhs;
  }
  constexpr modint operator-(const modint& rhs) const noexcept {
    return modint(*this) -= rhs;
  }
  constexpr modint operator*(const modint& rhs) const noexcept {
    return modint(*this) *= rhs;
  }
  constexpr modint operator/(const modint& rhs) const noexcept {
    return modint(*this) /= rhs;
  }
  constexpr modint& operator+=(const modint& rhs) noexcept {
    a += rhs.a;
    if(a >= mod) a -= mod;
    return *this;
  }
  constexpr modint& operator-=(const modint& rhs) noexcept {
    if(a < rhs.a) a += mod;
    a -= rhs.a;
    return *this;
  }
  constexpr modint& operator*=(const modint& rhs) noexcept {
    a = a*rhs.a%mod;
    return *this;
  }
  constexpr modint& operator/=(const modint& rhs) noexcept {
    return *this *= rhs.inv();
  }
  constexpr bool operator==(const modint& rhs) const noexcept {
    return a == rhs.a;
  }
  constexpr bool operator!=(const modint& rhs) const noexcept {
    return not (*this == rhs);
  }
  constexpr modint pow(long long k) const noexcept {
    modint ret(1);
    modint x = k > 0 ? *this : this->inv();
    k = abs(k);
    while(k > 0){
      if(k&1) ret *= x;
      x *= x;
      k >>= 1;
    }
    return ret;
  }
  constexpr modint inv() const noexcept {
    return pow(mod-2);
  }
  friend std::ostream& operator<<(std::ostream &os, const modint &X) noexcept {
    return os << X.a;
  }
  friend std::istream& operator>>(std::istream &is, modint &X) noexcept {
    is >> X.a;
    X.a %= mod;
    if(X.a < 0) X.a += mod;
    return is;
  }
};

#include <cassert>
#include <vector>

struct LCA {
private:
  std::vector<std::vector<int>> G;
  size_t n, m;
  std::vector<std::vector<int>> A;
  void dfs(int v, int p){
    for(auto v_ : G[v]){
      if(v_ == p) continue;
      A[v_][0] = v;
      D[v_] = D[v]+1;
      dfs(v_,v);
    }
  }
  void build(int r){
    dfs(r,-1);
    A[r][0] = r;
    for(size_t i = 1; i < m; ++i){
      for(size_t j = 0; j < n; ++j){
        A[j][i] = A[A[j][i-1]][i-1];
      }
    }
   }
public:
  std::vector<int> D;
  LCA(const std::vector<std::vector<int>>& Tree, int r) : G(Tree), n(Tree.size()), m(1), D(n,0) {
    size_t t = 1;
    while(t < n) ++m, t *= 2;
    A = std::vector<std::vector<int>>(n,std::vector<int>(m,-1));
    build(r);
  }
  size_t query(int u, int v){
    if(D[u] < D[v]) std::swap(u,v);

    for(size_t i = m-1; i < m; --i){
      size_t u_ = A[u][i];
      if(D[u_] < D[v]) continue;
      u = u_;
    }

    if(u == v) return u;
    assert(D[u] == D[v]);
    for(size_t i = m-1; i < m; --i){
      if(A[u][i] != A[v][i])
        u = A[u][i], v = A[v][i];
    }
    return A[u][0];
  }
  int ancestor(int v, int d){
    for(size_t i = m-1; i < m; --i){
      if(d>>i&1) v = A[v][i];
    }
    return v;
  }
};

int main(){
  using mint = modint<998244353>;
  int n;
  cin >> n;
  vector<vector<int>> G(n);
  for(int i = 0; i+1 < n; ++i){
    int a, b;
    cin >> a >> b;
    --a,--b;
    G[a].emplace_back(b);
    G[b].emplace_back(a);
  }
  vector<mint> S(n);
  auto rec = [&](auto&& rec, int v, int p) -> mint {
    S[v] += 1;
    for(auto u : G[v]){
      if(u == p) continue;
      S[v] += rec(rec,u,v)*2;
    }
    return S[v];
  };
  rec(rec,0,-1);
  LCA lca(G,0);
  int q;
  cin >> q;
  vector<tuple<int,int>> Q;
  for(int i = 0; i < q; ++i){
    int a, b;
    cin >> a >> b;
    --a,--b;
    Q.emplace_back(a,b);
  }
  vector<mint> T(n);
  auto dp = [&](auto&& dp, int v, int p, mint d) -> void {
    T[v] = S[v] + d*2;
    d *= 2;
    d += 1;
    for(auto u : G[v]){
      if(u == p) continue;
      d += S[u]*2;
    }
    for(auto u : G[v]){
      if(u == p) continue;
      dp(dp,u,v,d-S[u]*2);
    }
  };
  dp(dp,0,-1,0);
  for(int i = 0; i < q; ++i){
    auto [a,b] = Q[i];
    if(lca.D[a] < lca.D[b]) swap(a,b);
    int c = lca.query(a,b);
    int d = lca.D[a] + lca.D[b] - lca.D[c]*2;
    mint ans = mint(2).pow(d);
    if(c == b){
      int bb = lca.ancestor(a,d-1);
      ans *= S[a]*(T[b]-S[bb]*2);
    }else{
      ans *= S[a]*S[b];
    }
    cout << ans << "\n";
  }
}

