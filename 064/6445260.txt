#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

/* macro */

#define rep(i, a, n) for (int i = (int)(a); i < (int)(n); i++)
#define rrep(i, a, n) for (int i = ((int)(n - 1)); i >= (int)(a); i--)
#define Rep(i, a, n) for (i64 i = (i64)(a); i < (i64)(n); i++)
#define RRep(i, a, n) for (i64 i = ((i64)(n - i64(1))); i >= (i64)(a); i--)
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define Bit(n) (1LL << (n))

/* macro end */

/* template */

namespace ebi {

#ifdef LOCAL
#define debug(...)                                                      \
    std::cerr << "LINE: " << __LINE__ << "  [" << #__VA_ARGS__ << "]:", \
        debug_out(__VA_ARGS__)
#else
#define debug(...)
#endif

void debug_out() { std::cerr << std::endl; }

template <typename Head, typename... Tail>
void debug_out(Head h, Tail... t) {
    std::cerr << " " << h;
    if (sizeof...(t) > 0) std::cout << " :";
    debug_out(t...);
}

template <typename T1, typename T2>
std::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &pa) {
    return os << pa.first << " " << pa.second;
}

template <typename T1, typename T2>
std::istream &operator>>(std::istream &os, std::pair<T1, T2> &pa) {
    return os >> pa.x >> pa.y;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {
    for (std::size_t i = 0; i < vec.size(); i++)
        os << vec[i] << (i + 1 == vec.size() ? "" : " ");
    return os;
}

template <typename T>
std::istream &operator>>(std::istream &os, std::vector<T> &vec) {
    for (T &e : vec) std::cin >> e;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::optional<T> &opt) {
    if (opt) {
        os << opt.value();
    } else {
        os << "invalid value";
    }
    return os;
}

using size_t = std::size_t;
using i32 = std::int32_t;
using u32 = std::uint32_t;
using i64 = std::int64_t;
using u64 = std::uint64_t;

template <class T>
void fill(std::vector<T> &v) {
    for (T &e : v) std::cin >> e;
}

template <class T>
inline bool chmin(T &a, T b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
inline bool chmax(T &a, T b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

template <class T>
T gcd(T a, T b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

template <class T>
T lcm(T a, T b) {
    a /= gcd(a, b);
    return a * b;
}

template <class T>
T Pow(T x, i64 n) {
    T res = 1;
    while (n > 0) {
        if (n & 1) res = res * x;
        x = x * x;
        n >>= 1;
    }
    return res;
}

template <class T>
T mod_pow(T x, i64 n, i64 mod) {
    T res = 1;
    while (n > 0) {
        if (n & 1) res = (res * x) % mod;
        x = (x * x) % mod;
        n >>= 1;
    }
    return res;
}

template <class T>
T scan() {
    T val;
    std::cin >> val;
    return val;
}

template <class T>
struct Edge {
    int to;
    T cost;
    Edge(int _to, T _cost = 1) : to(_to), cost(_cost) {}
};

template <class T>
struct Graph : std::vector<std::vector<Edge<T>>> {
    using std::vector<std::vector<Edge<T>>>::vector;
    void add_edge(int u, int v, T w, bool directed = false) {
        (*this)[u].emplace_back(v, w);
        if (directed) return;
        (*this)[v].emplace_back(u, w);
    }
};

struct graph : std::vector<std::vector<int>> {
    using std::vector<std::vector<int>>::vector;
    void add_edge(int u, int v, bool directed = false) {
        (*this)[u].emplace_back(v);
        if (directed) return;
        (*this)[v].emplace_back(u);
    }
};

constexpr i64 LNF = std::numeric_limits<i64>::max() / 4;

constexpr int INF = std::numeric_limits<int>::max() / 2;

const std::vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
const std::vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};

}  // namespace ebi

/*
    reference: https://gist.github.com/draftcode/1357281
*/

namespace ebi {

typedef std::string::const_iterator State;
class ParseError {};

bool expect(State &begin, char expected) {
    if(*begin == expected) {
        return true;
    }
    else {
        return false;
    }
}

// beginがexpectedを指していたらbeginを一つ進める。
void consume(State &begin, char expected) {
    if (*begin == expected) {
        begin++;
    } else {
        std::cerr << "Expected '" << expected << "' but got '" << *begin << "'"
            << std::endl;
        std::cerr << "Rest string is '";
        while (*begin) {
            std::cerr << *begin++;
        }
        std::cerr << "'" << std::endl;
        throw ParseError();
    }
}

bool isdigit(char c) {
    return '0' <= c && c <= '9';
}

bool isAlpha(char c) {
    return 'A' <= c && c <= 'Z';
}

bool isalpha(char c) {
    return 'a' <= c && c <= 'z';
}

}

namespace ebi {

int E(State &begin, int bit) {
    int ret = 0;
    if(expect(begin, '-')) {
        consume(begin, '-');
        ret = 1^E(begin, bit);
    }
    else if(expect(begin, '(')) {
        consume(begin, '(');
        ret = E(begin, bit);
        if(expect(begin, '^')) {
            consume(begin, '^');
            ret ^= E(begin, bit);
        }
        else if(expect(begin, '*')) {
            consume(begin, '*');
            ret *= E(begin, bit);
        }
        else {
            assert(false);
        }
        consume(begin, ')');
    }
    else {
        if(isdigit(*begin)) {
            ret = *begin -'0';
            assert(ret == 0 || ret == 1);
            consume(begin, char(ret+'0'));
        }
        else if(isalpha(*begin)) {
            assert('a' <= *begin && *begin <= 'd');
            ret = (bit & (1<<(*begin - 'a'))) ? 1 : 0;
            consume(begin, *begin);
        }
        else {
            assert(false);
        }
    }
    return ret;
}

int truth_table(std::string s) {
    int table = 0;
    rep(bit,0,1<<4) {
        State begin = s.begin();
        table |= E(begin, bit)<<bit;
    }
    return table;
}

void main_() {
    const int sz = 1<<4;
    std::vector dp(17, std::vector<int>());
    std::vector<int> ans(1<<sz, INF);
    const int mask = (1<<sz) - 1;
    dp[1].emplace_back(0);
    dp[1].emplace_back(mask);
    ans[0] = ans[mask] = 1;
    rep(i,0,4) {
        int ret = 0;
        rep(bit,0,sz) {
            if(bit & (1<<i)) ret |= 1<<bit;
        }
        dp[1].emplace_back(ret);
        ans[ret] = 1;
    }
    rep(i,2,17) {
        for(auto bit: dp[i-1]) {
            int ret = bit ^ mask;
            if(ans[ret] == INF) {
                ans[ret] = i;
                dp[i].emplace_back(ret);
            }
        }
        rep(j,1,i-3) {
            int k = i-3-j;
            assert(k > 0 && j+k+3 == i);
            for(auto s: dp[j]) for(auto t: dp[k]) {
                if(ans[s^t] == INF) {
                    ans[s^t] = i;
                    dp[i].emplace_back(s^t);
                }
                if(ans[s&t] == INF) {
                    ans[s&t] = i;
                    dp[i].emplace_back(s&t);
                }
            }
        }
    }
    std::string s;
    while(std::cin >> s, s != ".") {
        std::cout << ans[truth_table(s)] << '\n';
    }
}

}  // namespace ebi

int main() {
    std::cout << std::fixed << std::setprecision(15);
    std::cin.tie(nullptr);
    std::ios::sync_with_stdio(false);
    int t = 1;
    // std::cin >> t;
    while (t--) {
        ebi::main_();
    }
    return 0;
}
