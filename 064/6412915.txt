#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <utility>
#include <tuple>
#include <cstdint>
#include <cstdio>
#include <map>
#include <cstdint>
#include <queue>
#include <set>
#include <stack>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include <bitset>
#include <cctype>
#include <functional>
#include <ctime>
#include <fstream>
#include <cmath>
#include <limits>
#include <chrono>
#include <numeric>
#include <type_traits>
#include <iomanip>
#include <float.h>
#include <math.h>
#include <cassert>
#include <random>
using namespace std;
using ll = long long;

struct segtree {
	int n;
	vector<int> node;
	vector<int> lazy;
	segtree(int x) {
		int g = 1;
		while (g < x)g *= 2;
		n = g;
		g *= 2;
		node.resize(g,0);
		lazy.resize(g);
	}

	void update(int s, int t, int x) {
		updates(s, t, x, 1, 0, n);
	}

	void eval(int k,int l,int r) {
		node[k] += lazy[k];
		if (r - l > 1) {
			lazy[2 * k] += lazy[k];
			lazy[2 * k+1] += lazy[k];
		}
		lazy[k] = 0;
	}

	void updates(int s, int t, int x,int k,int l,int r) {
		eval(k, l, r);
		if (s >= r || t <= l) {
			eval(k, l, r);
			return;
		}
		if (s <= l && t >= r) {
			eval(k, l, r);
			lazy[k] += x;
			eval(k, l, r);
			return;
		}
		updates(s, t, x, 2 * k, l, (l + r) / 2);
		eval(k, l, r);
		updates(s, t, x, 2 * k+1, (l + r) / 2, r);
		eval(k, l, r);
		node[k] = min(node[2 * k], node[2 * k + 1]);
		eval(k, l, r);
	}

	int que(int s, int t) {
		int ans = 1100000000;
		queu(s, t, ans, 1, 0, n);
		return ans;
	}
	void queu(int s, int t, int &ans,int k,int l,int r) {
		eval(k, l, r);
		if (s >= r || t <= l) {
			eval(k, l, r);
			return;
		}
		if (s <= l && t >= r) {
			eval(k, l, r);
			ans = min(ans, node[k]);
			eval(k, l, r);
			return;
		}
		eval(k, l, r);
		queu(s, t, ans, 2 * k, l, (l + r) / 2);
		eval(k, l, r);
		queu(s, t, ans, 2 * k + 1, (l + r) / 2, r);
		eval(k, l, r);
	}
};


int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n, q;
	cin >> n >> q;
	segtree s(n);
	for (int i = 0; i < q; i++) {
		int a;
		cin >> a;
		if (a == 0) {
			int b, c, d;
			cin >> b >> c >> d;
			s.update(b, c + 1, d);
		}
		else {
			int b, c;
			cin >> b >> c;
			cout << s.que(b, c + 1) << endl;
		}
	}
}


