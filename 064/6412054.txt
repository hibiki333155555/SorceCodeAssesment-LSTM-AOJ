use std::io::*;
use std::str::FromStr;
use std::iter::*;

#[derive(Debug)]
struct Dice {
    tp: i32, ft: i32, rt: i32, lt: i32, bk: i32, bm: i32,
}
#[allow(dead_code)]
impl Dice {
    fn new(s: Vec<i32>) -> Dice {
        Dice{ tp: s[0], ft: s[1], rt: s[2], lt: s[3], bk: s[4], bm: s[5] }
    }
    fn roll(&mut self, ch: char) {
        match ch {
            'N' => { let tmp = self.tp; self.tp = self.ft; self.ft = self.bm; self.bm = self.bk; self.bk = tmp; },
            'S' => { let tmp = self.tp; self.tp = self.bk; self.bk = self.bm; self.bm = self.ft; self.ft = tmp; },
            'E' => { let tmp = self.tp; self.tp = self.lt; self.lt = self.bm; self.bm = self.rt; self.rt = tmp; },
            'W' => { let tmp = self.tp; self.tp = self.rt; self.rt = self.bm; self.bm = self.lt; self.lt = tmp; },
            _ => {},
        }
    }
}

fn main() {
    let cin = stdin();
    let cin = cin.lock();
    let mut sc = Scanner::new(cin);
    let n: usize = sc.read();
    //let mut s = String::new();
    //std::io::stdin().read_line(&mut s).ok();
    //let vca: Vec<i32> = s.split_whitespace().map(|e| e.parse().unwrap()).collect();
    let mut d: Vec<Vec<i32>> = vec![vec![0; 6]; n];
    //let mut d: [[i32; 6]; 100] = [[0; 6]; 100];
    
    for i in 0..n{
       for j in 0..6{
           d[i][j] = sc.read();
       }
    }
    let mut flg = false;
    for i in 0..n-1{
        let mut ds = Dice::new(d[i].to_vec());
        //println!("{:?}", ds);
        for j in i+1..n{
            if d[j][1] ==ds.lt || d[j][1] ==ds.rt { ds.roll('W');  }
            for _ in 0..3{
                if d[j][1] == ds.ft { break;}
                ds.roll('S');  
            }
            for _ in 0..3{
                if d[j][0] == ds.tp {break;}
                ds.roll('W');  
            } 
            if d[j][0] == ds.tp && d[j][1] == ds.ft && d[j][2] == ds.rt && 
                d[j][3] == ds.lt && d[j][4] == ds.bk && d[j][5] == ds.bm {
                flg = true;
                break;
            } 
            //println!("{:?}", ds);
            //println!("{:?}", d[j]);
        }
        if flg {break;}
    }
    if flg { println!("No");}
    else { println!("Yes");} 
    // for cmd in cmds.chars() {}
}

struct Scanner<R: Read> {
    reader: R,
}
#[allow(dead_code)]
impl<R: Read> Scanner<R> {
    fn new(reader: R) -> Scanner<R> {
        Scanner { reader: reader }
    }
    fn safe_read<T: FromStr>(&mut self) -> Option<T> {
        let token = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)
            .skip_while(|c| c.is_whitespace())
            .take_while(|c| !c.is_whitespace())
            .collect::<String>();
        if token.is_empty() {
            None
        } else {
            token.parse::<T>().ok()
        }
    }

    fn read<T: FromStr>(&mut self) -> T {
        if let Some(s) = self.safe_read() {
            s
        } else {
            writeln!(stderr(), "Terminated with EOF").unwrap();
            std::process::exit(0);
        }
    }
}
