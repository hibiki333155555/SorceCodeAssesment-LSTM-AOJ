#include "iostream"
#include "climits"
#include "list"
#include "queue"
#include "stack"
#include "set"
#include "functional"
#include "algorithm"
#include "string"
#include "map"
#include "unordered_map"
#include "unordered_set"
#include "iomanip"
#include "cmath"
#include "random"
#include "bitset"
#include "cstdio"
#include "numeric"
#include "cassert"
#include "ctime"


using namespace std;

//constexpr long long int MOD = 1000000007;
constexpr long long int MOD = 998244353;
constexpr double EPS = 1e-8;

//int N, M, K, T, H, W, L, R;
long long int N, M, K, T, H, W, L, R;

class SuffixArray {
public:
	vector<int>ans;
	vector<int>id;
	vector<int>lcp;
	void InducedSort(vector<int>& ret, const vector<int>& v, const vector<int>& large, vector<int>& lft, vector<int>& rht) {
		for (int i = 0; i < v.size(); i++) {
			if (ret[i] == -1)continue;
			if (ret[i] == 0)continue;
			if (!large[ret[i] - 1])continue;
			ret[lft[v[ret[i] - 1]]++] = ret[i] - 1;
		}
		for (int i = v.size() - 1; i >= 0; i--) {
			if (ret[i] == -1)continue;
			if (ret[i] == 0)continue;
			if (large[ret[i] - 1])continue;
			ret[--rht[v[ret[i] - 1]]] = ret[i] - 1;
		}
	}
	vector<int> Solve(vector<int>v, int mx) {
		vector<int>ret;
		vector<int>large;
		vector<int>num;
		vector<int>nx_lms;
		vector<bool>lms;
		vector<int>rht;
		vector<int>lft;
		if (v.size() == 1) {
			return vector<int>(1);
		}
		large.resize((v.size()));
		nx_lms.resize(v.size(), v.size() - 1);
		lms.resize(v.size());
		lms.back() = true;
		for (int i = v.size() - 2; i >= 0; i--) {
			if (v[i] > v[i + 1]) {
				large[i] = 1;
			}
			else if (v[i] < v[i + 1]) {
				large[i] = 0;
			}
			else {
				large[i] = large[i + 1];
			}
		}
		for (int i = v.size() - 2; i > 0; i--) {
			if (large[i - 1] && !large[i]) {
				lms[i] = true;
				nx_lms[i - 1] = i;
			}
			else {
				nx_lms[i - 1] = nx_lms[i];
			}
		}
		ret.resize(v.size(), -1);
		num.resize(mx + 1);
		lft.resize(mx + 1);
		rht.resize(mx + 1);
		for (auto i : v) {
			num[i]++;
		}
		for (int i = 1; i <= mx; i++) {
			num[i] += num[i - 1];
		}
		rht[0] = num[0];
		for (int i = 1; i <= mx; i++) {
			rht[i] = num[i];
			lft[i] = num[i - 1];
		}
		for (int i = 1; i < v.size(); i++) {
			if (lms[i]) {
				ret[--rht[v[i]]] = i;
			}
		}
		for (int i = 0; i <= mx; i++) {
			rht[i] = num[i];
		}
		InducedSort(ret, v, large, lft, rht);
		vector<int>nxv;
		int nxmx = -1;
		vector<int>conv(v.size());
		vector<int>nxp;
		for (int i = 0; i + 1 < v.size(); i++) {
			if (large[i] && !large[i + 1]) {
				nxp.push_back(i + 1);
			}
		}
		vector<int>bef;
		for (int i = 0; i < v.size(); i++) {
			if (lms[ret[i]]) {
				vector<int> aft;
				for (int j = ret[i]; j <= nx_lms[ret[i]]; j++) {
					aft.push_back(v[j]);
				}
				if (bef != aft) {
					nxmx++;
					bef = aft;
				}
				conv[ret[i]] = nxmx;
			}
		}
		for (int i = 0; i < v.size(); i++) {
			if (lms[i]) {
				nxv.push_back(conv[i]);
			}
		}

		auto nxret = Solve(nxv, nxmx);

		for (auto& i : ret)i = -1;

		rht[0] = num[0];
		lft[0] = 0;
		for (int i = 1; i <= mx; i++) {
			rht[i] = num[i];
			lft[i] = num[i - 1];
		}


		for (int i = nxret.size() - 1; i >= 0; i--) {
			ret[--rht[v[nxp[nxret[i]]]]] = nxp[nxret[i]];
		}

		for (int i = 0; i <= mx; i++) {
			rht[i] = num[i];
		}

		InducedSort(ret, v, large, lft, rht);
		return ret;
	}
	SuffixArray(string s) {
		vector<int>v;
		int mx = 0;
		for (auto i : s) {
			v.push_back(i + 1);
			mx = max(mx, i + 1);
		}
		v.push_back(0);
		ans = Solve(v, mx);
		ans.erase(ans.begin());
		id.resize(ans.size());
		lcp.resize(ans.size());
		for (int i = 0; i < ans.size(); i++) {
			id[ans[i]] = i;
		}
		for (int i = 0; i < id.size(); i++) {
			int nx = id[i];
			if (nx + 1 == id.size())continue;
			nx = ans[nx + 1];
			int idx = i;
			if (i && lcp[id[i - 1]]) {
				lcp[id[i]] = lcp[id[i - 1]] - 1;
				nx += lcp[id[i]];
				idx += lcp[id[i]];
			}
			while (nx < id.size() && i < id.size() && s[idx] == s[nx]) {
				lcp[id[i]]++;
				nx++;
				idx++;
			}
		}
	}
};

class Segment_Tree {
	vector<long long int>v;
	int num;
	long long int ret;
	bool is_min;
	long long int Update(int place) {
		if (place >= v.size() / 2) {
			return v[place];
		}
		if (is_min) {
			v[place] = min(Update(place * 2), Update(place * 2 + 1));
			return v[place];
		}
		v[place] = max(Update(place * 2), Update(place * 2 + 1));
		return v[place];
	}
public:
	Segment_Tree(int n, bool min) {
		n++;
		num = 1;
		while (num < n * 2) {
			num *= 2;
		}
		is_min = min;
		if (min) {
			v.resize(num, MOD * MOD);
		}
		else v.resize(num, -MOD * MOD);
	}
	void Insert(int place, long long int num, bool update) {
		place += v.size() / 2;
		v[place] = num;
		if (!update)return;
		place /= 2;
		while (place) {
			if (is_min)v[place] = min(v[place * 2], v[place * 2 + 1]);
			else v[place] = max(v[place * 2], v[place * 2 + 1]);
			place /= 2;
		}
	}
	void TopDown() {
		Update(1);
	}
	long long int RMQ(int a, int b) {
		if (is_min)ret = LLONG_MAX;
		else ret = LLONG_MIN;
		if (is_min) {
			b++;
			for (a += num / 2, b += num / 2; a < b; a >>= 1, b >>= 1) {
				if (a & 1)ret = min(ret, v[a++]);
				if (b & 1)ret = min(ret, v[--b]);
			}
		}
		else {
			b++;
			for (a += num / 2, b += num / 2; a < b; a >>= 1, b >>= 1) {
				if (a & 1)ret = max(ret, v[a++]);
				if (b & 1)ret = max(ret, v[--b]);
			}
		}
		return ret;
	}
};

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> N;
	string s;
	cin >> s;
	string t;
	t = s + "#";
	reverse(s.begin(), s.end());
	t += s;
	SuffixArray sa(t);
	Segment_Tree sg(2 * N + 1, true);
	for (int i = 0; i < sa.lcp.size(); i++) {
		sg.Insert(i, sa.lcp[i], true);
	}
	int ans = 0;
	for (int i = 0; i < N - 1; i++) {
		int l = sa.id[i + 1];
		int r = sa.id[2 * N - i];
		if (l > r)swap(l, r);
		if (sg.RMQ(l, r-1) == min(i + 1, (int)N - i - 1)) {
			ans++;
		}
	}
	cout << ans << endl;
}
