#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
template<class T> using V = vector<T>;
using VI = V<int>;
using VL = V<ll>;
using VS = V<string>;
template<class T> using PQ = priority_queue<T, V<T>, greater<T>>;
using graph = V<VI>;
template<class T> using w_graph = V<V<pair<int, T>>>;
#define FOR(i,a,n) for(int i=(a);i<(n);++i)
#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)
#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)
#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define inside(h,w,y,x) (unsigned(y)<h&&unsigned(x)<w)
#ifdef _DEBUG
#define line cout << "-----------------------------\n"
#define stop system("pause")
#endif
constexpr ll INF = 1000000000;
constexpr ll LLINF = 1LL << 61;
constexpr ll mod = 1000000007;
constexpr ll MOD = 998244353;
constexpr ld eps = 1e-10;
constexpr int dy[]{ -1,0,1,0 }, dx[]{ 0,1,0,-1 };
template<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }
template<class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }
inline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }
template<class T> inline istream& operator>>(istream& is, V<T>& v) { for (auto& a : v)is >> a; return is; }
template<class T, class U> inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template<class T> inline V<T> vec(size_t a) { return V<T>(a); }
template<class T> inline V<T> defvec(T def, size_t a) { return V<T>(a, def); }
template<class T, class... Ts> inline auto vec(size_t a, Ts... ts) { return V<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }
template<class T, class... Ts> inline auto defvec(T def, size_t a, Ts... ts) { return V<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }
template<class T> inline void print(const T& a) { cout << a << "\n"; }
template<class T, class... Ts> inline void print(const T& a, const Ts&... ts) { cout << a << " "; print(ts...); }
template<class T> inline void print(const V<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? "\n" : " "); }
template<class T> inline void print(const V<V<T>>& v) { for (auto& a : v)print(a); }
template<class T> inline constexpr const T cumsum(const V<T>& a, int l, int r) { return 0 <= l && l <= r && r < a.size() ? a[r] - (l == 0 ? 0 : a[l - 1]) : 0; }//[l,r]
template<class T> inline constexpr const T min(const V<T>& v) { return *min_element(all(v)); }
template<class T> inline constexpr const T max(const V<T>& v) { return *max_element(all(v)); }

template<int modulo> struct ModInt {
    int x;

    ModInt() : x(0) {}
    ModInt(ll y) : x(y >= 0 ? y % modulo : (modulo - (-y) % modulo) % modulo) {}

    ModInt& operator+=(const ModInt& p) {
        if ((x += p.x) >= modulo) x -= modulo;
        return *this;
    }
    ModInt& operator-=(const ModInt& p) {
        if ((x += modulo - p.x) >= modulo) x -= modulo;
        return *this;
    }
    ModInt& operator*=(const ModInt& p) {
        x = (int)(1LL * x * p.x % modulo);
        return *this;
    }
    ModInt& operator/=(const ModInt& p) {
        *this *= p.inverse();
        return *this;
    }

    ModInt operator-() const { return ModInt(-x); }
    ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }
    ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }
    ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }
    ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }

    bool operator==(const ModInt& p) const { return x == p.x; }
    bool operator!=(const ModInt& p) const { return x != p.x; }

    ModInt inverse() const {
        int a = x, b = modulo, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            a -= t * b;
            swap(a, b);
            u -= t * v;
            swap(u, v);
        }
        return ModInt(u);
    }

    ModInt pow(ll e) {
        ll a = 1, p = x;
        while (e > 0) {
            if (e % 2 == 0) {
                p = (p * p) % modulo;
                e /= 2;
            }
            else {
                a = (a * p) % modulo;
                e--;
            }
        }
        return ModInt(a);
    }

    friend ostream& operator<<(ostream& os, const ModInt<modulo>& p) {
        return os << p.x;
    }
    friend istream& operator>>(istream& is, ModInt<modulo>& a) {
        ll x;
        is >> x;
        a = ModInt<modulo>(x);
        return (is);
    }
};
using mint = ModInt<MOD>;
int main() {
    init();

    int n; cin >> n;
    graph g(n);
    FOR(i, 0, n - 1) {
        int a, b; cin >> a >> b;
        --a, --b;
        g[a].push_back(b);
        g[b].push_back(a);
    }

    int logn = 17;
    auto nxt = defvec<int>(-1, logn + 1, n);
    VI dep(n);

    V<mint> dp1(n);
    auto f1 = [&](auto&& f, int cur, int par)->mint {
        dp1[cur] += 1;
        for (int to : g[cur]) {
            if (to == par)continue;
            nxt[0][to] = cur;
            dep[to] = dep[cur] + 1;
            dp1[cur] += f(f, to, cur) * 2;
        }
        return dp1[cur];
    };
    f1(f1, 0, -1);
    
    V<mint> dp2(n);
    auto f2 = [&](auto&& f, int cur, int par, mint x)->mint {
        dp2[cur] = dp1[cur] + x;
        for (int to : g[cur]) {
            if (to == par)continue;
            f(f, to, cur, (dp2[cur] - dp1[to] * 2) * 2);
        }
        return dp1[cur];
    };
    f2(f2, 0, -1, 0);

    FOR(j, 0, logn)FOR(i, 0, n) {
        if (nxt[j][i] != -1)nxt[j + 1][i] = nxt[j][nxt[j][i]];
    }

    auto lca = [&](int a, int b)->int {
        if (dep[a] > dep[b])swap(a, b);
        eFOR(j, 0, logn)if ((dep[b] - dep[a]) >> j & 1) {
            b = nxt[j][b];
        }
        if (a == b)return a;
        erFOR(j, 0, logn)if (nxt[j][a] != nxt[j][b]) {
            a = nxt[j][a];
            b = nxt[j][b];
        }
        return nxt[0][a];
    };
    auto up = [&](int x, int d)->int {
        eFOR(j, 0, logn)if (d >> j & 1) {
            x = nxt[j][x];
        }
        return x;
    };

    V<mint> p2(n + 1, 1);
    FOR(i, 0, n)p2[i + 1] = p2[i] * 2;

    int q; cin >> q;
    while (q--) {
        int x, y; cin >> x >> y;
        --x, --y;
        int z = lca(x, y);
        int d = dep[x] + dep[y] - dep[z] * 2;
        int prex = z != x ? nxt[0][x] : up(y, dep[y] - dep[x] - 1);
        int prey = z != y ? nxt[0][y] : up(x, dep[x] - dep[y] - 1);
        mint valx, valy;
        if (z == x)valx = dp2[x] - dp1[prex] * 2;
        else valx = dp2[x] - (dp2[prex] - dp1[x] * 2) * 2;
        if (z == y)valy = dp2[y] - dp1[prey] * 2;
        else valy = dp2[y] - (dp2[prey] - dp1[y] * 2) * 2;
        print((valx* p2[d] * valy));
    }


    return 0;
}
