#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}

template<typename T>
struct Dijkstra{
    const T inf=numeric_limits<T>::max();
    using P=pair<T,int>;
    int n;
    vector<vector<pair<int,T>>> g;
    vector<T> d;
    Dijkstra(int n):n(n),g(n),d(n){}
    void add_edge(int u,int v,T w){
        g[u].emplace_back(v,w);
    }
    vector<T> build(int s){
        for(int i=0;i<n;i++){
            d[i]=inf;
        }
        d[s]=0;
        priority_queue<P,vector<P>,greater<P>> pq;
        pq.emplace(d[s],s);
        while(pq.size()){
            P p=pq.top(); pq.pop();
            int v=p.second;
            if(d[v]<p.first)continue;
            for(auto &e:g[v]){
                int u=e.first; T c=e.second;
                if(d[u]>d[v]+c){
                    d[u]=d[v]+c;
                    pq.emplace(d[u],u);
                }
            }
        }
        return d;
    }
};

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n,m,T; cin >> n >> m >> T;
    int a,b,c; cin >> a >> b >> c;
    a--; b--; c--;
    Dijkstra<int> di(n);
    for(int i=0;i<m;i++){
        int x,y; cin >> x >> y;
        x--; y--;
        di.add_edge(x, y, 1);
        di.add_edge(y, x, 1);
    }
    vector<int> A = di.build(a);
    vector<int> B = di.build(b);
    vector<int> C = di.build(c);
    int L = 0, R = n+1;
    vector<int> d(n);
    auto check=[&](int mid)->bool{
        if(A[0]<mid) return false;
        if(B[0]<mid) return false;
        if(C[0]<mid) return false;
        for(int i=0;i<n;i++){
            d[i] = 1e9;
        }
        d[0] = 0;
        queue<int> q;
        q.push(0);
        while(q.size()){
            int s = q.front(); q.pop();
            for(auto to:di.g[s]){
                int t = to.first;
                if(A[t]>=mid and B[t]>=mid and C[t]>=mid and d[t]==1e9){
                    d[t] = d[s]+1;
                    q.push(t);
                }
            }
        }
        return (d.back()<=T);
    };
    while(R-L>1){
        int mid = (L+R)/2;
        if(check(mid)){
            L = mid;
        }
        else{
            R = mid;
        }
    }
    cout << L << endl;
}


