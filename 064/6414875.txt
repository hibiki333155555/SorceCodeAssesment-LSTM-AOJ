#include<iostream>
#include<string>
#include<iomanip>
#include<cmath>
#include<vector>
#include<algorithm>
#include<utility>

using namespace std;

#define int long long
#define endl "\n"

constexpr long long INF = 1e18;
constexpr long long MOD = 998244353; 

struct fast_io {
  fast_io(){
    std::cin.tie(nullptr);
    std::ios::sync_with_stdio(false);
    cout<<fixed<<setprecision(10);
  };
} fio;

class binomial_coefficients {
	long long MAX_VAL;
	vector<long long> fac, mmi;

public:

	binomial_coefficients(){
	}
	
	binomial_coefficients(long long num){
		init(num);
	}
	
	~binomial_coefficients(){
		
	}
	
	void init(long long num){
		MAX_VAL = num+1; 
		fac.resize(MAX_VAL);
		mmi.resize(MAX_VAL);
		
		factorial_mod();
		modular_multiplicatibe_inverse();
	}
	
	void factorial_mod(){
		 fac[0] = 1;
		for(long long i = 1; i < MAX_VAL; fac[i] %= MOD, i++)
			fac[i] = fac[i - 1] * (i % MOD);
	}
	
	long long power(long long x, long long n){
		long long ans = 1;
		for(;n;n >>= 1, x *= x, ans %= MOD, x %= MOD) if(n&1)ans*=x;
		return ans % MOD;
	}
	
	void exgcd(long long a, long long b, long long &x, long long &y){
		if(b == 0){
			x = 1;
			y = 0;
			return ;
		}
		exgcd(b, a % b, y, x);
		y -= a / b * x;
	}
	
	void modular_multiplicatibe_inverse(){
		long long x, y;  
		exgcd(fac[MAX_VAL - 1], MOD, x, y);
		mmi[MAX_VAL-1] = (x%MOD + MOD) % MOD;
		// mmi[MAX_VAL-1] = power(fac[MAX_VAL-1], MOD-2);
		for(long long i = MAX_VAL - 2; i >= 0; mmi[i]%=MOD, i--)
			mmi[i] = mmi[i + 1] * ((i + 1) % MOD);
	}
	
	long long combination(long long n, long long r){
		return n < r ? 0 :fac[n] * (mmi[r] * mmi[n-r] % MOD) % MOD;
	}
};

signed main(){
  
  int N;
  int ans = 1;
  vector<int> A;
  vector<int> con(10);
	binomial_coefficients BC;
  int a = 0, b = 0, c = 0, d = 0;
  
  cin>>N;
  
  A.resize(N+1, 6);
  BC.init(N*2);
  
  
  
  for(int i = 0; i < N+1; i++){
    if(i < N) cin>>A[i];
    con[A[i]]++;
    if(A[i]%2 && A[i]%3) d++;
    else if(A[i] == 6) {
      c++;
      ans *= BC.combination(a+b, a);
      ans %= MOD;
      a = 0, b = 0;
    } else if(A[i]%2 == 0) {
      a++;
    } else if(A[i]%3 == 0) {
      b++;
    }
  }
  
  ans *= BC.combination(N, d);
  ans %= MOD;
  ans *= BC.combination(d, d-con[1]);
  ans %= MOD;
  ans *= BC.combination(d-con[1], d-con[1]-con[5]);
  ans %= MOD;
  ans *= BC.combination(d-con[1]-con[5], d-con[1]-con[5]-con[7]);
  ans %= MOD;
  
  cout<<ans<<endl;
  
  return 0;
}
