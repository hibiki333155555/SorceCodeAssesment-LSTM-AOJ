#include<bits/stdc++.h>
using namespace std;

#define for_(i, a, b) for(int i = (a);i < (b);++i)
#define rfor_(i, a, b) for(int i = (b)-1;i >= (a);--i)
#define rep(i, n) for_(i, 0, n)
#define rrep(i, n) rfor_(i, 0, n)

/* accelration */
// 高速バイナリ生成
#pragma GCC target("avx")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
// cin cout の結びつけ解除, stdioと同期しない(入出力非同期化)
// cとstdの入出力を混在させるとバグるので注意
struct Fast {Fast() {std::cin.tie(0); ios::sync_with_stdio(false);}} fast;

/* define short */
#define all(obj) (obj).begin(), (obj).end()

/* alias */
using ull = unsigned long long;
using ll = long long;
const int inf = 100000000;
const ll infl = 1LL << 60;

ll mul(ll a, ll b) { if (infl / a < b) return infl; return min(infl, a * b); }
ll gcd(ll a, ll b) { return a ? gcd(b % a, a) : b; }
ll lcm(ll a, ll b) { if (a == infl || b == infl) return infl; return mul(a / gcd(a, b), b); }

template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }


// いい解き方が思いつかんかったので答え見た
// 8クイーン問題は、縦横斜めにおいてクイーンが存在しなければよい
// ということでる。つまり縦横に存在しないという点から、
// 8つのクイーンが同じ行、列にいることはあり得ない
// このことから順列計算に持っていける
// 各クイーンは(0, p0), (1, p1), …, (7, p7)というような座標になり、
// p0～p7には0～7がダブりなしではいる。順列列挙に持っていける。
int K;


int main() {
    cin >> K;
    vector<int> rs(K);
    vector<int> cs(K);
    rep(i, K) cin >> rs[i] >> cs[i];

    vector<int> queen_cs(8);   // 要素番号がrow, 要素がcol
    rep(i, 8) queen_cs[i] = i;

    do {
        // 指定した場所にqueenがあるか見る
        bool is_at_ordered_pos = true;
        rep(i, K) {
            if (queen_cs[rs[i]] != cs[i]) {
                is_at_ordered_pos = false;
                break;
            }
        }

        if (!is_at_ordered_pos) continue;

        // 斜め列にかぶりがないか見る
        // （※）斜めの見方注意
        // それぞれのクイーン同士において、行と列の差(dr, dc)をそれぞれ求め、
        // (dr == dc)か(dr == -dc)となるようなら、斜めにあると考えることができる
        bool is_8queen = true;  // 8queenが成り立っていたらtrue
        rep(i, 7) {
            for_(j, i+1, 8) {
                int dr = i - j;
                int dc = queen_cs[i] - queen_cs[j];

                if (dr == dc || dr == -dc) is_8queen = false;
            }

            if (!is_8queen) break;
        }

        if (is_8queen) break;
    } while (next_permutation(all(queen_cs)));

    // 結果の表示
    rep(row, 8) {
        rep(col, 8) {
            if (col == queen_cs[row]) cout << "Q";
            else cout << ".";
        }
        cout << endl;
    }
}
