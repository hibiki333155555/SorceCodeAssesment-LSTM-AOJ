#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
template<class T> using V = vector<T>;
using VI = V<int>;
using VL = V<ll>;
using VS = V<string>;
template<class T> using PQ = priority_queue<T, V<T>, greater<T>>;
using graph = V<VI>;
template<class T> using w_graph = V<V<pair<int, T>>>;
#define FOR(i,a,n) for(int i=(a);i<(n);++i)
#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)
#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)
#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define inside(h,w,y,x) (unsigned(y)<h&&unsigned(x)<w)
#ifdef _DEBUG
#define line cout << "-----------------------------\n"
#define stop system("pause")
#endif
constexpr ll INF = 1000000000;
constexpr ll LLINF = 1LL << 61;
constexpr ll mod = 1000000007;
constexpr ll MOD = 998244353;
constexpr ld eps = 1e-10;
constexpr int dy[]{ -1,0,1,0 }, dx[]{ 0,1,0,-1 };
template<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }
template<class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }
inline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }
template<class T> inline istream& operator>>(istream& is, V<T>& v) { for (auto& a : v)is >> a; return is; }
template<class T, class U> inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template<class T> inline V<T> vec(size_t a) { return V<T>(a); }
template<class T> inline V<T> defvec(T def, size_t a) { return V<T>(a, def); }
template<class T, class... Ts> inline auto vec(size_t a, Ts... ts) { return V<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }
template<class T, class... Ts> inline auto defvec(T def, size_t a, Ts... ts) { return V<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }
template<class T> inline void print(const T& a) { cout << a << "\n"; }
template<class T, class... Ts> inline void print(const T& a, const Ts&... ts) { cout << a << " "; print(ts...); }
template<class T> inline void print(const V<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? "\n" : " "); }
template<class T> inline void print(const V<V<T>>& v) { for (auto& a : v)print(a); }
template<class T> inline constexpr const T cumsum(const V<T>& a, int l, int r) { return 0 <= l && l <= r && r < a.size() ? a[r] - (l == 0 ? 0 : a[l - 1]) : 0; }//[l,r]
template<class T> inline constexpr const T min(const V<T>& v) { return *min_element(all(v)); }
template<class T> inline constexpr const T max(const V<T>& v) { return *max_element(all(v)); }

int main() {
    init();

    int n, m; cin >> n >> m;
    w_graph<int> g(n);
    FOR(i, 0, m) {
        int a, b, c; cin >> a >> b >> c;
        --a, --b;
        g[a].emplace_back(b, c);
    }

    set<int> se;
    FOR(bit, 0, 1 << 20) {
        int a = 1;
        FOR(i, 0, 20)if (bit >> i & 1)a = lcm(a, i + 1);
        se.insert(a);
    }

    int Min = INF, Max = -INF;
    int primes[] = { 2,3,5,7,11,13,17,19 };
    for (int LCM : se) {
        VI q, qp;
        int tmp = LCM;
        for (int p : primes)if (tmp % p == 0) {
            int x = 1;
            while (tmp % p == 0) {
                tmp /= p;
                x *= p;
            }
            q.push_back(x);
            qp.push_back(p);
        }
        int s = q.size();

        int ctobit[21] = {};
        eFOR(cost, 1, 20) {
            int tmp = cost;
            FOR(i, 0, s) {
                if (tmp % q[i] == 0) {
                    ctobit[cost] |= (1 << i);
                    tmp /= q[i];
                }
                else {
                    while (tmp % qp[i] == 0)tmp /= qp[i];
                }
            }
            if (tmp > 1)ctobit[cost] = -1;
        }
        auto dp = vec<bool>(1 << s, n);
        dp[0][0] = true;
        queue<pair<int, int>> que;
        que.emplace(0, 0);
        while (!que.empty()) {
            auto [bit, cur] = que.front();
            que.pop();
            for (auto [to, cost] : g[cur]) {
                int nxtbit = bit | ctobit[cost];
                if (nxtbit == -1)continue;
                if (!dp[nxtbit][to]) {
                    dp[nxtbit][to] = true;
                    que.emplace(nxtbit, to);
                }
            }
        }
        if (dp[(1 << s) - 1][n - 1]) {
            chmin(Min, LCM);
            chmax(Max, LCM);
        }
    }
    if (Min == INF)print("IMPOSSIBLE");
    else print(Min, Max);

    return 0;
}
