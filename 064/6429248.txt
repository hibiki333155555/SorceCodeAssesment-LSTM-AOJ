#line 2 "library/KowerKoint/base.hpp"

#ifndef ONLINE_JUDGE
#define _GLIBCXX_DEBUG
#endif

#include <bits/stdc++.h>
using namespace std;

#define REP(i, n) for(int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for(ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()
#define END(...) { print(__VA_ARGS__); return; }

using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using ll = long long;
using VL = vector<ll>;
using VVL = vector<VL>;
using VVVL = vector<VVL>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VS = vector<string>;
using VVS = vector<VS>;
using VVVS = vector<VVS>;
using VC = vector<char>;
using VVC = vector<VC>;
using VVVC = vector<VVC>;
using P = pair<int, int>;
using VP = vector<P>;
using VVP = vector<VP>;
using VVVP = vector<VVP>;
using LP = pair<ll, ll>;
using VLP = vector<LP>;
using VVLP = vector<VLP>;
using VVVLP = vector<VVLP>;

template <typename T>
using PQ = priority_queue<T>;
template <typename T>
using GPQ = priority_queue<T, vector<T>, greater<T>>;

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

void print() { cout << '\n'; }
template<typename T>
void print(const T &t) { cout << t << '\n'; }
template<typename Head, typename... Tail>
void print(const Head &head, const Tail &... tail) {
    cout << head << ' ';
    print(tail...);
}

#ifdef ONLINE_JUDGE
template<typename... Args>
void dbg(const Args &... args) {}
#else
void dbg() { cerr << '\n'; }
template<typename T>
void dbg(const T &t) { cerr << t << '\n'; }
template<typename Head, typename... Tail>
void dbg(const Head &head, const Tail &... tail) {
    cerr << head << ' ';
    dbg(tail...);
}
#endif

template< typename T1, typename T2 >
ostream &operator<<(ostream &os, const pair< T1, T2 >& p) {
    os << p.first << " " << p.second;
    return os;
}

template< typename T1, typename T2 >
istream &operator>>(istream &is, pair< T1, T2 > &p) {
    is >> p.first >> p.second;
    return is;
}

template< typename T >
ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i = 0; i < (int) v.size(); i++) {
        os << v[i] << (i + 1 != (int) v.size() ? " " : "");
    }
    return os;
}

template< typename T >
istream &operator>>(istream &is, vector< T > &v) {
    for(T &in : v) is >> in;
    return is;
}

template< typename T1, typename T2 >
inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

template< typename T1, typename T2 >
inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

template <typename T>
pair<VI, vector<T>> compress(const vector<T> &a) {
    int n = a.size();
    vector<T> x;
    REP(i, n) x.push_back(a[i]);
    sort(ALL(x)); x.erase(unique(ALL(x)), x.end());
    VI res(n);
    REP(i, n) res[i] = lower_bound(ALL(x), a[i]) - x.begin();
    return make_pair(res, x);
}

template <typename T>
pair<vector<T>, vector<T>> factorial(int n) {
    vector<T> res(n+1), rev(n+1);
    res[0] = 1;
    REP(i, n) res[i+1] = res[i] * (i+1);
    rev[n] = 1 / res[n];
    for(int i = n; i > 0; i--) {
        rev[i-1] = rev[i] * i;
    }
    return make_pair(res, rev);
}
#line 2 "Contests/Dummy/HUPC2021-day1/d/main.cpp"

/* #include <atcoder/all> */
/* using namespace atcoder; */
/* #include "KowerKoint/expansion/ac-library/all.hpp" */
#line 1 "library/KowerKoint/internal_operator.hpp"
namespace internal_operator {
    template <typename T>
    T default_add(T a, T b) { return a + b; }
    template <typename T>
    T default_sub(T a, T b) { return a - b; }
    template <typename T>
    T zero() { return T(0); }
    template <typename T>
    T default_div(T a, T b) { return a / b; }
    template <typename T>
    T default_mult(T a, T b) { return a * b; }
    template <typename T>
    T one() { return T(1); }
    template <typename T>
    T default_xor(T a, T b) { return a ^ b; }
    template <typename T>
    T default_and(T a, T b) { return a & b; }
    template <typename T>
    T default_or(T a, T b) { return a | b; }
}

#line 4 "library/KowerKoint/math/matrix.hpp"

template <
    typename T,
    T (*add)(const T, const T)=internal_operator::default_add,
    T (*zero)()=internal_operator::zero,
    T (*mult)(const T, const T)=internal_operator::default_mult,
    T (*one)()=internal_operator::one,
    T (*sub)(const T, const T)=internal_operator::default_sub,
    T (*div)(const T, const T)=internal_operator::default_div
>
struct Matrix {
    int n, m;
    vector<vector<T>> A;

    Matrix() : n(0), m(0), A(vector<vector<T>>(0)) {}
    Matrix(size_t _n, size_t _m) : n(_n), m(_m), A(_n, vector<T>(_m, zero())) {}
    Matrix(vector<vector<T>> _A) : n(_A.size()), m(_A[0].size()), A(_A) {}

    vector<T> &operator[](int i) { return A.at(i); }
    const vector<T> &operator[](int i) const { return A.at(i); }

    static Matrix I(size_t n) {
        Matrix ret(n, n);
        REP(i, n) ret[i][i] = one();
        return ret;
    }

    Matrix &operator+=(const Matrix &B) {
        assert(n == B.n && m == B.m);
        REP(i, n) REP(j, m) A[i][j] = add(A[i][j], B[i][j]);
        return *this;
    }
    Matrix operator+(const Matrix &B) const {
        return (Matrix(*this) += B);
    }

    Matrix &operator-=(const Matrix &B) {
        assert(n == B.n && m == B.m);
        REP(i, n) REP(j, m) A[i][j] = sub(A[i][j], B[i][j]);
        return *this;
    }
    Matrix operator-(const Matrix &B) const {
        return (Matrix(*this) -= B);
    }

    Matrix &operator*=(const Matrix &B) {
        assert(m == B.n);
        vector<vector<T>> res(n, vector<T>(B.m, zero()));
        REP(i, n) REP(j, m) REP(k, B.m) res[i][k] = add(res[i][k], mult(A[i][j], B[j][k]));
        A.swap(res);
        m = B.m;
        return (*this);
    }
    Matrix operator*(const Matrix &B) const {
        return (Matrix(*this) *= B);
    }

    Matrix &operator|=(const Matrix &B) {
        assert(B.n == n);
        REP(i, n) {
            A[i].resize(m+B.m);
            REP(j, B.m) A[i][m+j] = B[i][j];
        }
        m += B.m;
        return (*this);
    }
    Matrix operator|(const Matrix &B) const {
        return (Matrix(*this) |= B);
    }

    Matrix &operator|=(const vector<T> &B) {
        assert(B.size() == n);
        REP(i, n) {
            A[i].push_back(B[i]);
        }
        m++;
        return (*this);
    }
    Matrix operator|(const vector<T> &B) const {
        return (Matrix(*this) |= B);
    }

    Matrix &operator&=(const Matrix &B) {
        assert(B.m == m);
        A.resize(n+B.n);
        REP(i, B.n) {
            A[n+i] = B[i];
        }
        n += B.n;
        return (*this);
    }
    Matrix operator&(const Matrix &B) const {
        return (Matrix(*this) &= B);
    }

    Matrix &operator&=(const vector<T> &B) {
        assert(B.size() == m);
        A.push_back(B);
        n++;
        return (*this);
    }
    Matrix operator&(const vector<T> &B) const {
        return (Matrix(*this) &= B);
    }

    friend istream &operator>>(istream &is, Matrix &mat) {
        REP(i, mat.n) REP(j, mat.m) is >> mat[i][j];
        return is;
    }

    friend ostream &operator<<(ostream &os, Matrix &mat) {
        REP(i, mat.n) {
            REP(j, mat.m) os << mat[i][j] << (j==mat.m-1? '\n' : ' ');
        }
        return os;
    }

    pair<Matrix, T> gaussian_elimination() const {
        Matrix mat(*this);
        T det = one();
        VI columns;
        int i = 0;
        int j = 0;
        while(i < n && j < m) {
            int idx = -1;
            FOR(k, i, n) if(mat[k][j] != zero()) idx = k;
            if(idx == -1) {
                det = zero();
                j++;
                continue;
            }
            if(i != idx) {
                det *= sub(zero(), one());
                swap(mat[i], mat[idx]);
            }
            det *= mat[i][j];
            T scale = mat[i][j];
            REP(l, m) mat[i][l] = div(mat[i][l], scale);
            FOR(k, i+1, n) {
                T scale = mat[k][j];
                REP(l, m) mat[k][l] = sub(mat[k][l], mult(mat[i][l], scale));
            }
            columns.push_back(j);
            i++;
            j++;
        }
        REP(i, columns.size()) {
            int j = columns[i];
            REP(k, i) {
                T scale = mat[k][j];
                FOR(l, j, m) {
                    mat[k][l] = sub(mat[k][l], mult(mat[i][l], scale));
                }
            }
        }
        return make_pair(mat, det);
    }

    void make_basis() {
        *this = gaussian_elimination().first;
        while(n && get_bra(n-1) == vector<T>(m, zero())) pop_bra();
    }

    Matrix inv() const {
        Matrix and_i = A | I(n);
        auto [i_and, det] = and_i.gaussian_elimination();
        assert(det != zero());
        Matrix res(n, n);
        REP(i, n) REP(j, n) res[i][j] = i_and[i][n+i];
        return res;
    }

    vector<T> get_bra(int i) const {
        assert(0 <= i && i < n);
        return A[i];
    }

    vector<T> get_ket(int i) const {
        assert(0 <= i && i < m);
        vector<T> res(n);
        REP(i, n) res[i] = A[i][i];
        return res;
    }

    void pop_bra() {
        assert(n > 0);
        A.pop_back();
        n--;
    }

    void pop_ket() {
        assert(m > 0);
        REP(i, n) A[i].pop_back();
        m--;
    }

    Matrix transpose() const {
        Matrix res(m, n);
        REP(i, n) REP(j, m) res[j][i] = A[i][j];
        return res;
    }

    Matrix operator^=(ll n) {
        if(n < 0) {
            *this = this->inv();
            n = -n;
        }
        Matrix res = Matrix::I(n);
        while(n) {
            if(n & 1) res *= *this;
            *this *= *this;
            n >>= 1LL;
        }
        A.swap(res.A);
        return (*this);
    }
    Matrix operator^(const ll n) const {
        return (Matrix(*this) ^= n);
    }
};

using XorMatrix = Matrix<
    int,
    internal_operator::default_xor<int>,
    internal_operator::zero<int>,
    internal_operator::default_and<int>,
    internal_operator::one<int>,
    internal_operator::default_xor<int>,
    internal_operator::default_and<int>
>;
#line 7 "Contests/Dummy/HUPC2021-day1/d/main.cpp"

void solve(){
    int k; cin >> k;
    VI n(k); cin >> n;
    VVL _a(k);
    REP(i, k) {
        _a[i].resize(n[i]);
        cin >> _a[i];
    }
    vector<XorMatrix> a(k);
    REP(_, k) {
        a[_] = XorMatrix(n[_], 60);
        REP(i, n[_]) REP(j, 60) {
            a[_][i][j] = _a[_][i] >> j & 1LL;
        }
        a[_].make_basis();
    }
    ll ans = 0;
    REP(_, 1 << k) {
        if(_ == 0) {
            continue;
        }
        VI indexes;
        REP(i, k) if(_ >> i & 1) indexes.push_back(i);
        XorMatrix basis = a[indexes[0]];
        FOR(i, 1, indexes.size()) {
            int index = indexes[i];
            int n = a[index].n;
            XorMatrix mat;
            swap(mat, basis);
            basis = XorMatrix(0, 60);
            XorMatrix new_mat(0, 60 + n);
            REP(__, n) {
                VI ai = a[index].get_bra(__);
                int bit_idx = 0;
                REP(j, mat.n) {
                    while(mat[j][bit_idx] == 0) bit_idx++;
                    if(ai[bit_idx]) {
                        REP(l, 60) {
                            ai[l] ^= mat[j][l];
                        }
                    }
                }
                bit_idx = 0;
                VI ai_use(n);
                ai_use[__] = 1;
                REP(j, new_mat.n) {
                    while(new_mat[j][bit_idx] == 0) bit_idx++;
                    if(ai[bit_idx]) {
                        REP(l, 60) {
                            ai[l] ^= new_mat[j][l];
                        }
                        REP(l, n) ai_use[l] ^= new_mat[j][60 + l];
                    }
                }
                if(ai == VI(60)){
                    VI new_basis(60);
                    REP(j, n) {
                        if(ai_use[j]) {
                            REP(l, 60) new_basis[l] ^= a[index][j][l];
                        }
                    }
                    basis &= new_basis;
                }
                else {
                    VI aip(60+n);
                    REP(j, 60) aip[j] = ai[j];
                    REP(j, n) aip[60+j] = ai_use[j];
                    new_mat &= aip;
                    new_mat.make_basis();
                }
            }
            basis.make_basis();
        }
        if(__builtin_popcount(_) % 2) {
            ans += 1LL << basis.n;
        }
        else ans -= 1LL << basis.n;
    }
    print(ans);
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    // Fasterize input/output script
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << fixed << setprecision(100);
    // scanf/printf user should delete this fasterize input/output script

    int t = 1;
    //cin >> t; // comment out if solving multi testcase
    for(int testCase = 1;testCase <= t;++testCase){
        solve();
    }
    return 0;
}

