#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
ll INF = (1LL << 31)-1;
vector<ll> lazy(1<<20+1,INF);
ll LEN = 1 << 19;
vector<ll> seg(2*LEN+1,INF);
void set_value(ll pos,ll val){
  pos += 1 << 19;
  seg[pos] = val;
  while((pos /= 2) > 0){
    seg[pos] = min(seg[2*pos],seg[pos*2+1]);
  }
}
//lazy[k]の値を伝搬させる
void eval(int k){
  if(lazy[k] == INF)return;
  if(k < LEN){
    lazy[k*2] = min<ll>(lazy[k*2],lazy[k]);
    lazy[k*2+1] = min<ll>(lazy[k*2+1],lazy[k]);
  }
  seg[k] = lazy[k];
  lazy[k] = INF;
}
//qlとqrが求める範囲
//slとsrという広い範囲からどんどん小さくしていく
//ql と　qrのあたいに+= LENなどはする必要ない
ll get_min(int ql,int qr,int sl=0,int sr=1<<19,int pos = 1){
  eval(pos);
  //ちっともかぶってない
  if(qr <= sl || sr <= ql)return INF;
  //完全に包まれている
  if(ql <= sl && sr <= qr)return seg[pos];
  ll sm = (sl + sr)/2;
  ll lmin = get_min(ql,qr,sl,sm,pos*2);
  ll rmin = get_min(ql,qr,sm,sr,pos*2+1);
  return min<ll>(lmin,rmin);
}

void update(int a,int b,int x,int l = 0,int r = (1 << 19),int pos = 1){
  //cout << " a" << endl;
  eval(pos);
  if(a <= l&& r <= b){ // 完全にかぶっている
    lazy[pos] = x;
    eval(pos);
  }else if(b <= l || r <= a)return;//全くかぶっていない
  else{//ちょっとかぶっている
    ll sm = (l + r)/2;
    update(a,b,x,l,sm,pos*2);
    update(a,b,x,sm,r,pos*2+1);
    seg[pos] = min<ll>(seg[pos*2],seg[pos*2+1]);
  }
}

int main(){
  ll n,q,com,x,y,z;
  cin >> n >> q;
  for(int i = 0;i < q;i++){
    cin >> com >> x >> y;
    if(com == 0){
      cin >> z;
      update(x,y+1,z);
    }else{
      cout << get_min(x,y+1)<<endl;
    }
  }
  return 0;
}

