#include <bits/stdc++.h>
#define endl '\n'

using namespace std;

const int N = 110;
int pre[N], w[N], n, m, in[N];
int h[N], e[N], ne[N], idx;
bool st[N], vis[N];

void add_edge(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void bfs() {
    queue<int> que;
    memset(st, false, sizeof(st));
    memset(vis, false, sizeof(vis));
    for (int i = 0; i < n; i ++) {
        if (in[i] == -1) que.push(i);
    }
    while (!que.empty()) {
        int v = que.front(); que.pop();
        vis[v] = true;
        for (int i = h[v]; ~i; i = ne[i]) {
            int u = e[i];
            if (-- in[u] == 0) {
                que.push(u);
            }
        }
    }
    for (int i = 0; i < n; i ++) {
        if (!vis[i]) st[i] = true;
    }
}

int fnd(int x, int *pre) {
    return pre[x] < 0 ? x : pre[x] = fnd(pre[x], pre);
}

void unite(int x,int y, int *pre) {
    int rx = fnd(x, pre), ry = fnd(y, pre);
    if (rx != ry) {
        if (pre[x] < pre[y]) {
            pre[x] += pre[y];
            pre[y] = x;
        } else {
            pre[y] += pre[x];
            pre[x] = y;
        }
    }
}

bool check() {
    static int pre[N];
    memset(pre, -1, sizeof(pre));
    for (int i = 0; i < n; i ++) {
        for (int j = h[i]; ~j; j = ne[j]) {
            unite(i, e[j], pre);
        }
    }
    int cnt = 0;
    for (int i = 0; i < n; i ++) {
        if (pre[i] < 0) cnt ++;
    }
    return cnt == 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    while (cin >> n >> m, n || m) {
        int res = 0;
        memset(pre, -1, sizeof(pre));
        memset(h, -1, sizeof(h));
        for (int i = 1; i <= m; i ++) {
            int x, y, z; cin >> x >> y >> z;
            pre[y] = x, w[y] = z, in[x] ++;
            if (w[y] < 0) {
                res += w[y];
            } else add_edge(y, x);
        }
        if (!check()) cout << res << endl;
        else {
            bfs();
            int tmi = 1e9, fmi = 1e9, fsmi = 1e9;
            for (int i = 0; i < n; i ++) {
                if (pre[i] == -1) continue;
                if (st[i]) {
                    tmi = min(tmi, w[i]);
                } else {
                    if (fmi < w[i]) {
                        fsmi = fmi;
                        fmi = w[i];
                    } else fsmi = min(fsmi, w[i]);
                }
            }
            cout << min(fsmi + fmi, tmi) << endl;
        }
    }
    return 0;
}

