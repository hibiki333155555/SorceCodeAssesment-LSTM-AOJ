#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const int INF=1e9;
const long long LINF=1e18;
#define REP(i,n) for(int i=0;i<(n);i++)

template<typename T>
bool chmax(T &a,T b){
  return (a<b&&(a=b,true));
}
template<typename T>
bool chmin(T &a,T b){
  return (a>b&&(a=b,true));
}

struct Line{
  ll a,b;
  ll f(ll x){
    return a*x+b;
  }
};
void debug(const Line&l){
  cerr<<l.a<<"x+"<<l.b<<endl;
}

struct CHT{
  deque<Line> lines;

  void push_front(ll a,ll b){
    while(lines.size()>=2){
      const auto&[a1,b1]=lines[0];
      const auto&[a2,b2]=lines[1];
      if((b1-b)*(a-a2)>(b2-b)*(a-a1))lines.pop_front();
      else break;
    }
    if(lines.size()&&lines[0].a==a){
      if(lines[1].b<=b)return;
      lines.pop_front();
    }
    lines.push_front({a,b});
  }

  void push_back(ll a,ll b){
    while(lines.size()>=2){
      int S=lines.size();
      const auto&[a1,b1]=lines[S-2];
      const auto&[a2,b2]=lines[S-1];
      if((b1-b)*(a-a2)>(b2-b)*(a-a1))lines.pop_back();
      else break;
    }
    if(lines.size()&&lines.back().a==a){
      if(lines.back().b<=b)return;
      lines.pop_front();
    }
    lines.push_back({a,b});
  }

  void pop_back(){
    lines.pop_back();
  }

  inline ll val(int id,int x){
    return lines[id].f(x);
  }
  ll query(int x){
    int l=-1,r=lines.size()-1;
    ll res=min(val(0,x),val(r,x));
    while(r-l>1){
      int mid=(l+r)>>1;
      if(val(mid,x)<val(mid+1,x)){
        res=min(res,val(mid,x));
        r=mid-1;
      }
      else{
        res=min(res,val(mid+1,x));
        l=mid+2;
      }
    }
    return res;
  }
};


struct LiChaoTree {
  int n;
  vector<ll> xs,p,q;
  vector<bool> u;
  int cnt;
  struct rireki{
    int cnt,k;
    ll prep,preq;
    bool preu;
  };
  stack<rireki> sta;

  LiChaoTree(int n0){
    n = 1;
    while(n < n0) n <<= 1;
    cnt=0;
    u.resize(n*2,false);xs.resize(n*2,0);p.resize(n*2,0);q.resize(n*2,2*LINF);
    for(int i=0; i<2*n; ++i) u[i] = false;
    for(int i=0; i<n0; ++i) xs[i] = i;
    for(int i=n0; i<2*n-1; ++i) xs[i] =INF;
  }

  void _add_line(ll a, ll b, int k, int l, int r,int num) {
    while(r-l > 0) {
      int m = (l + r) >> 1;
      if(!u[k]) {
        sta.push(rireki{num,k,p[k],q[k],u[k]});
        p[k] = a; q[k] = b;
        u[k] = true;
        return;
      }

      ll lx = xs[l], mx = xs[m], rx = xs[r-1];
      ll pk = p[k], qk = q[k];
      bool left = (a*lx+b < pk*lx+qk);
      bool mid = (a*mx+b < pk*mx+qk);
      bool right = (a*rx+b < pk*rx+qk);
      if(left && right) {
        sta.push(rireki{num,k,p[k],q[k],u[k]});
        p[k] = a; q[k] = b;
        return;
      }
      if(!left && !right) {
        return;
      }
      if(mid) {
        sta.push(rireki{num,k,p[k],q[k],u[k]});
        swap(p[k], a);
        swap(q[k], b);
      }
      if(left != mid) {
        k = 2*k+1; r = m;
      } else {
        k = 2*k+2; l = m;
      }
    }
  }

  ll _query(int k, ll x) {
    k += n - 1;
    ll s = u[k] ? p[k]*x+q[k] :LINF;
    while(k > 0) {
      k = (k - 1) / 2;
      if(u[k]) {
        ll r = p[k]*x+q[k];
        s = min(s, r);
      }
    }
    return s;
  }

  void add_line(ll a, ll b) {
    _add_line(a, b, 0, 0, n,++cnt);
  }
  
  void undo(){
    int now=cnt--;
    while(sta.size() && sta.top().cnt==now){
      p[sta.top().k]=sta.top().prep;
      q[sta.top().k]=sta.top().preq;
      u[sta.top().k]=sta.top().preu;
      sta.pop();
    }
  }

  ll query(int i) {
    return _query(i,xs[i]);
  }
};

int main(){
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n,K;cin>>n>>K;
  vector<ll> v(n);
  REP(i,n)cin>>v[i];

  map<int,CHT*> B;//B[m]:最大値がmの区間のやつ

  vector<ll> dp(n+1,LINF);//dp[i]:[0,i)をk個に区切った時の最小値
  dp[0]=0;
  REP(k,K){
    //cerr<<"K;"<<k<<endl;
    LiChaoTree A(n+2);
    stack<Line> staA;
    while(B.size()){
      delete B.begin()->second;
      B.erase(B.begin());
    }
    vector<ll> dp2(n+1,LINF);//dp2[i]:[0,i)をk+1個に区切った時の最小値
    
    for(int i=k;i<n;i++){
      if(!B.size()||(B.begin()->first)>v[i]){
        CHT *cht=new CHT();
        (*cht).push_back(-i,dp[i]);
        B[v[i]]=cht;
      }
      else{
        int sz=-1,m;
        for(auto it=B.begin();it!=B.end()&&(it->first)<=v[i];it++)
          if(chmax(sz,(int)(it->second->lines.size())))m=it->first;
        
        stack<Line> sta;
        for(auto it=B.begin();it!=B.end()&&(it->first)<=v[i];){
          const auto&key=it->first;
          if(key==m){
            ++it;
            continue;
          }
          for(const auto&[a,b]:it->second->lines)
            if(key<m)sta.push({a,b});
            else B[m]->push_front(a,b);
          
          delete (it->second);
          it=B.erase(it);
        }

        while(sta.size()){
          auto [a,b]=sta.top();
          B[m]->push_back(a,b);
          sta.pop();
        }

        B[m]->push_back(-i,dp[i]);
        if(m!=v[i]){
          B[v[i]]=B[m];
          B.erase(m);
        }
        //cerr<<"BIN"<<endl;
        //for(auto l:B[v[i]]->lines)debug(l);
      }
      
      while(staA.size() and staA.top().a<=v[i]){
        staA.pop();
        A.undo();
      }
      A.add_line(v[i],B[v[i]]->query(v[i]));
      //cerr<<"ADD:"<<v[i]<<" "<<B[v[i]]->query(v[i])<<endl;
      staA.push(Line{v[i],B[v[i]]->query(v[i])});
      dp2[i+1]=A.query(i+1);
    }
    dp=dp2;
    //for(const auto&p:dp)cerr<<p<<" ";cerr<<endl;
  }
  cout<<dp[n]<<endl;
}



