#include<bits/stdc++.h> 
using namespace std;
typedef long long ll;
#define all(x) (x).begin(),(x).end()
template<typename T1,typename T2> bool chmin(T1 &a,T2 b){if(a<=b)return 0; a=b; return 1;}
template<typename T1,typename T2> bool chmax(T1 &a,T2 b){if(a>=b)return 0; a=b; return 1;}
int dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};
long double eps = 1e-9;
long double pi = acos(-1);

template< typename T > istream &operator>>(istream &is, vector< T > &v) {
	for(T &in : v) is >> in;
	return is;
}

template< typename T > ostream &operator<<(ostream &os, const vector< T > &v) {
	for(int i = 0; i < (int) v.size(); i++) {
		os << v[i] << (i + 1 != (int) v.size() ? " " : "");
	}
	return os;
}

/*
正規版
メモ
norm(P) Pの絶対値の2乗 abs(P)の2乗
abs(P) Pの絶対値
arg(P)の戻り値の範囲は[-π, π]
polar(長さ,角度(ラジアン))でPointができる
int(-2.2+0.5)=-1
*/

// #include <bits/stdc++.h>
// using namespace std;
// template<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}
// template<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}
// template<class T,class U>constexpr bool bitUP(const T n,const U k){return (n>>k)&1;}



////////////////////////////
// マクロや型
////////////////////////////

using DD=long double;

const DD EPS=1e-9;
const DD INF=1e50;
const DD PI=acosl(-1.0);
#define EQ(a,b) (abs( (a) - (b) )<EPS) //a==b
#define LS(a,b) ( (a)+EPS<(b) ) //a<b
#define GR(a,b) ( (a)>(b)+EPS ) //a>b
#define LE(a,b) ( (a)<(b)+EPS ) //a<=b
#define GE(a,b) ( (a)>(b)-EPS ) //a>=b

#define X real()
#define Y imag()


//点
using Point=complex<DD>;
istream &operator>>(istream &is, Point &p) {
  DD x,y;
  is>>x>>y;
  p=Point(x,y);
  return is;
}

//点a→点bの線分
//aとbが等しい時、色々バグるから注意!
struct Segment{
	Point a,b;
	Segment()=default;
	Segment(Point a,Point b) :a(a),b(b){}
	Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}
	Segment(DD r,Point a) :a(a),b(a+polar((DD)1.0,r)){} 
};
using Line=Segment;

//円
struct Circle{
	Point p;
	DD r;
	Circle()=default;
	Circle(Point p,DD r):p(p),r(r){}
};



////////////////////////////
// 基本計算
////////////////////////////

//度→ラジアン
inline DD torad(const DD deg){return deg*PI/180;}
//ラジアン→度
inline DD todeg(const DD rad){return rad*180/PI;}
//内積 |a||b|cosθ
inline DD dot(const Point &a,const Point &b){return (conj(a)*b).X;}
//外積 |a||b|sinθ
inline DD cross(const Point &a,const Point &b){return (conj(a)*b).Y;}
//ベクトルpを反時計回りにtheta(ラジアン)回転
Point rotate(const Point &p,const DD theta){return p*Point(cos(theta),sin(theta));}

//余弦定理 cos(角度abc(ラジアン))を返す
//長さの対応に注意 ab:辺abの長さ
//verify:https://codeforces.com/gym/102056/problem/F
DD cosine_formula(const DD ab,const DD bc,const DD ca){
	return (ab*ab+bc*bc-ca*ca)/(2*ab*bc);
}

inline bool xy_sort(const Point &a,const Point &b){
	if(a.X+EPS<b.X) return true;
	if(EQ(a.X,b.X) && a.Y+EPS<b.Y) return true;
	return false;
}
inline bool yx_sort(const Point &a,const Point &b){
	if(a.Y+EPS<b.Y) return true;
	if(EQ(a.Y,b.Y) && a.X+EPS<b.X) return true;
	return false;
}


//凸包　アンドリューのアルゴリズム
//O(NlogN)
//反時計回りの多角形を返す
//verify:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A
vector<Point> ConvexHull(vector<Point> s, const bool on_edge){
	int j;
	if(on_edge) j=-1;
	else j=1;
	int sz=(int)s.size();
	if(sz<3) return s;
	sort(s.begin(),s.end(),yx_sort);

	int n=0;
	vector<Point> res(2*sz);
	for(int i=0;i<sz;i++){
		while(n>=2 && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){
			n--;
		}
		res[n]=s[i];
		n++;
	}
	int t=n+1;
	for(int i=sz-2;i>=0;i--){
		while(n>=t && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){
			n--;
		}
		res[n]=s[i];
		n++;
	}
	res.resize(n-1);
	return res;
}


signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout << fixed << setprecision(20);

	int n;
	cin>>n;
	vector<Point> p(n);
	for(int i=0;i<n;i++){
		ll h;
		cin>>h;
		p[i] = Point(i+1, h);
	}
	p.push_back(Point(1,0));
	p.push_back(Point(n,0));
	vector<Point> h = ConvexHull(p,0);
	int ans = 0;
	vector<array<ll,2>> v;
	for(int i=0;i<(int)h.size();i++){
		v.push_back({(ll)h[i].real(), (ll)h[i].imag()});
	}
	sort(all(v));
	for(int i=1;i<(int)v.size();i++){
		chmax(ans, v[i][0] - v[i-1][0]);
	}
	cout << ans << endl;

}

