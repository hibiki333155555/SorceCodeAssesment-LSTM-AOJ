#include<bits/stdc++.h>
using namespace std;
typedef complex<double> P;
typedef vector<P> vec;
double eps=1e-8;
double PI=acos(-1);
vec t;
bool eq(double a,double b){return (b-a<eps&&a-b<eps);}
double cos(P a,P b){return real(b*conj(a));}
double sin(P a,P b){return imag(b*conj(a));}
P project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}

P reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}
int ccw(P a,P b,P c){
  b-=a,c-=a,a=c*conj(b);
  if(a.imag()>eps)return 1;//ccw
  if(a.imag()<-eps)return -1;//cw
  if(a.real()<-eps)return 2;//ob
  if(abs(b)+eps<abs(c))return -2;//of
  return 0;//os
}
//segment ab , point c

double dist(P a,P b,P c){
  if(cos(b-a,c-a)<0)return abs(c-a);
  if(cos(a-b,c-b)<0)return abs(c-b);
  return abs(sin(b-a,c-a))/abs(b-a);
}

bool isintersect(P a,P b,P c,P d){
  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));
}
//segment ab , segment cd
P intersect(P a,P b,P c,P d){
  a-=d;b-=d;c-=d;
  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);
}

double dist(P a,P b,P c,P d){
  if(isintersect(a,b,c,d))return 0;
  double ab=min(dist(a,b,c),dist(a,b,d));
  double cd=min(dist(c,d,a),dist(c,d,b));
  return min(ab,cd);
}

double calcArea(vec &t){
  double res=0;
  int n=t.size();
  for(int i=0;i<n;i++)res+=sin(t[i],t[(i+1==n?0:i+1)]);
  return abs(res/2.0);
}

double Arg(P a,P b,P c){
  b-=a,c-=a;
  return arg(c*conj(b));
}

int inPolygon(vec &t,P p){

  int n=t.size();
  double sum=0;
  for(int i=0;i<n;i++){
    P a=t[i],b=t[(i+1==n?0:i+1)];
    if( ccw(a,b,p) == 0 )return 1;
	sum+= Arg(p,a,b);
    //cout<<Arg(p,a,b)<<' '<<sum<<endl;
  }
  if( abs(sum)< eps+2*arg(P(-1,0))  && abs(sum)> -eps+2*arg(P(-1,0)))return 2; else  return 0;
  //if(sum<eps) return 0;else return 2;
}

bool cmp(P x,P y){
	return arg(x-t[0])<arg(y-t[0]);
}

bool cmp1(P x,P y){
	return abs(x-t[0])<abs(y-t[0]);
}

bool cmp2(P x,P y){
	return abs(x-t[0])>abs(y-t[0]);
}
vec convex_hull(vec &t){
	int n=t.size();
	for(int i=1;i<n;i++){
		if(t[i].imag()<t[0].imag() || (t[i].imag()==t[0].imag()) && t[i].real()==t[0].real()) swap(t[i],t[0]);
	}
	sort(t.begin()+1,t.end(),cmp);
	for(int i=1;i<n;i++){
		if(arg(t[i]-t[0]) == arg(t[i+1]-t[0]))continue;
		sort(t.begin()+1,t.begin()+1+i,cmp1);
		break;
	}
	for(int i=n-1;i;i--){
		if(arg(t[i]-t[0]) == arg(t[i-1]-t[0]))continue;
		sort(t.begin()+i,t.end(),cmp2);
		break;
	}
	vec a;
	a.push_back(t[0]); a.push_back(t[1]); a.push_back(t[2]);
	int end=3;
	for(int i=3;i<n;i++){
		while(end>1 && (imag( (t[i]-a[end-1]) * conj(a[end-1]-a[end-2]))<0 || arg( (t[i]-a[end-1]) * conj(a[end-1]-a[end-2]))==arg(P(-1,0))) ) a.pop_back(),end--;
		// tips when the point turn around
		a.push_back(t[i]);
		end++;
	}
	//cout<<a.size()<<endl;
	//for(auto x:a) cout<<x.real()<<' '<<x.imag()<<endl;
	return a;
}
double area(P x,P y,P z){
	x-=z,y-=z;
	return abs(sin(x,y))/2;
}
vec convex_cut(vec a,P x,P y){
	vec t;
	//cout<<a.size()<<endl;
	for(int i=0;i<a.size();i++){
		P x1=a[i],x2=a[(i+1)%a.size()];
		if(ccw(x,y,x1)!=-1){
			t.push_back(x1);
		}
		if(ccw(x,y,x1)*ccw(x,y,x2)==-1){
			t.push_back(intersect(x1,x2,x,y));
		}
	}
	return t;
}
P circumscribed(P a,P b, P c){
	P x1,y1,x2,y2,d;
    x1=P((c.real()+b.real())/2,0); x1=P(x1.real(),(c.imag()+b.imag())/2);
    x2=P((a.real()+c.real())/2,0); x2=P(x2.real(),(a.imag()+c.imag())/2);
    y1=P(b.imag()-c.imag(),0);y1=P(y1.real(),c.real()-b.real());
    y2=P(c.imag()-a.imag(),0);y2=P(y2.real(),a.real()-c.real());
    d=intersect(x1,x1+y1,x2,x2+y2);
    return d;
}
int main(){
  int n;

  double x,y;
  P a,b,c,d;
  cin>>x>>y;
  a=(P(x,y));
  cin>>x>>y;
  b=(P(x,y));
  cin>>x>>y;
  c=(P(x,y));
  double r=abs(a-b)/sin(a-c,b-c)*abs(a-c)*abs(b-c)/2;
  d=circumscribed(a,b,c)+circumscribed(b,c,a);
  cout<<fixed<<setprecision(6)<<d.real()/2<<' '<<d.imag()/2<<endl;
  cout<<fixed<<setprecision(15)<<abs(r)<<endl;
  //cout<<intersect(a,b,c,d)<<endl;
  return 0;
}
