using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _20220129_AOJ
{
	public class Vertex
	{
		public Vertex()
		{
			Children = new Dictionary<char, int>();
			Leaf = false;
			Parent = -1;
			SuffixLink = -1;
			WordID = new List<int>();
			EndWordLink = -1;
		}

		// Links to the child vertexes in the trie:
		// Key: A single character
		// Value: The ID of vertex
		public Dictionary<char, int> Children;

		// Flag that some word from the dictionary ends in this vertex
		public bool Leaf;

		// Link to the parent vertex
		public int Parent;

		// Char which moves us from the parent vertex to the current vertex
		public char ParentChar;

		// Suffix link from current vertex (the equivalent of P[i] from the KMP algorithm)
		public int SuffixLink;

		// Link to the leaf vertex of the maximum-length word we can make from the current prefix
		public int EndWordLink;

		// If the vertex is the leaf, we store the ID of the word
		public List<int> WordID;
	}

	public class Aho
	{
		List<Vertex> Trie;
		List<int> WordsLength;
		int size = 0;
		int root = 0;

		public Aho()
		{
			Trie = new List<Vertex>();
			WordsLength = new List<int>();
			Init();
		}

		private void Init()
		{
			Trie.Add(new Vertex());
			size++;
		}

		public void AddString(String s, int wordID)
		{
			int curVertex = root;
			for (int i = 0; i < s.Length; ++i) // Iterating over the string's characters
			{
				char c = s[i];

				// Checking if a vertex with this edge exists in the trie:
				if (!Trie[curVertex].Children.ContainsKey(c))
				{
					Trie.Add(new Vertex());

					Trie[size].SuffixLink = -1; // If not - add vertex
					Trie[size].Parent = curVertex;
					Trie[size].ParentChar = c;
					Trie[curVertex].Children[c] = size;
					size++;
				}
				curVertex = (int)Trie[curVertex].Children[c]; // Move to the new vertex in the trie
			}
			// Mark the end of the word and store its ID
			Trie[curVertex].Leaf = true;
			Trie[curVertex].WordID.Add(wordID);
			WordsLength.Add(s.Length);
		}

		public void PrepareAho()
		{
			Queue<int> vertexQueue = new Queue<int>();
			vertexQueue.Enqueue(root);
			while (vertexQueue.Count > 0)
			{
				int curVertex = vertexQueue.Dequeue();
				CalcSuffLink(curVertex);

				foreach (char key in Trie[curVertex].Children.Keys)
				{
					vertexQueue.Enqueue((int)Trie[curVertex].Children[key]);
				}
			}
		}

		public void CalcSuffLink(int vertex)
		{
			// Processing root (empty string)
			if (vertex == root)
			{
				Trie[vertex].SuffixLink = root;
				Trie[vertex].EndWordLink = root;
				return;
			}
			// Processing children of the root (one character substrings)
			if (Trie[vertex].Parent == root)
			{
				Trie[vertex].SuffixLink = root;
				if (Trie[vertex].Leaf) Trie[vertex].EndWordLink = vertex;
				else Trie[vertex].EndWordLink = Trie[Trie[vertex].SuffixLink].EndWordLink;
				return;
			}
			// Cases above are degenerate cases as for prefix function calculation; the
			// value is always 0 and links to the root vertex.

			// To calculate the suffix link for the current vertex, we need the suffix
			// link for the parent of the vertex and the character that moved us to the
			// current vertex.
			int curBetterVertex = Trie[Trie[vertex].Parent].SuffixLink;
			char chVertex = Trie[vertex].ParentChar;
			// From this vertex and its substring we will start to look for the maximum
			// prefix for the current vertex and its substring.

			while (true)
			{
				// If there is an edge with the needed char, we update our suffix link
				// and leave the cycle
				if (Trie[curBetterVertex].Children.ContainsKey(chVertex))
				{
					Trie[vertex].SuffixLink = (int)Trie[curBetterVertex].Children[chVertex];
					break;
				}
				// Otherwise, we are jumping by suffix links until we reach the root
				// (equivalent of k == 0 in prefix function calculation) or we find a
				// better prefix for the current substring.
				if (curBetterVertex == root)
				{
					Trie[vertex].SuffixLink = root;
					break;
				}
				curBetterVertex = Trie[curBetterVertex].SuffixLink; // Go back by sufflink
			}
			// When we complete the calculation of the suffix link for the current
			// vertex, we should update the link to the end of the maximum length word
			// that can be produced from the current substring.
			if (Trie[vertex].Leaf) Trie[vertex].EndWordLink = vertex;
			else Trie[vertex].EndWordLink = Trie[Trie[vertex].SuffixLink].EndWordLink;
		}

		public int[] ProcessString(String text)
		{
			// Current state value
			int currentState = root;

			// Targeted result value
			int[] result = Enumerable.Repeat(-1, WordsLength.Count).ToArray();

			for (int j = 0; j < text.Length; j++)
			{
				// Calculating new state in the trie
				while (true)
				{
					// If we have the edge, then use it
					if (Trie[currentState].Children.ContainsKey(text[j]))
					{
						currentState = (int)Trie[currentState].Children[text[j]];
						break;
					}
					// Otherwise, jump by suffix links and try to find the edge with
					// this char

					// If there aren't any possible edges we will eventually ascend to
					// the root, and at this point we stop checking.
					if (currentState == root) break;
					currentState = Trie[currentState].SuffixLink;
				}
				int checkState = currentState;

				// Trying to find all possible words from this prefix
				while (true)
				{
					// Checking all words that we can get from the current prefix
					checkState = Trie[checkState].EndWordLink;

					// If we are in the root vertex, there are no more matches
					if (checkState == root) break;

					// If the algorithm arrived at this row, it means we have found a
					// pattern match. And we can make additional calculations like find
					// the index of the found match in the text. Or check that the found
					// pattern is a separate word and not just, e.g., a substring.
					foreach (var v in Trie[checkState].WordID)
					{
						int indexOfMatch = j + 1 - WordsLength[v];
						if (result[v] < 0)
						{
							result[v] = indexOfMatch;
						}
					}

					// Trying to find all matched patterns of smaller length
					checkState = Trie[checkState].SuffixLink;
				}
			}

			return result;
		}
	}

	class _20220323_AhoCorasick
	{
		static void Main(string[] args)
		{
			string line = Console.ReadLine();
			HashSet<char> charSet = new HashSet<char>();
			foreach (var v in line)
			{
				charSet.Add(v);
			}

			int q = int.Parse(Console.ReadLine());
			string[] p = new string[q];

			for (int i = 0; i < q; i++)
			{
				p[i] = Console.ReadLine();

				HashSet<char> tempSet = new HashSet<char>();
				foreach (var v in p[i])
				{
					tempSet.Add(v);
				}

				if (charSet.Intersect(tempSet).Count() != tempSet.Count())
				{
					p[i] = "@";
				}
			}

			Aho ahoAlg = new Aho();
			for (int i = 0; i < q; i++)
			{
				//p[i] = Console.ReadLine();
				ahoAlg.AddString(Console.ReadLine(), i); // Add all patterns to the structure
			}


			//for (int i = 0; i < p.Length; i++)
			//{
			//	ahoAlg.AddString(p[i], i); // Add all patterns to the structure
			//}
			// Prepare algorithm for work (calculates all links in the structure):
			ahoAlg.PrepareAho();
			
			// Process the text. Output might be different; in my case, it's a count of
			// matches. We could instead return a structure with more detailed information.
			int[] found = ahoAlg.ProcessString(line);

			StringBuilder sb = new StringBuilder();
			foreach (var v in found)
			{
				sb.AppendLine(v >= 0 ? "1" : "0");
			}
			Console.Write(sb);
		}
	}
}

