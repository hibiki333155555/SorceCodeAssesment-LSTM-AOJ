#include <iostream>
#include <cassert>
#include <map>
#include <tuple>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;
using ll = long long;
const int FOOTWAY = 0;
const int ROADWAY = 1;
const ll mod = 1000LL * 1000LL * 1000LL + 9LL;
const int INFI = 1<<28;
const ll INFL = 1LL<<60;

namespace {

    struct Edge {
        int from, to;
        ll cost;
        int type;
        Edge(int from, int to, ll cost, int type) : from(from), to(to), cost(cost), type(type) {}
    };

    int N, P, Q;
    vector<vector<Edge>> G;

    bool input() {
        cin >> N >> P >> Q;
        if (N == 0 && P == 0 && Q == 0) return false;
        G = vector<vector<Edge>>(N);
        for (int i = 0; i < P; i++) {
            // 歩道
            int a, b, c; {
                cin >> a >> b >> c;
                a--; b--;
            }
            G[a].emplace_back(a, b, c, FOOTWAY);
            G[b].emplace_back(b, a, c, FOOTWAY);
        }
        for (int i = 0; i < Q; i++) {
            // 車道
            int d, e, f; {
                cin >> d >> e >> f;
                d--; e--;
            }
            G[d].emplace_back(d, e, f, ROADWAY);
            G[e].emplace_back(e, d, f, ROADWAY);
        }
        return true;
    }

    struct State {
        int v;
        int cost;
        State(int v, int cost) : v(v), cost(cost) {}
    };
    bool operator<(const State& s, const State& t) {
        return s.cost > t.cost;
    }
    int calc_z0() {
        // z0: 0からN-1に移動する際、最小のタクシー乗車回数
        priority_queue<State> PQ;
        vector<int> d(N, INFI);
        d[0] = 0;
        PQ.emplace(0, 0);
        while (not PQ.empty()) {
            auto cur = PQ.top(); PQ.pop();
            for (auto&& e : G[cur.v]) {
                int nv = e.to;
                int ncost = cur.cost + e.type;
                if (d[nv] > ncost) {
                    d[nv] = ncost;
                    PQ.emplace(nv, ncost);
                }
            }
        }
        return d[N-1];
    }

    struct CState {
        int t, v; // t: タクシーに乗車しているかどうか、v: 今どの頂点にいるか
        int z; // z: タクシー乗車回数
        ll cost;
        CState(int t, int v, int z, ll cost) : t(t), v(v), z(z), cost(cost) {}
    };
    bool operator<(const CState& a, const CState& b) {
        return a.cost > b.cost;
    }

    ll calc_cost(int zlim) {
        // z回までタクシー乗車を許容するときの最小コスト
        priority_queue<CState> PQ;
        map<tuple<int, int, int>, ll> d;
        d[make_tuple(0, 0, 0)] = 0;
        PQ.emplace(0, 0, 0, 0LL);
        while (not PQ.empty()) {
            auto cur = PQ.top(); PQ.pop();
            auto t = cur.t, v = cur.v, z = cur.z;
            if (t == 0) {
                for (auto&& e : G[cur.v]) {
                    int nt = e.type; // e.typeがROADWAY(1)なら1, FOOTWAY(0)なら0
                    int nv = e.to;
                    int nz = z + nt;
                    if (nz > zlim) continue;
                    ll ncost = cur.cost + e.cost;
                    auto nstate = make_tuple(nt, nv, nz);
                    if (d.count(nstate) == 0 || d[nstate] > ncost) {
                        PQ.emplace(nt, nv, nz, ncost);
                        d[nstate] = ncost;
                    }
                }
            } else if (t == 1) {
                for (auto&& e : G[cur.v]) {
                    int nt = e.type; // e.typeがROADWAY(1)なら1, FOOTWAY(0)なら0
                    int nv = e.to;
                    int nz = z;
                    ll ncost = cur.cost + e.cost;
                    auto nstate = make_tuple(nt, nv, nz);
                    if (d.count(nstate) == 0 || d[nstate] > ncost) {
                        PQ.emplace(nt, nv, nz, ncost);
                        d[nstate] = ncost;
                    }
                }
            } else { assert(false); }
        }

        ll ans = INFL;
        for (int t = 0; t <= 1; t++) {
            auto s = make_tuple(t, N-1, zlim);
            if (d.count(s) == 0) continue;
            ans = min(ans, d[s]);
        }
        return ans;
    }

    ll cost_waiting_taxi(int z) {
        ll x = 1LL;
        ll ans = 0LL;
        for (int i = 0; i < z; i++) {
            ans = ans + x;
            x = x * 2LL;
        }
        return ans;
    }
    ll cost_waiting_taxi_mod(int z) {
        ll x = 1LL;
        ll ans = 0LL;
        for (int i = 0; i < z; i++) {
            ans = (ans + x) % mod;
            x = (x * 2LL) % mod;
        }
        return ans;
    }

    void solve() {
        int z0 = calc_z0();
        if (z0 == INFI) {
            cout << -1 << endl;
            return;
        }
        ll ans = INFL;
        int k = 40;
        if (z0 > k) {
            ans = (calc_cost(z0) + cost_waiting_taxi_mod(z0)) % mod;
        } else {
            for (int z = z0; z <= k; z++) {
                ans = min(ans, calc_cost(z) + cost_waiting_taxi(z));
            }
        }
        cout << ans % mod << endl;
    }

}

int main() {
    while (input()) {
        solve();
    }
}

