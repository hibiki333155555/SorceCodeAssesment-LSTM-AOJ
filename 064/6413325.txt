#include<iostream>
#include<vector>
#include<set>
using namespace std;

static const int N = 100000;
static const int NTL = -1;
static const int white = 0;
static const int black = 1;

/*用来存储各个结点在深度优先搜索中的顺序*/
int prenum[N] = {};

/*用来存储各个点在深度优先搜索中按照搜索顺序的父结点*/
int parent[N] = {};

/*用来记录该结点能回到的最靠近起点的结点（访问顺序层面）的访问顺序，如果小于父亲结点的prenum*/
/*则有回边，若就是父亲结点则无回边*/
int lowest[N] = {};

/*距离图中各个节点的访问状态*/
int colour[N] = {};

/*图的邻接矩阵*/
vector<int> Graph[N];

/*图的访问顺序*/
int nt = 1;

int mini(int a, int b)
{
	return a > b ? b : a;
}

/*利用深度优先搜索计算lowest*/
void DfsPoint(int u, int paren)
{
	prenum[u] = lowest[u] = nt++;
	parent[u] = paren;
	colour[u] = black;
	int next;
	for (int i = 0; i < Graph[u].size(); i++)
	{
		next = Graph[u][i];
		if (colour[next] != black)
		{
			DfsPoint(next, u);
			/*结点搜索完毕之后立即进行的处理*/
			lowest[u] = min(lowest[u], lowest[next]);
		}
		/*没访问过又不是父结点才可能是回边*/
		else if (next != paren)
		{
			/*和我相连的，已经被访问过的点，一定是我这面子树的上的更高的结点，不可能是另一颗树上的，所以找回去一定是一条回边*/
			lowest[u] = min(lowest[u], prenum[next]);
		}
	}
}

void count(int n)
{
	set<int> ap;
	int mp = 0;
	for (int i = 1; i < n; i++)
	{
		int p = parent[i];
		if (p == 0) mp++;
		else if (prenum[p] <= lowest[i])ap.insert(p);
	}
	if (mp > 1)ap.insert(0);
	for (set<int>::iterator it = ap.begin(); it != ap.end(); it++)
		cout << *it << endl;
}

int main()
{
	int n, e;
	cin >> n >> e;
	for (int i = 0; i < n; i++)
		parent[i] = NTL;
	for (int i = 0; i < e; i++)
	{
		/*将无向图的边添加到邻接矩阵中*/
		int s, t;
		cin >> s >> t;
		Graph[s].push_back(t);
		Graph[t].push_back(s);
	}

	DfsPoint(0, NTL);
	count(n);
	return 0;
}
