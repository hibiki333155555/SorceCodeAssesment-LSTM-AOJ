#include <bits/stdc++.h>

using namespace std;
using ll = long long;

constexpr ll MAX_N = 1000000;

map<ll, ll> memo;
map<ll, ll> odd_memo;

vector<ll> tetra_num_list;
vector<ll> odd_tetra_num_list;

ll dfs(ll num) {
   if (memo.count(num)) {
      return memo[num];
   }

   int min_count = MAX_N;

   for (const auto v : tetra_num_list) {
      if (v > num) {
         break;
      }

      int count1 = 1;
      int count2 = dfs(num - v);

      if (count1 + count2 < min_count) {
         min_count = count1 + count2;
      }
   }

   memo.emplace(num, min_count);
   return min_count;
}

ll odd_dfs(ll num) {
   if (odd_memo.count(num)) {
      return odd_memo[num];
   }

   int min_count = MAX_N;

   for (const auto v : odd_tetra_num_list) {
      if (v > num) {
         break;
      }
      int count1 = 1;
      int count2 = odd_dfs(num - v);

      if (count1 + count2 < min_count) {
         min_count = count1 + count2;
      }
   }

   odd_memo.emplace(num, min_count);
   return min_count;
}

int main() {
   cout << fixed << setprecision(15);

   int i = 0;

   while (true) {
      i++;

      ll tetra_num = i * (i + 1) * (i + 2) / 6;

      if (tetra_num > MAX_N) {
         break;
      }

      tetra_num_list.push_back(tetra_num);
      memo.emplace(tetra_num, 1);

      if (tetra_num % 2 == 1) {
         odd_tetra_num_list.push_back(tetra_num);
         odd_memo.emplace(tetra_num, 1);
      }
   }

   while (true) {
      ll n;
      cin >> n;

      if (n == 0) {
         break;
      }

      cout << dfs(n) << " " << odd_dfs(n) << endl;
   }

   return 0;
}

