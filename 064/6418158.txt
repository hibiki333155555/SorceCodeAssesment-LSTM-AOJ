use std::collections::BTreeMap;

/// https://github.com/hatoo/competitive-rust-snippets
#[allow(unused_imports)]
use std::cmp::{max, min, Ordering, Reverse};
#[allow(unused_imports)]
use std::collections::{BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
#[allow(unused_imports)]
use std::io::{stdin, stdout, BufWriter, Write};
#[allow(unused_imports)]
use std::iter::FromIterator;
#[allow(unused_macros)]
macro_rules ! input {(source = $ s : expr , $ ($ r : tt ) * ) => {let mut iter = $ s . split_whitespace () ; let mut next = || {iter . next () . unwrap () } ; input_inner ! {next , $ ($ r ) * } } ; ($ ($ r : tt ) * ) => {let stdin = std :: io :: stdin () ; let mut bytes = std :: io :: Read :: bytes (std :: io :: BufReader :: new (stdin . lock () ) ) ; let mut next = move || -> String {bytes . by_ref () . map (| r | r . unwrap () as char ) . skip_while (| c | c . is_whitespace () ) . take_while (| c |! c . is_whitespace () ) . collect () } ; input_inner ! {next , $ ($ r ) * } } ; }
#[allow(unused_macros)]
macro_rules ! input_inner {($ next : expr ) => {} ; ($ next : expr , ) => {} ; ($ next : expr , $ var : ident : $ t : tt $ ($ r : tt ) * ) => {let $ var = read_value ! ($ next , $ t ) ; input_inner ! {$ next $ ($ r ) * } } ; }
#[allow(unused_macros)]
macro_rules ! read_value {($ next : expr , ($ ($ t : tt ) ,* ) ) => {($ (read_value ! ($ next , $ t ) ) ,* ) } ; ($ next : expr , [$ t : tt ; $ len : expr ] ) => {(0 ..$ len ) . map (| _ | read_value ! ($ next , $ t ) ) . collect ::< Vec < _ >> () } ; ($ next : expr , chars ) => {read_value ! ($ next , String ) . chars () . collect ::< Vec < char >> () } ; ($ next : expr , usize1 ) => {read_value ! ($ next , usize ) - 1 } ; ($ next : expr , $ t : ty ) => {$ next () . parse ::<$ t > () . expect ("Parse error" ) } ; }

mod complex {
    use std::ops::{Add, Div, Mul, MulAssign, Sub};

    #[derive(Copy, Clone, PartialEq, Debug)]
    pub struct MyComplex {
        real: f64,
        imag: f64,
    }

    impl MyComplex {
        pub fn new(real: f64, imag: f64) -> Self {
            Self { real, imag }
        }

        pub fn from_polar(module: f64, arg: f64) -> Self {
            Self {
                real: module * arg.cos(),
                imag: module * arg.sin(),
            }
        }

        pub fn real(&self) -> f64 {
            self.real
        }

        pub fn imag(&self) -> f64 {
            self.imag
        }

        pub fn module(&self) -> f64 {
            (self.real * self.real + self.imag * self.imag).sqrt()
        }

        pub fn arg(&self) -> f64 {
            use std::f64::consts::PI;
            if self.real == 0.0 {
                if self.imag.is_sign_negative() {
                    -PI
                } else {
                    PI
                }
            } else {
                (self.imag / self.real).atan()
            }
        }

        pub fn conj(&self) -> Self {
            Self {
                real: self.real,
                imag: -self.imag,
            }
        }
    }

    impl Default for MyComplex {
        fn default() -> MyComplex {
            Self {
                real: 0.0,
                imag: 0.0,
            }
        }
    }

    impl std::fmt::Display for MyComplex {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let sign = if self.imag.is_sign_negative() {
                "-"
            } else {
                "+"
            };
            write!(f, "{:.5}{}{:.5}i", self.real, sign, self.imag.abs())
        }
    }

    impl Add for MyComplex {
        type Output = Self;
        fn add(self, other: Self) -> Self {
            Self {
                real: self.real + other.real,
                imag: self.imag + other.imag,
            }
        }
    }

    impl Sub for MyComplex {
        type Output = Self;
        fn sub(self, other: Self) -> Self {
            Self {
                real: self.real - other.real,
                imag: self.imag - other.imag,
            }
        }
    }

    impl Mul for MyComplex {
        type Output = Self;
        fn mul(self, other: Self) -> Self {
            Self {
                real: self.real * other.real - self.imag * other.imag,
                imag: self.real * other.imag + self.imag * other.real,
            }
        }
    }

    impl MulAssign for MyComplex {
        fn mul_assign(&mut self, rhs: Self) {
            *self = self.mul(rhs);
        }
    }

    impl Div for MyComplex {
        type Output = Self;
        fn div(self, other: Self) -> Self {
            let r2 = self.real * self.real + other.imag * other.imag;
            assert!(r2 > 0.0);
            Self {
                real: (self.real * other.real + self.imag * other.imag) / r2,
                imag: (self.imag * other.real - self.real * other.imag) / r2,
            }
        }
    }

    impl Div<f64> for MyComplex {
        type Output = Self;
        fn div(self, other: f64) -> Self {
            Self {
                real: self.real / other,
                imag: self.imag / other,
            }
        }
    }

    impl From<f64> for MyComplex {
        fn from(x: f64) -> Self {
            Self { real: x, imag: 0.0 }
        }
    }
}

mod fft_cooley_tukey {
    use super::complex::MyComplex;

    pub fn fft(x: &[MyComplex]) -> Vec<MyComplex> {
        let mut x = x.to_vec();
        let n = x.len().next_power_of_two();
        x.resize_with(n, Default::default);
        _fft(&mut x);
        x
    }

    fn _fft(x: &mut [MyComplex]) {
        use std::f64::consts::PI;
        let n = x.len();
        if n <= 1 {
            return;
        }
        let mut even = Vec::new();
        let mut odd = Vec::new();
        for (i, &ix) in x.iter().enumerate() {
            if i % 2 == 0 {
                even.push(ix);
            } else {
                odd.push(ix);
            }
        }
        _fft(&mut even);
        _fft(&mut odd);
        let circle = 2.0 * PI / (n as f64);
        for k in 0..n {
            let theta = circle * (k as f64);
            let t = MyComplex::from_polar(1.0, theta);
            x[k] = even[k % (n / 2)] + odd[k % (n / 2)] * t;
        }
    }

    pub fn ifft(x: &[MyComplex]) -> Vec<MyComplex> {
        let mut x = x.to_vec();
        let n = x.len().next_power_of_two();
        x.resize_with(n, Default::default);

        let mut x = x.into_iter().map(|ix| ix.conj()).collect::<Vec<_>>();
        _fft(&mut x);
        let x = x
            .into_iter()
            .map(|ix| ix.conj() / (n as f64))
            .collect::<Vec<_>>();
        x
    }

    pub fn convolution(a: &[f64], b: &[f64]) -> Vec<f64> {
        let mut a = a
            .into_iter()
            .map(|&v| MyComplex::new(v, 0.0))
            .collect::<Vec<_>>();
        let mut b = b
            .into_iter()
            .map(|&v| MyComplex::new(v, 0.0))
            .collect::<Vec<_>>();
        let n = a.len() + b.len() - 1;
        a.resize_with(n, Default::default);
        b.resize_with(n, Default::default);
        let mut a = fft(&a);
        let b = fft(&b);
        for (i, ia) in a.iter_mut().enumerate() {
            *ia *= b[i];
        }
        let a = ifft(&a);
        let ret = a[0..n].iter().map(|c| c.real()).collect();
        ret
    }
}

use std::ops::{Add, Div, Mul, Rem, Sub};
#[derive(Debug, Eq, PartialEq, Clone)]
struct BigInt {
    digits: Vec<i32>,
    is_minus: bool,
}

impl BigInt {
    pub fn new(s: &str) -> Self {
        let s: Vec<char> = s.chars().collect();
        let (mut digits, mut is_minus) = if s[0] == '-' {
            (
                s[1..]
                    .iter()
                    .rev()
                    .map(|c| c.to_digit(10).unwrap() as i32)
                    .collect(),
                true,
            )
        } else {
            (
                s.iter()
                    .rev()
                    .map(|c| c.to_digit(10).unwrap() as i32)
                    .collect(),
                false,
            )
        };
        BigInt::_remove_leading_zero(&mut digits);
        // zero case
        if digits.len() == 1 && digits[0] == 0 {
            is_minus = false;
        }
        Self { digits, is_minus }
    }

    fn _remove_leading_zero(digits: &mut Vec<i32>) {
        while digits.len() > 1 && digits.last().unwrap() == &0 {
            digits.pop();
        }
    }

    pub fn to_string(&self) -> String {
        let mut vc = Vec::new();
        if self.is_minus {
            vc.push('-');
        }
        for &d in self.digits.iter().rev() {
            vc.push(std::char::from_digit(d as u32, 10).unwrap());
        }
        vc.iter().collect()
    }

    fn _carry_and_fix(digits: &mut Vec<i32>) {
        let n = digits.len();
        for i in 0..n - 1 {
            if digits[i] > 9 {
                let k = digits[i] / 10;
                digits[i] -= k * 10;
                digits[i + 1] += k;
            }
            if digits[i] < 0 {
                let k = (-digits[i] - 1) / 10 + 1;
                digits[i] += k * 10;
                digits[i + 1] -= k;
            }
        }
        let mut k = *digits.last().unwrap();
        while k > 9 {
            k /= 10;
            *digits.last_mut().unwrap() -= k * 10;
            digits.push(k);
        }
        BigInt::_remove_leading_zero(digits);
    }

    fn _cmp(self_digits: &[i32], other_digits: &[i32]) -> std::cmp::Ordering {
        let n_self = self_digits.len();
        let n_other = other_digits.len();
        if n_self == n_other {
            for i in (0..n_self).rev() {
                if self_digits[i] != other_digits[i] {
                    return self_digits[i].cmp(&other_digits[i]);
                }
            }
            Ordering::Equal
        } else {
            n_self.cmp(&n_other)
        }
    }

    fn _swap_less_case(self_digits: &mut Vec<i32>, other_digits: &mut Vec<i32>) -> bool {
        if BigInt::_cmp(&self_digits, &other_digits) == Ordering::Less {
            std::mem::swap(self_digits, other_digits);
            return true;
        }
        false
    }

    fn _add(self_digits: &[i32], other_digits: &[i32]) -> Vec<i32> {
        let n = std::cmp::max(self_digits.len(), other_digits.len());
        let mut digits = vec![0i32; n];
        for (i, &d) in self_digits.iter().enumerate() {
            digits[i] += d;
        }
        for (i, &d) in other_digits.iter().enumerate() {
            digits[i] += d;
        }
        BigInt::_carry_and_fix(&mut digits);
        digits
    }
    // a-b
    fn _sub(self_digits: &[i32], other_digits: &[i32]) -> Vec<i32> {
        let mut digits = self_digits.to_vec();
        for (i, &d) in other_digits.iter().enumerate() {
            digits[i] -= d;
        }
        BigInt::_carry_and_fix(&mut digits);
        digits
    }

    fn _mul(self_digits: &[i32], other_digits: &[i32]) -> Vec<i32> {
        let mut digits = vec![0i32; self_digits.len() + other_digits.len()];
        for (i, &di) in self_digits.iter().enumerate() {
            for (j, &dj) in other_digits.iter().enumerate() {
                digits[i + j] += di * dj;
            }
        }
        BigInt::_carry_and_fix(&mut digits);
        digits
    }

    fn _mul2(self_digits: &[i32], other_digits: &[i32]) -> Vec<i32> {
        use fft_cooley_tukey::convolution;
        let a = self_digits.iter().map(|&x| x as f64).collect::<Vec<_>>();
        let b = other_digits.iter().map(|&x| x as f64).collect::<Vec<_>>();
        let c = convolution(&a, &b);
        let mut digits = c.into_iter().map(|x| x.round() as i32).collect::<Vec<_>>();
        BigInt::_carry_and_fix(&mut digits);
        digits
    }

    fn _div(lhs_digits: &[i32], rhs_digits: &[i32]) -> Vec<i32> {
        let n_lhs = lhs_digits.len();
        let n_rhs = rhs_digits.len();
        if n_lhs < n_rhs {
            return vec![0];
        }
        let mut d = n_lhs - n_rhs;
        if BigInt::_cmp(&lhs_digits[d..n_lhs], &rhs_digits) != Ordering::Less {
            d += 1;
        }
        if d == 0 {
            return vec![0];
        }
        let mut remain = lhs_digits[(d - 1)..n_lhs].to_vec();
        let mut digits = vec![9i32; d];
        for i in (0..d).rev() {
            for j in 1..=9 {
                let x = BigInt::_mul(&rhs_digits, &vec![j]);
                if BigInt::_cmp(&x, &remain) == Ordering::Greater {
                    digits[i] = j - 1;
                    break;
                }
            }
            let x_result = BigInt::_mul(&rhs_digits, &vec![digits[i]]);
            remain = BigInt::_sub(&remain, &x_result);
            if i >= 1 {
                if remain.len() == 1 && remain[0] == 0 {
                    remain[0] = lhs_digits[i - 1];
                } else {
                    remain.insert(0, lhs_digits[i - 1]);
                }
            }
        }
        digits
    }
}

impl Add for BigInt {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        let (digits, mut is_minus) = if self.is_minus ^ other.is_minus {
            // a+(-b) or (-a)+b
            if BigInt::_cmp(&self.digits, &other.digits) == Ordering::Greater {
                let digits = BigInt::_sub(&self.digits, &other.digits);
                (digits, self.is_minus)
            } else {
                let digits = BigInt::_sub(&other.digits, &self.digits);
                (digits, other.is_minus)
            }
        } else {
            // a+b or (-a)+(-b)
            let digits = BigInt::_add(&self.digits, &other.digits);
            (digits, self.is_minus)
        };
        // zero case
        if digits.len() == 1 && digits[0] == 0 {
            is_minus = false;
        }
        Self { digits, is_minus }
    }
}

impl Sub for BigInt {
    type Output = Self;
    fn sub(self, other: Self) -> Self {
        let (digits, mut is_minus) = if self.is_minus ^ other.is_minus {
            // a-(-b) or (-a)-b
            let digits = BigInt::_add(&self.digits, &other.digits);
            (digits, self.is_minus)
        } else {
            // a-b or (-a)-(-b)
            if BigInt::_cmp(&self.digits, &other.digits) == Ordering::Greater {
                let digits = BigInt::_sub(&self.digits, &other.digits);
                (digits, self.is_minus)
            } else {
                let digits = BigInt::_sub(&other.digits, &self.digits);
                (digits, !self.is_minus)
            }
        };
        // zero case
        if digits.len() == 1 && digits[0] == 0 {
            is_minus = false;
        }
        Self { digits, is_minus }
    }
}

impl Mul for BigInt {
    type Output = Self;
    fn mul(self, other: Self) -> Self {
        let digits = BigInt::_mul2(&self.digits, &other.digits);
        let mut is_minus = self.is_minus ^ other.is_minus;
        // zero case
        if digits.len() == 1 && digits[0] == 0 {
            is_minus = false;
        }
        Self { digits, is_minus }
    }
}

impl Div for BigInt {
    type Output = Self;
    fn div(self, other: Self) -> Self {
        let digits = BigInt::_div(&self.digits, &other.digits);
        let mut is_minus = self.is_minus ^ other.is_minus;
        // zero case
        if digits.len() == 1 && digits[0] == 0 {
            is_minus = false;
        }
        Self { digits, is_minus }
    }
}

impl Rem for BigInt {
    type Output = Self;
    fn rem(self, modulus: Self) -> Self {
        let d = self.clone() / modulus.clone();
        let ret = self - d * modulus;
        ret
    }
}

impl PartialOrd for BigInt {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for BigInt {
    fn cmp(&self, other: &Self) -> Ordering {
        if self.is_minus ^ other.is_minus {
            if self.is_minus {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        } else {
            let ord = BigInt::_cmp(&self.digits, &other.digits);
            if self.is_minus {
                if ord == Ordering::Greater {
                    Ordering::Less
                } else if ord == Ordering::Less {
                    Ordering::Greater
                } else {
                    Ordering::Equal
                }
            } else {
                ord
            }
        }
    }
}
use mod_int::ModInt;

const MOD: i64 = 998244353;
fn main() {
    let (r, w) = (std::io::stdin(), std::io::stdout());
    let mut sc = IO::new(r.lock(), w.lock());

    loop {
        let n: usize = sc.read();
        let m: usize = sc.read();
        if n == 0 && m == 0 {
            break;
        }

        let mut s = Evaluator {
            memory: BTreeMap::new(),
            print: vec![],
        };
        for _ in 0..n {
            let line = sc.read::<String>();
            let statement = parse_line(&line);
            s.eval(&statement);
        }

        let mut t = Evaluator {
            memory: BTreeMap::new(),
            print: vec![],
        };
        for _ in 0..m {
            let line = sc.read::<String>();
            let statement = parse_line(&line);
            t.eval(&statement);
        }
    }
}

struct Evaluator {
    memory: BTreeMap<String, i64>,
    print: Vec<(i64, BigInt)>,
}

impl Evaluator {
    fn eval(&mut self, statement: &Statement) {
        match statement {
            Statement::Declare { name } => {
                self.memory.insert(name.to_string(), 0);
            }
            Statement::Assign(assign) => {
                self.eval_assign(assign, 1);
            }
            Statement::Print(print) => {
                self.eval_print(print, BigInt::new("1"));
            }
            Statement::For {
                for_elements,
                inner,
            } => {
                self.eval_for(for_elements, inner);
            }
        }
    }

    fn eval_expression(&self, expr: &Expression) -> i64 {
        let mut sum = 0;
        for term in expr.terms.iter() {
            let prefix = term.0;
            match &term.1 {
                Term::Value(var) => {
                    let value = self.memory.get(var).unwrap();
                    sum += prefix * (*value);
                    sum %= MOD;
                }
                Term::Number(v) => {
                    sum += prefix * (*v);
                    sum %= MOD;
                }
            }
        }
        sum
    }

    fn eval_assign(&mut self, assign: &Assignment, count: i64) {
        if count == 0 {
            return;
        }
        let mut x = 0;
        let mut other_terms = vec![];
        for term in assign.expr.terms.iter() {
            if let Term::Value(s) = &term.1 {
                if &assign.name == s {
                    x += term.0;
                } else {
                    other_terms.push(term.clone());
                }
            } else {
                other_terms.push(term.clone());
            }
        }
        let expr = Expression { terms: other_terms };
        let y = self.eval_expression(&expr);

        let c = *self.memory.get(&assign.name).unwrap();
        if x == 1 {
            let y = (y + MOD) % MOD;
            let add = (y * count) % MOD;
            let new_value = (c + add) % MOD;
            self.memory.insert(assign.name.to_string(), new_value);
            return;
        }

        // a <- x * a + y

        let xn = ModInt::from(x).pow(count);
        let an = xn * c * y * (xn - 1i64) / (x - 1);

        self.memory.insert(assign.name.to_string(), an.value());
    }

    fn eval_print(&mut self, print: &Print, counts: BigInt) {
        let result = self.eval_expression(&print.expr);
        self.print.push((result, counts));
    }

    fn eval_for(&mut self, loops: &[Expression], inner: &ForInner) {
        let mut counts = BigInt::new("1");
        let mut loop_count = 1;
        for expr in loops {
            let result = self.eval_expression(expr);
            loop_count *= result;
            loop_count %= MOD;
            counts = counts * BigInt::new(result.to_string().as_str());
        }

        match inner {
            ForInner::Assign(assign) => {
                self.eval_assign(assign, loop_count);
            }
            ForInner::Print(print) => {
                self.eval_print(print, counts);
            }
        }
    }
}

#[derive(Debug)]
enum Statement {
    Declare {
        name: String,
    },
    Assign(Assignment),
    Print(Print),
    For {
        for_elements: Vec<Expression>,
        inner: ForInner,
    },
}

#[derive(Debug)]
enum ForInner {
    Assign(Assignment),
    Print(Print),
}

#[derive(Debug)]
struct Assignment {
    name: String,
    expr: Expression,
}

#[derive(Debug)]
struct Print {
    expr: Expression,
}

#[derive(Debug, Clone)]
struct Expression {
    terms: Vec<(i64, Term)>,
}

#[derive(Debug, Clone)]
enum Term {
    Value(String),
    Number(i64),
}

fn parse_line(line: &str) -> Statement {
    if line.starts_with("for(") {
        // for
        let (mut elements, inner) = parse_for(line);
        elements.reverse();
        Statement::For {
            for_elements: elements,
            inner,
        }
    } else if line.starts_with("print(") {
        // print
        Statement::Print(parse_print(line))
    } else if line.contains("<-") {
        // assign
        Statement::Assign(parse_assignment(line))
    } else {
        // declare
        Statement::Declare {
            name: line.to_string(),
        }
    }
}

fn parse_print(line: &str) -> Print {
    let l = line.len();
    let expression = &line[6..(l - 1)];
    let expression = parse_expression(expression);
    Print { expr: expression }
}

fn parse_for(line: &str) -> (Vec<Expression>, ForInner) {
    if line.starts_with("for(") {
        let right = line.find(')').unwrap();
        let expression = &line[4..right];
        let expression = parse_expression(expression);

        let rest = &line[(right + 1)..];
        let (mut elements, inner) = parse_for(rest);
        elements.push(expression);
        (elements, inner)
    } else {
        let inner = parse_for_inner(line);
        (vec![], inner)
    }
}

fn parse_assignment(line: &str) -> Assignment {
    let i = line.find("<-").unwrap();
    let value_name = &line[..i];
    let expression = &line[(i + 2)..];

    Assignment {
        name: value_name.to_string(),
        expr: parse_expression(expression),
    }
}

fn parse_for_inner(for_inner: &str) -> ForInner {
    if for_inner.starts_with("print(") {
        ForInner::Print(parse_print(for_inner))
    } else {
        ForInner::Assign(parse_assignment(for_inner))
    }
}

fn parse_expression(expression: &str) -> Expression {
    let mut q = expression.bytes().collect::<Vec<_>>();
    let head = q[0];
    q.reverse();
    if head != b'-' {
        q.push(b'+');
    }
    q.reverse();

    let mut terms = vec![];
    while !q.is_empty() {
        let mut buf = vec![];
        let mut prefix = 1;
        while let Some(c) = q.pop() {
            if c == b'+' || c == b'-' {
                if c == b'-' {
                    prefix = -1;
                }
                break;
            } else {
                buf.push(c);
            }
        }
        buf.reverse();

        let term = if buf.len() == 1 && buf[0].is_ascii_alphabetic() {
            Term::Value(String::from_utf8(buf).unwrap())
        } else {
            let num = parse_number(&buf);
            Term::Number(num)
        };

        terms.push((prefix, term));
    }
    Expression { terms }
}

fn parse_number(buf: &[u8]) -> i64 {
    let mut x = ModInt::from(0);
    for &b in buf {
        x *= 10;
        x += (b - b'0') as i64;
    }
    x.value()
}

pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);

impl<R: std::io::Read, W: std::io::Write> IO<R, W> {
    pub fn new(r: R, w: W) -> Self {
        Self(r, std::io::BufWriter::new(w))
    }
    pub fn write<S: ToString>(&mut self, s: S) {
        use std::io::Write;
        self.1.write_all(s.to_string().as_bytes()).unwrap();
    }
    pub fn read<T: std::str::FromStr>(&mut self) -> T {
        use std::io::Read;
        let buf = self
            .0
            .by_ref()
            .bytes()
            .map(|b| b.unwrap())
            .skip_while(|&b| b == b' ' || b == b'\n' || b == b'\r' || b == b'\t')
            .take_while(|&b| b != b' ' && b != b'\n' && b != b'\r' && b != b'\t')
            .collect::<Vec<_>>();
        unsafe { std::str::from_utf8_unchecked(&buf) }
            .parse()
            .ok()
            .expect("Parse error.")
    }
    pub fn usize0(&mut self) -> usize {
        self.read::<usize>() - 1
    }
    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {
        (0..n).map(|_| self.read()).collect()
    }
    pub fn chars(&mut self) -> Vec<char> {
        self.read::<String>().chars().collect()
    }
}
pub mod mod_int {
    type ModInternalNum = i64;
    thread_local!(
        static MOD: std::cell::RefCell<ModInternalNum> = std::cell::RefCell::new(0);
    );

    pub fn set_mod_int<T: ToInternalNum>(v: T) {
        MOD.with(|x| x.replace(v.to_internal_num()));
    }
    fn modulo() -> ModInternalNum {
        998244353
    }

    #[derive(Debug)]
    pub struct ModInt(ModInternalNum);
    impl Clone for ModInt {
        fn clone(&self) -> Self {
            Self(self.0)
        }
    }
    impl Copy for ModInt {}

    impl ModInt {
        fn internal_new(mut v: ModInternalNum) -> Self {
            let m = modulo();
            if v >= m {
                v %= m;
            }
            Self(v)
        }

        pub fn internal_pow(&self, mut e: ModInternalNum) -> Self {
            let mut result = 1;
            let mut cur = self.0;
            let modulo = modulo();
            while e > 0 {
                if e & 1 == 1 {
                    result *= cur;
                    result %= modulo;
                }
                e >>= 1;
                cur = (cur * cur) % modulo;
            }
            Self(result)
        }

        pub fn pow<T>(&self, e: T) -> Self
        where
            T: ToInternalNum,
        {
            self.internal_pow(e.to_internal_num())
        }

        pub fn value(&self) -> ModInternalNum {
            self.0
        }
    }

    pub trait ToInternalNum {
        fn to_internal_num(&self) -> ModInternalNum;
    }
    impl ToInternalNum for ModInt {
        fn to_internal_num(&self) -> ModInternalNum {
            self.0
        }
    }
    macro_rules! impl_primitive {
        ($primitive:ident) => {
            impl From<$primitive> for ModInt {
                fn from(v: $primitive) -> Self {
                    let v = v as ModInternalNum;
                    Self::internal_new(v)
                }
            }
            impl ToInternalNum for $primitive {
                fn to_internal_num(&self) -> ModInternalNum {
                    *self as ModInternalNum
                }
            }
        };
    }
    impl_primitive!(u8);
    impl_primitive!(u16);
    impl_primitive!(u32);
    impl_primitive!(u64);
    impl_primitive!(usize);
    impl_primitive!(i8);
    impl_primitive!(i16);
    impl_primitive!(i32);
    impl_primitive!(i64);
    impl_primitive!(isize);

    impl<T: ToInternalNum> std::ops::AddAssign<T> for ModInt {
        fn add_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }

            self.0 += rhs;
            if self.0 >= m {
                self.0 -= m;
            }
        }
    }

    impl<T: ToInternalNum> std::ops::Add<T> for ModInt {
        type Output = ModInt;
        fn add(self, rhs: T) -> Self::Output {
            let mut res = self;
            res += rhs;
            res
        }
    }
    impl<T: ToInternalNum> std::ops::SubAssign<T> for ModInt {
        fn sub_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            if rhs > 0 {
                self.0 += m - rhs;
            }
            if self.0 >= m {
                self.0 -= m;
            }
        }
    }
    impl<T: ToInternalNum> std::ops::Sub<T> for ModInt {
        type Output = Self;
        fn sub(self, rhs: T) -> Self::Output {
            let mut res = self;
            res -= rhs;
            res
        }
    }
    impl<T: ToInternalNum> std::ops::MulAssign<T> for ModInt {
        fn mul_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            self.0 *= rhs;
            self.0 %= m;
        }
    }
    impl<T: ToInternalNum> std::ops::Mul<T> for ModInt {
        type Output = Self;
        fn mul(self, rhs: T) -> Self::Output {
            let mut res = self;
            res *= rhs;
            res
        }
    }

    impl<T: ToInternalNum> std::ops::DivAssign<T> for ModInt {
        fn div_assign(&mut self, rhs: T) {
            let mut rhs = rhs.to_internal_num();
            let m = modulo();
            if rhs >= m {
                rhs %= m;
            }
            let inv = Self(rhs).internal_pow(m - 2);
            self.0 *= inv.value();
            self.0 %= m;
        }
    }

    impl<T: ToInternalNum> std::ops::Div<T> for ModInt {
        type Output = Self;
        fn div(self, rhs: T) -> Self::Output {
            let mut res = self;
            res /= rhs;
            res
        }
    }
}

