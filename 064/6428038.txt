//include
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <unordered_map>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>

using namespace std;
/*
#include<atcoder/all>
using namespace atcoder;
using mint = modint1000000007;
*/
typedef long long lint;
lint MAX = 1LL<<62;
const lint mod = 1000000007;


struct UnionFind {
    vector<lint> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2

    UnionFind(lint N) : par(N) { //最初は全てが根であるとして初期化
        for(lint i = 0; i < N; i++) par[i] = i;
    }

    lint root(lint x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}
        if (par[x] == x) return x;
        return par[x] = root(par[x]);
    }

    void unite(lint x, lint y) { // xとyの木を併合
        lint rx = root(x); //xの根をrx
        lint ry = root(y); //yの根をry
        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま
        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける
    }

    bool same(lint x, lint y) { // 2つのデータx, yが属する木が同じならtrueを返す
        return root(x) == root(y);
    }
};


lint modpow(lint a, lint b){ //高速な冪乗計算a^b
  lint res = 1;
  while(b>0){
    if(b&1) res = res*a%mod;
    a = a*a%mod;
    b >>= 1;
  }
  return res;
}

lint modfac(lint n){
  if(n==1){
    return 1;
  }
  return modfac(n-1)%mod*n;
}

lint modinv(lint a) {
    return modpow(a, mod - 2);
}

lint modncr(lint n, lint r){ //なぜか大きくなるとバグる
  lint a=modfac(n), b=modfac(r), c=modfac(n-r);
  b = modinv(b);
  c = modinv(c);
  return a%mod*b%mod*c%mod;
}

lint modcomb(lint n, lint r){ //without factorial
  lint up=1, down=1;
  for(int i=1;i<=r;i++){
    down = down*i%mod;
    up = up*(n-i+1)%mod;
  }
  down = modinv(down);
  return up%mod*down%mod;
}

void asshuku(vector<lint> &a){ //座標圧縮0-indexedで返す
  lint n = a.size();
  vector<lint> vec;
  for(lint i=0;i<n;i++){
    vec.push_back(a[i]);
  }
  sort(vec.begin(), vec.end());
  vec.erase(unique(vec.begin(), vec.end()), vec.end());
  for(lint i=0;i<n;i++){
    a[i] = lower_bound(vec.begin(), vec.end(), a[i]) - vec.begin();
  }
}

int nibut(vector<int> a, int b){ //二部探索　なければ-1を返す
  int left = 0, right = a.size()-1;
  while(left <= right){
    int mid = left + (right - left)/2;
    if(a[mid] == b)return mid;
    else if(a[mid] > b)right = mid;
    else left = mid+1;
  }
  return -1;
}


int main(){
  cin.tie(0);
  ios::sync_with_stdio(false);

  int n;
  cin >> n;
  vector<vector<int> > g(n);
  vector<int> dist(n, -1);
  queue<int> que;

  int u, k, v;
  for(int i=0;i<n;i++){
    cin >> u >> k;
    u--;
    for(int j=0;j<k;j++){
      cin >> v;
      v--;
      g[u].push_back(v);
    }
  }

  dist[0]=0;
  que.push(0);
  while(!que.empty()){
    int x = que.front();
    que.pop();
    for(int y : g[x]){
      if(dist[y] != -1) continue;
      dist[y] = dist[x] + 1;
      que.push(y);
    }
  }

  for(int i=0;i<n;i++){
    cout << i+1 << " " << dist[i] << endl;
  }

  return 0;
}

/*
string solve(){
    int n;
    cin >> n;
    vector<int> a, b, vec(n);
    int x, y;
    for(int i=0;i<n;i++){
      if(i%2){
        cin >> x;
        a.push_back(x);
      }else{
        cin >> y;
        b.push_back(y);
      }
    }
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    
    for(int i=0;i<n;i++){
      if(i%2){
        vec[i] = a[i/2];
      }else{
        vec[i] = b[i/2];
      }
    }

    for(int i=0;i<n-1;i++){
      if(vec[i] > vec[i+1]){
        return to_string(i);
      }
    }
    return "OK";
}

void solver(){
  int t;
  cin >> t;
  for(int cnt=1;cnt<=t;cnt++){
    string ans = solve();
    cout << "Case #" << cnt << ": " << ans << endl;
  }
}

int main(){
  solver(); 
  return 0;
}
*/
