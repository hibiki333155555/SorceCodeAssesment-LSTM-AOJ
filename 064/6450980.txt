

fn main() {
    let (n, m) : (usize, usize) = input_t();
    let a : Vec<usize> = input_vec();

    const MOD : usize = 998_244_353;

    let mut cnt = vec![0; n+1]; cnt[0] = 1;
    for a in a {
        let mut b = vec![1; a+1];

        let bit = 64 - (cnt.len() + b.len()).leading_zeros() as usize;

        cnt.resize(1<<bit, 0);
        b.resize(1<<bit, 0);
        ntt(&mut cnt, bit, false);
        ntt(&mut b, bit, false);



        for (cnt, &b) in cnt.iter_mut().zip(b.iter()) { *cnt *= b; *cnt %= MOD; }
        ntt(&mut cnt, bit, true);

        let inv = pow(1<<bit, MOD-2, MOD);
        for cnt in cnt.iter_mut() { *cnt *= inv; *cnt %= MOD; }
        cnt.resize(n+1, 0);
    }


    println!("{}", cnt[n] * (1..=n).fold(1, |acc, v| acc * v % MOD) % MOD);
}

fn pow(mut n:usize, mut x:usize, _mod :usize) -> usize { let mut res = 1; while x != 0 { if x&1 == 1 { res *= n; res %= _mod; } n *= n; n %= _mod; x /= 2; } res }
fn ntt(x :&mut Vec<usize>, bit : usize, inverse : bool) -> () {
    const MOD : usize = 998_244_353;
    let n = x.len();
    assert!(n == 1<<bit);
    assert!(bit <= 32);

    let mask1 = n - 1;

    let mut pv_zeta = pow(3, 119, MOD);
    for _ in 0..23usize.saturating_sub(bit) { pv_zeta *= pv_zeta; pv_zeta %= MOD; }
    if !inverse { pv_zeta = pow(pv_zeta, MOD-2, MOD); }

    let mut zeta = vec![1; n];
    for i in 1..n { zeta[i] = zeta[i-1] * pv_zeta % MOD; }

    for i in 0..bit {
        let mask2 = mask1 >> i + 1;
        let mut tmp = vec![0; n];
        for j in 0..n {
            let lower = j & mask2;
            let upper = j ^ lower;
            let shifted = upper << 1 & mask1;
            tmp[j] = x[shifted | lower] + zeta[upper] * x[shifted | mask2 + 1 | lower] % MOD;
            tmp[j] %= MOD;
        }
        *x = tmp;
    }
}

#[allow(dead_code)] fn input<T: std::str::FromStr>() -> T { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); s.trim().parse().ok().unwrap() } #[allow(dead_code)] fn input_t<T: std::str::FromStr, U: std::str::FromStr>() -> (T, U) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap()) } #[allow(dead_code)] fn input_t3<T1: std::str::FromStr, T2: std::str::FromStr, T3: std::str::FromStr>() -> (T1, T2, T3) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap(), s[2].parse().ok().unwrap()) } #[allow(dead_code)] fn input_t4<T1: std::str::FromStr, T2: std::str::FromStr, T3: std::str::FromStr, T4: std::str::FromStr>() -> (T1, T2, T3, T4) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap(), s[2].parse().ok().unwrap(), s[3].parse().ok().unwrap()) } #[allow(dead_code)] fn input_t5<T1: std::str::FromStr, T2: std::str::FromStr, T3: std::str::FromStr, T4: std::str::FromStr, T5: std::str::FromStr>() -> (T1, T2, T3, T4, T5) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap(), s[2].parse().ok().unwrap(), s[3].parse().ok().unwrap(), s[4].parse().ok().unwrap()) } #[allow(dead_code)] fn input_vec<T: std::str::FromStr>() -> Vec<T> { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); s.trim().split_whitespace().map(|s| s.parse().ok().unwrap()).collect() }
