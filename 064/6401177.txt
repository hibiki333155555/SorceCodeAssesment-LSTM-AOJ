#include <bits/stdc++.h>
using namespace std;

struct io_setup {
    io_setup() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout << fixed << setprecision(15);
    }
} io_setup;

struct Bipartite_Matching {
    vector<vector<int>> es;
    vector<int> d, match;
    vector<bool> used, used2;
    const int n, m;

    Bipartite_Matching(int n, int m) : es(n), d(n), match(m), used(n), used2(n), n(n), m(m) {}

    void add_edge(int u, int v) { es[u].push_back(v); }

    void _bfs() {
        fill(begin(d), end(d), -1);
        queue<int> que;
        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                que.push(i);
                d[i] = 0;
            }
        }
        while (!que.empty()) {
            int i = que.front();
            que.pop();
            for (auto &e : es[i]) {
                int j = match[e];
                if (j != -1 && d[j] == -1) {
                    que.push(j);
                    d[j] = d[i] + 1;
                }
            }
        }
    }

    bool _dfs(int now) {
        used2[now] = true;
        for (auto &e : es[now]) {
            int u = match[e];
            if (u == -1 || (!used2[u] && d[u] == d[now] + 1 && _dfs(u))) {
                match[e] = now, used[now] = true;
                return true;
            }
        }
        return false;
    }

    int bipartite_matching() { // 右側のiは左側のmatch[i]とマッチングする
        fill(begin(match), end(match), -1), fill(begin(used), end(used), false);
        int ret = 0;
        while (true) {
            _bfs();
            fill(begin(used2), end(used2), false);
            int flow = 0;
            for (int i = 0; i < n; i++) {
                if (!used[i] && _dfs(i)) flow++;
            }
            if (flow == 0) break;
            ret += flow;
        }
        return ret;
    }
};

struct Dulmage_Mendelsohn_Decomposition : Bipartite_Matching {
    using BM = Bipartite_Matching;
    vector<vector<int>> rs;
    vector<vector<int>> ids_l, ids_r; // 左側と右側のブロック
    vector<int> comp_l, comp_r;       // 属するブロックの番号
    vector<int> vs;

    Dulmage_Mendelsohn_Decomposition(int n, int m) : BM(n, m), rs(n), comp_l(n), comp_r(m) {}

    void _dfs(int now, int col) {
        if (comp_l[now] != n + 1) return;
        comp_l[now] = col;
        for (auto &e : this->es[now]) {
            int to = this->match[e];
            if (to != -1) _dfs(to, col);
        }
        if (col > 0) vs.push_back(now);
    }

    void _rdfs(int now, int col) {
        if (comp_l[now] != n + 1) return;
        comp_l[now] = col;
        for (auto &e : rs[now]) _rdfs(e, col);
    }

    void decompose() {
        this->bipartite_matching();
        for (int i = 0; i < n; i++) {
            for (auto &e : this->es[i]) {
                int to = this->match[e];
                if (to != -1) rs[to].push_back(i);
            }
        }
        fill(begin(comp_l), end(comp_l), n + 1);
        for (int i = 0; i < n; i++) {
            bool flag = true;
            for (auto &e : es[i]) {
                if (this->match[e] == -1) {
                    _rdfs(i, 0);
                    flag = false;
                } else if (this->match[e] == i) {
                    flag = false;
                }
            }
            if (flag) _dfs(i, -1);
        }
        for (int i = 0; i < n; i++) _dfs(i, 1);
        for (int i = 0; i < n; i++) {
            if (comp_l[i] > 0) comp_l[i] = n + 1;
        }
        reverse(begin(vs), end(vs));
        int cnt = 1;
        for (auto &e : vs) {
            if (comp_l[e] == n + 1) _rdfs(e, cnt++);
        }
        for (int i = 0; i < n; i++) {
            if (comp_l[i] == -1) comp_l[i] = cnt;
        }
        for (int i = 0; i < m; i++) {
            if (this->match[i] == -1) {
                comp_r[i] = 0;
            } else {
                comp_r[i] = comp_l[this->match[i]];
            }
        }
        ids_l.resize(cnt + 1), ids_r.resize(cnt + 1);
        for (int i = 0; i < m; i++) {
            if (this->match[i] == -1) ids_r[0].push_back(i);
        }
        vector<bool> used(n, false);
        for (int i = 0; i < m; i++) {
            int e = this->match[i];
            if (e != -1) {
                ids_l[comp_l[e]].push_back(e);
                ids_r[comp_r[i]].push_back(i);
                used[e] = true;
            }
        }
        for (int i = 0; i < n; i++) {
            if (!used[i]) ids_l[cnt].push_back(i);
        }
    }
};

template <bool directed = false>
struct Graph {
    struct edge {
        int to, id;
        edge(int to, int id) : to(to), id(id) {}
    };

    vector<vector<edge>> es;
    const int n;
    int m;

    vector<int> d;
    vector<int> pre_v, pre_e;

    Graph(int n) : es(n), n(n), m(0), d(n), pre_v(n), pre_e(n) {}

    void add_edge(int from, int to) {
        es[from].emplace_back(to, m);
        if (!directed) es[to].emplace_back(from, m);
        m++;
    }

    int bfs(int s, int t = 0) {
        fill(begin(d), end(d), -1);
        queue<int> que;
        d[s] = 0;
        que.emplace(s);
        while (!que.empty()) {
            int i = que.front();
            que.pop();
            for (auto &e : es[i]) {
                if (d[e.to] == -1) {
                    d[e.to] = d[i] + 1;
                    pre_v[e.to] = i, pre_e[e.to] = e.id;
                    que.push(e.to);
                }
            }
        }
        return d[t];
    }

    vector<int> shortest_path(int s, int t, bool use_id = false) {
        if (bfs(s, t) == -1) return {};
        vector<int> ret;
        for (int now = t; now != s; now = pre_v[now]) ret.push_back(use_id ? pre_e[now] : now);
        if (!use_id) ret.push_back(s);
        reverse(begin(ret), end(ret));
        return ret;
    }
};

template <typename T, bool directed = false>
struct Weighted_Graph {
    struct edge {
        int to;
        T cost;
        int id;
        edge(int to, T cost, int id) : to(to), cost(cost), id(id) {}
    };

    vector<vector<edge>> es;
    const T INF_T = numeric_limits<T>::max() / 2;
    const int n;
    int m;

    vector<T> d;
    vector<int> pre_v;

    Weighted_Graph(int n) : es(n), n(n), m(0), d(n), pre_v(n) {}

    void add_edge(int from, int to, T cost) {
        es[from].emplace_back(to, cost, m);
        if (!directed) es[to].emplace_back(from, cost, m);
        m++;
    }

    bool bellman_ford(int s) { // sから到達可能な負閉路を検出
        fill(begin(d), end(d), INF_T);
        d[s] = 0;
        bool ret = false;
        for (int i = 0; i < 2 * n; i++) {
            for (int j = 0; j < n; j++) {
                for (auto &e : es[j]) {
                    if (d[j] == INF_T) continue;
                    if (d[j] + e.cost < d[e.to]) {
                        d[e.to] = d[j] + e.cost, pre_v[e.to] = j;
                        if (i >= n - 1) d[e.to] = -INF_T, ret = true;
                    }
                }
            }
        }
        return ret;
    }

    bool negative_loop() { //全ての負閉路を検出
        fill(begin(d), end(d), 0);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (auto &e : es[j]) {
                    if (d[j] + e.cost < d[e.to]) {
                        d[e.to] = d[j] + e.cost;
                        if (i == n - 1) return true;
                    }
                }
            }
        }
    }

    vector<int> shortest_path(int s, int t) {
        bellman_ford(s);
        if (abs(d[t]) == INF_T) return {};
        vector<int> ret;
        for (int now = t; now != s; now = pre_v[now]) ret.push_back(now);
        ret.push_back(s), reverse(begin(ret), end(ret));
        return ret;
    }
};

struct Partition_Matroid {
    const int m; // |E|
    const int n; // 分割の個数
    vector<vector<int>> ids;
    vector<int> belong;
    vector<int> d, cnt;
    vector<vector<int>> used;

    Partition_Matroid(int m, int n, const vector<vector<int>> &ids, vector<int> &d) : m(m), n(n), ids(ids), d(d), cnt(n), used(n) {
        assert(ids.size() == n && d.size() == n);
        belong.assign(m, -1);
        for (int i = 0; i < n; i++) {
            for (auto &e : ids[i]) belong[e] = i;
        }
    }

    int size() { return m; }

    template <typename T>
    void set(const vector<T> &X) { // X∈F 計算量 O(m+n)
        fill(begin(cnt), end(cnt), 0);
        for (int i = 0; i < n; i++) used[i].clear();
        for (int i = 0; i < m; i++) {
            if (X[i]) cnt[belong[i]]++;
        }
        for (int i = 0; i < n; i++) {
            assert(cnt[i] <= d[i]);
            if (cnt[i] == d[i]) {
                for (auto &e : ids[i]) {
                    if (X[e]) used[i].push_back(e);
                }
            }
        }
    }

    vector<int> circuit(int y) const { // C(X,y) 計算量 O(1)
        assert(0 <= y && y < m);
        int p = belong[y];
        assert(0 <= p && p < n);
        if (cnt[p] == d[p]) {
            vector<int> ret = used[p];
            ret.push_back(y);
            return ret;
        }
        return {};
    }
};

struct Graphic_Matroid {
    struct edge {
        int to, id;
        edge(int to, int id) : to(to), id(id) {}
    };

    const int m; // |E|
    const int n; // |V|
    vector<vector<edge>> list;
    vector<pair<int, int>> es;
    vector<int> pre_v, pre_e;
    vector<int> root;
    vector<int> depth;

    Graphic_Matroid(int m, int n, const vector<pair<int, int>> &es) : m(m), n(n), es(es), pre_v(n), pre_e(n), root(n), depth(n) {
        list.resize(n);
        for (int i = 0; i < m; i++) {
            auto [u, v] = es[i];
            list[u].emplace_back(v, i);
            list[v].emplace_back(u, i);
        }
    }

    int size() { return m; }

    template <typename T>
    void set(const vector<T> &X) { // X∈F 計算量 O(m+n)
        fill(begin(pre_v), end(pre_v), -1);
        fill(begin(pre_e), end(pre_e), -1);
        fill(begin(root), end(root), -1);
        fill(begin(depth), end(depth), -1);
        for (int i = 0; i < n; i++) {
            if (root[i] != -1) continue;
            queue<int> que;
            que.push(i);
            depth[i] = 0;
            while (!que.empty()) {
                int j = que.front();
                que.pop();
                root[j] = i;
                for (auto &e : list[j]) {
                    assert(!X[e.id] || root[e.to] == -1 || e.id == pre_e[j]);
                    if (X[e.id] && root[e.to] == -1) {
                        pre_v[e.to] = j;
                        pre_e[e.to] = e.id;
                        depth[e.to] = depth[j] + 1;
                        que.emplace(e.to);
                    }
                }
            }
        }
    }

    vector<int> circuit(int y) const { // C(X,y) 計算量 O(n)
        auto [s, t] = es[y];
        if (root[s] != root[t]) return {};
        int r = root[s];
        vector<int> ret;
        while (s != t) {
            if (depth[s] > depth[t]) {
                ret.push_back(pre_e[s]);
                s = pre_v[s];
            } else {
                ret.push_back(pre_e[t]);
                t = pre_v[t];
            }
        }
        ret.push_back(y);
        return ret;
    }
};

struct Transversal_Matroid {
    const int m; // |L|
    const int n; // |R|
    vector<vector<int>> es;
    vector<bool> fixed;
    vector<vector<int>> res;

    Transversal_Matroid(int m, int n, const vector<vector<int>> &es) : m(m), n(n), es(es), fixed(n), res(m + n) {}

    int size() { return m; }

    template <typename T>
    void set(const vector<T> &X) { // X∈F 計算量 O(e√(m+n)+m+n+e)
        fill(begin(fixed), end(fixed), true);
        for (int i = 0; i < m + n; i++) res[i].clear();
        Dulmage_Mendelsohn_Decomposition DM(m, n);
        for (int i = 0; i < m; i++) {
            if (X[i]) {
                for (auto &e : es[i]) DM.add_edge(i, e);
            }
        }
        DM.decompose();
        assert(DM.ids_r.back().empty());
        for (auto &e : DM.ids_r[0]) fixed[e] = false;
        for (int i = 0; i < m; i++) {
            for (auto &e : es[i]) res[i].push_back(m + e);
        }
        for (int i = 0; i < (int)DM.ids_l.size() - 1; i++) {
            int k = DM.ids_l[i].size(), l = DM.ids_r[i].size();
            for (int j = 0; j < k; j++) {
                int u = DM.ids_l[i][j], v = DM.ids_r[i][l - k + j];
                res[m + v].push_back(u);
            }
        }
    }

    vector<int> circuit(int y) const { // C(X,y) 計算量 O(e+m+n)
        for (auto &e : es[y]) {
            if (!fixed[e]) return {};
        }
        vector<bool> used(m + n, false);
        used[y] = true;
        queue<int> que;
        que.push(y);
        while (!que.empty()) {
            int i = que.front();
            que.pop();
            for (auto &e : res[i]) {
                if (!used[e]) {
                    used[e] = true;
                    que.emplace(e);
                }
            }
        }
        vector<int> ret;
        for (int i = 0; i < m; i++) {
            if (used[i]) ret.push_back(i);
        }
        return ret;
    }
};

template <typename Matroid_1, typename Matroid_2>
int Matroid_Intersection(Matroid_1 M1, Matroid_2 M2) {
    assert(M1.size() == M2.size());
    const int m = M1.size();
    vector<bool> X(m, false);
    for (int i = 0;; i++) {
        M1.set(X), M2.set(X);
        Graph<true> G(m + 2); // 最短路を求める
        int s = m, t = m + 1;
        for (int y = 0; y < m; y++) {
            if (X[y]) continue;
            vector<int> c1 = M1.circuit(y), c2 = M2.circuit(y);
            if (c1.empty()) G.add_edge(s, y);
            for (auto &x : c1) {
                if (x != y) G.add_edge(x, y);
            }
            if (c2.empty()) G.add_edge(y, t);
            for (auto &x : c2) {
                if (x != y) G.add_edge(y, x);
            }
        }
        vector<int> path = G.shortest_path(s, t);
        if (path.empty()) return i;
        for (auto &e : path) {
            if (e != s && e != t) X[e] = !X[e];
        }
    }
    return -1;
};

template <typename Matroid_1, typename Matroid_2, typename T>
vector<T> Weighted_Matroid_Intersection(Matroid_1 M1, Matroid_2 M2, vector<T> w) {
    assert(M1.size() == M2.size());
    const int m = M1.size();
    for (int i = 0; i < m; i++) w[i] *= m + 1;
    vector<bool> X(m, false);
    vector<T> ret(m + 1, -1);
    ret[0] = 0;
    for (int i = 1; i <= m; i++) {
        M1.set(X), M2.set(X);
        Weighted_Graph<T, true> G(m + 2); // コスト最大のパスのうち通る辺数が最小のものを求める
        int s = m, t = m + 1;
        for (int y = 0; y < m; y++) {
            if (X[y]) continue;
            vector<int> c1 = M1.circuit(y), c2 = M2.circuit(y);
            if (c1.empty()) G.add_edge(s, y, 0);
            for (auto &x : c1) {
                if (x != y) G.add_edge(x, y, w[x] + 1);
            }
            if (c2.empty()) G.add_edge(y, t, -w[y]);
            for (auto &x : c2) {
                if (x != y) G.add_edge(y, x, -w[y] + 1);
            }
        }
        vector<int> path = G.shortest_path(s, t);
        if (path.empty()) break;
        for (auto &e : path) {
            if (e != s && e != t) X[e] = !X[e];
        }
        T sum = 0;
        for (int j = 0; j < m; j++) {
            if (X[j]) sum += w[j];
        }
        ret[i] = sum / (m + 1);
    }
    return ret;
}

template <typename T>
T floor_sqrt(T x) {
    T L = 0, R = x + 1;
    while (R - L > 1) {
        T M = (L + R) / 2;
        (M * M <= x ? L : R) = M;
    }
    return L;
}

int main() {
    int L, R, E;
    cin >> L >> R >> E;

    vector<vector<int>> ids1(L), ids2(R);
    vector<int> d1(L, 1), d2(R, 1);

    for (int i = 0; i < E; i++) {
        int u, v;
        cin >> u >> v;
        ids1[u].push_back(i), ids2[v].push_back(i);
    }

    Partition_Matroid M1(E, L, ids1, d1), M2(E, R, ids2, d2);

    cout << Matroid_Intersection(M1, M2) << '\n';
}
