#include <iostream>
#include <vector>
#include <cassert>
#include <algorithm>

using namespace std;
using ll = long long;

const ll MOD = 998244353;

struct range {
    int l, r; // [l ,r)
};

int n;
vector<ll> cost;
vector<range> ranges;
ll ret = 0;

void dfs(const range parent, int here) {
    range now = ranges[here];
    if (here < n)dfs(now, here * 2), dfs(now, here * 2 + 1);

    if (parent.l == now.l && parent.r == now.r)return;

    ll left = -1, right = -1;
    if (parent.l == now.l) {
        left = now.l, right = parent.r - now.r;
    } else if (parent.r == now.r) {
        left = now.l - parent.l, right = n + 1 - now.r;
    } else {
        assert(1 != 0);
    }

    ret += (left * right % MOD) * cost[here] % MOD;
    ret %= MOD;
}

ll calc_pow(ll x, ll pow) {
    if (pow == 0) return 1;
    ll a = calc_pow(x, pow / 2);
    a = a * a % MOD;
    if (pow % 2 == 1) a *= x;
    return a % MOD;
}

ll calc_div(ll a, ll b) {
    return a * calc_pow(b, MOD - 2) % MOD;
}

int main() {
    cin >> n;

    cost.resize(2 * n);
    for (int i = 1; i <= 2 * n - 1; i++)cin >> cost[i];

    ranges.resize(2 * n);
    for (int i = n; i <= 2 * n - 1; i++)ranges[i] = {i - n + 1, i - n + 1};
    for (int i = n - 1; i >= 1; i--) {
        cost[i] = min(cost[i], cost[2 * i] + cost[2 * i + 1]);
        ranges[i].l = min(ranges[2 * i].l, ranges[2 * i + 1].l);
        ranges[i].r = max(ranges[2 * i].r, ranges[2 * i + 1].r);
    }

    ret += cost[1];
    if (n >= 2) {
        dfs(ranges[1], 2);
        dfs(ranges[1], 3);
    }

    ret *= 2, ret %= MOD;
    ret = calc_div(ret, n);
    ret = calc_div(ret, n + 1);

    cout << ret << endl;
    return 0;
}
