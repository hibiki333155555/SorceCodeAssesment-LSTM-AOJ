

#include <bits/stdc++.h>
#include <iostream>
#include <limits>
#include <numeric>
#include <type_traits>
#include <bitset>
#include <map>
#include <unordered_map>
#include <set>

using namespace std;

#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)
#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)
using ll = long long;
const ll mod = 1000000007;//998244353;
const ll inf = 1e9;
const ll INF = 1e18;


void pline(vector<ll> lis){
    rep(i,0,lis.size()){
        printf ("%lld",lis[i]);
        if (i != lis.size()-1) printf(" ");
        else printf("\n");
    }
}

/*
void pmap(map<ll,mint>& lis){
    for (auto p : lis){
        printf ("%lld:%lld ,",p.first,p.second.val());
    }
    printf ("\n");
}*/

/*
void setxor(set<ll>& a,set<ll>& b){ // a ^= b
    for (ll x : b){
        if (a.count(x) > 0) a.erase(x);
        else a.insert(x);
    }
}

set<ll> setmin(set<ll> a,set<ll> b){

    auto aitr = a.begin();
    auto bitr = b.begin();

    while (aitr != a.end() && bitr != b.end()){
        if (*aitr < *bitr) return a;
        else if (*aitr > *bitr) return b;
        aitr++;
        bitr++;
    }

    if (*aitr == a.end()) return a;
    return b;

}
*/

char shift(char c , ll x){
    x %= 26;
    rep(i,0,x){
        if (c == 'z'){
            c = 'a';
        }else{
            c++;
        }
    }
    return c;
}

int main(){

    ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    //ModFac mf(200000);
    ll H,W;
    cin >> H >> W;
    
    vector<string> S(H);
    rep(i,0,H){
        cin >> S[i];
    }

    ll sx,sy;
    ll gx,gy;

    rep(i,0,H){
        rep(j,0,W){
            if (S[i][j] == 'S'){
                sx = i;
                sy = j;
                S[i][j] = '.';
            }
            if (S[i][j] == 'V'){
                gx = i;
                gy = j;
                S[i][j] = '.';
            }
        }
    }

    vector<vector<ll>> tlis(H,vector<ll> (W,inf));

    ll M;
    cin >> M;
    rep(i,0,M){
        ll a,b,nt;
        cin >> a >> b >> nt;
        a--;b--;
        tlis[a][b] = nt;
    }


    ll ansf;

    {

        vector<vector<ll>> d(H,vector<ll> (W,inf));

        list<pair<ll,ll>> q;
        q.push_back( make_pair(sx,sy) );
        d[sx][sy] = 0;

        while (!q.empty()){

            auto xy = q.front(); q.pop_front();
            ll x = xy.first;
            ll y = xy.second;
            if (S[x][y] == '#'){
                continue;
            }else{

                ll nexx,nexy;
                vector<ll> xs = {x-1,x+1,x,x};
                vector<ll> ys = {y,y,y-1,y+1};

                rep(lp,0,4){
                    ll nexx = xs[lp];
                    ll nexy = ys[lp];
                    if ( 0 <= nexx && nexx < H && 0 <= nexy && nexy < W ){
                        
                        if (d[nexx][nexy] > d[x][y] + 1 && d[x][y]+1 < tlis[nexx][nexy]){
                            d[nexx][nexy] = d[x][y] + 1;
                            q.push_back(make_pair(nexx,nexy));
                        }
                    }
                }
            }
        }

        ansf = d[gx][gy];
        if (ansf >= inf/2){
            cout << "No" << endl;
            return 0;
        }
    }


    {

        vector<vector<ll>> d(H,vector<ll> (W,inf));

        list<pair<ll,ll>> q;
        q.push_back( make_pair(gx,gy) );
        d[gx][gy] = ansf;

        while (!q.empty()){

            auto xy = q.front(); q.pop_front();
            ll x = xy.first;
            ll y = xy.second;
            if (S[x][y] == '#'){
                continue;
            }else{

                ll nexx,nexy;
                vector<ll> xs = {x-1,x+1,x,x};
                vector<ll> ys = {y,y,y-1,y+1};

                rep(lp,0,4){
                    ll nexx = xs[lp];
                    ll nexy = ys[lp];
                    if ( 0 <= nexx && nexx < H && 0 <= nexy && nexy < W ){
                        
                        if (d[nexx][nexy] > d[x][y] + 1 && d[x][y]+1 < tlis[nexx][nexy]){
                            d[nexx][nexy] = d[x][y] + 1;
                            q.push_back(make_pair(nexx,nexy));
                        }
                    }
                }
            }
        }

        ansf = d[sx][sy];
        if (ansf >= inf/2){
            cout << "No" << endl;
            return 0;
        }else{
            cout << "Yes" << endl;
            return 0;
        }
    }


}

/*

G:


*/
