#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;

// f: [0, n) -> T
template < class T, class func > pair< int, T > find_local_minimum(func f, int n) {
    int a = 0, b = (n + 1) / 2, c = n + 1;
    while(c - a > 2) {
        int l = (a + b) / 2, r = (b + c + 1) / 2;
        if(f(l) < f(b))
            tie(a, b, c) = make_tuple(a, l, b);
        else if(f(b) > f(r))
            tie(a, b, c) = make_tuple(b, r, c);
        else
            tie(a, b, c) = make_tuple(l, b, r);
    }
    return {b, f(b)};
};

// f: [0, p) -> T, f(x) = f(x + p)
template < class T, class func > pair< int, T > find_minimum(func f, int p) {
    return find_local_minimum< T, func >(f, 2 * p - 1);
}

template < class T > vector< int > argsort(vector< T > &a) {
    vector< int > ids((int)a.size());
    iota(ids.begin(), ids.end(), 0);
    sort(ids.begin(), ids.end(), [&](int i, int j) {
        return a[i] < a[j] || (a[i] == a[j] && i < j);
    });
    return ids;
}

template < class T >
pair< vector< int >, vector< pair< T, T > > > convex_hull(vector< pair< T, T > > &points, string mode = "full", bool inclusive = false) {
    assert(mode == "full" || mode == "lower" || mode == "upper");
    int n = points.size();
    if(n == 1) return {{0}, {points[0]}};
    if(n == 2) return {{0, 1}, {points[0], points[1]}};
    vector<int> I = argsort(points);

    auto check = [&](int i, int j, int k) {
        auto [xi, yi] = points[i];
        auto [xj, yj] = points[j];
        auto [xk, yk] = points[k];
        T det = (xj - xi) * (yk - yj) - (yj - yi) * (xk - xj);
        return inclusive ? det >= 0 : det > 0;
    };

    auto calc = [&]() {
        vector<int> J;
        for(int k : I) {
            while(J.size() >= 2) {
                if(check(J[J.size() - 2], J.back(), k)) break;
                J.pop_back();
            }
            J.push_back(k);
        }
        return J;
    };

    vector<int> ids;
    if(mode == "full" || mode == "lower") {
        vector<int> J = calc();
        ids.insert(ids.end(), J.begin(), J.end());
    }
    if(mode == "full" || mode == "upper") {
        if(!ids.empty()) ids.pop_back();
        reverse(I.begin(), I.end());
        vector<int> J = calc();
        ids.insert(ids.end(), J.begin(), J.end());
    }
    if(mode == "upper") reverse(ids.begin(), ids.end());
    if(ids.size() >= 2 && ids[0] == ids.back()) ids.pop_back();
    vector< pair< T, T > > ch;
    for(int i : ids) ch.push_back(points[i]);
    return {ids, ch};
}



template < class T > class CHT_xy {
  private:
    using Point = pair< T, T >;
    vector< Point > ps;
    bool is_prepared = false;

    T eval(int i, T x, T y) {
        i %= size(); if(i < 0) i += size();
        auto [a, b] = ps[i];
        return a * x + b * y;
    }

    struct rets {
        Point p; T v;
    };

  public:
    CHT_xy() {}
    CHT_xy(vector< Point > &ps) : ps(ps) {}

    int size() { return ps.size(); }

    void clear() { ps.clear(); is_prepared = false; }

    void add(Point p) {
        assert(!is_prepared);
        ps.push_back(p);
    }
    void add(T a, T b) {
        add(Point(a, b));
    }

    void build() {
        assert(!is_prepared);
        is_prepared = true;
        ps = convex_hull< T >(ps).second;
    }

    rets get_min(T x, T y) {
        assert(is_prepared);
        auto f = [&](int i) -> T { return +eval(i, x, y); };
        auto [i, minimum] = find_minimum< T >(f, size());
        return {ps[i], +minimum};
    }

    rets get_max(T x, T y) {
        assert(is_prepared);
        auto f = [&](int i) -> T { return -eval(i, x, y); };
        auto [i, minimum] = find_minimum< T >(f, size());
        return {ps[i], -minimum};
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);

    int n; cin >> n;
    vector<ll> a(n);
    rep(i,n) cin >> a[i];

    vector< pair<ll, ll> > p(n);
    for(auto &[x, y] : p) cin >> x >> y;

    auto calc = [&](vector< pair< ll, ll > > &ps) -> ll {
        CHT_xy<ll> cht;
        for(auto [x, y] : ps) cht.add(-y, x);
        cht.build();
        ll ans = 0;
        for(auto [x, y] : ps) ans = max(ans, abs(cht.get_max(x, y).v));
        for(auto [x, y] : ps) ans = max(ans, abs(cht.get_min(x, y).v));
        return ans;
    };

    rep(i,n) {
        vector<pair<ll,ll>> ps;
        rep(j,n) if(j != i) {
            ll dx = p[j].first  - p[i].first;
            ll dy = p[j].second - p[i].second;
            dx *= a[j];
            dy *= a[j];
            ps.push_back({dx, dy});
        }

        cout << a[i] * calc(ps) << endl;
    }
}
