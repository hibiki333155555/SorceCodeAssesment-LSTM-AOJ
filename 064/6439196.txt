import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
const long mod = 1_000_000_000 + 7;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

int mpow (long x, long n, int M) {
  if (n == 0L)
    return 1L;
  long ret = 1L;
  while (n > 0L) {
    if (n % 2L == 0L) {
      x *= x;
      x %= M;
      n /= 2L;
    } else {
      ret *= x;
      ret %= M;
      n -= 1L;
    }
  }
  return cast(int) ret;
}

Tuple!(long, long) calc (string N, int M) {
  const int maxK = N.length.to!int;

  auto dp = new long[][][][][](2, 2, 10, 3, 500);
  foreach (i; 0 .. 2)
    foreach (k; 0 .. 2)
      foreach (j; 0 .. 10)
        foreach (l; 0 .. 3)
          foreach (m; 0 .. M)
            dp[i][k][j][l][m] = -1L;

  dp[1][0][0][0][0] = 1L;

  for (long i = maxK; i > 0; i--) {
    long ni = (N[maxK - i] - '0');

    foreach (k; 0 .. 2)
      foreach (j; 0 .. 10)
        foreach (l; 0 .. 3)
          foreach (m; 0 .. M) {
            if (dp[1][k][j][l][m] < 0L)
              continue;

            foreach (d; 0 .. 10) {
              if (k == 0 && d > ni)
                continue;
              if (l == 0 && j != 0 && j == d)
                continue;
              if (l == 1 && j <= d)
                continue;
              if (l == 2 && j >= d)
                continue;

              int nk = cast(int)(k == 1 || d < ni);
              int nj = d;
              int nl;
              if (l == 0) {
                if (j == 0)
                  nl = 0;
                else if (j < d)
                  nl = 1;
                else
                  nl = 2;
              } else if (l == 1)
                nl = 2;
              else
                nl = 1;

              int nm = d * mpow(10L, i - 1L, M);
              nm %= M;
              nm += m;
              nm %= M;

              dp[0][nk][nj][nl][nm] =
                max(0L, dp[0][nk][nj][nl][nm]) + dp[1][k][j][l][m];
              dp[0][nk][nj][nl][nm] %= 10_000L;
            }
          }

    foreach (k; 0 .. 2)
      foreach (j; 0 .. 10)
        foreach (l; 0 .. 3)
          foreach (m; 0 .. M) {
            dp[1][k][j][l][m] = dp[0][k][j][l][m];
            dp[0][k][j][l][m] = -1L;
          }
  }

  long ret0 = 0L, ret1 = 0L;
  foreach (j; 0 .. 10)
    foreach (l; 0 .. 3) {
      if (dp[1][0][j][l][0] >= 0L) {
        ret0 += dp[1][0][j][l][0];
        ret0 %= 10_000L;
      }
      if (dp[1][1][j][l][0] >= 0L) {
        ret1 += dp[1][1][j][l][0];
        ret1 %= 10_000L;
      }
    }

  return tuple(ret0, ret1);
}

void main () {
  string A = readln.chomp;
  string B = readln.chomp;
  int M = readln.chomp.to!int;

  auto retA = calc(A, M);
  auto retB = calc(B, M);

  long ret = retB[0] + retB[1] - retA[1];
  ret += 10_000L;
  ret %= 10_000L;
  writeln(ret);
}

