import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False

dx_dy_list = [(1, 0), (0, 1), (-1, 0), (0, -1)]


def show_puzzle(puzzle, width, height):
    for y in range(height):
        for x in range(width):
            print(f'{puzzle[y][x]:2d}', end=' ')
        print('')
    return


def calc_manhattan_distance_table(width, num_idx, goal_state):
    manhattan_distance_table = [[0] * num_idx for _ in range(num_idx)]

    for c_num in range(num_idx):
        g_idx = goal_state.index(c_num)
        gx = g_idx % width
        gy = g_idx // width
        for c_idx in range(num_idx):
            cx = c_idx % width
            cy = c_idx // width

            if c_num != 0:
                manhattan_distance_table[c_num][c_idx] = abs(gx - cx) + abs(gy - cy)
            else:
                manhattan_distance_table[c_num][c_idx] = 0
    return manhattan_distance_table


def calc_manhattan_distance(num_idx, manhattan_distance_table, state):
    m_dist = 0
    for c_idx in range(num_idx):
        c_num = state[c_idx]
        m_dist += manhattan_distance_table[c_num][c_idx]
    return m_dist


def dls(num_idx, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
        c_state,  c_zero_idx, c_h_dist, c_num_moves, pre_p):
    if c_state == goal_state:
        return c_num_moves

    if c_num_moves > depth_limit:
        return -1

    for i in adjacency_list[c_zero_idx]:
        p = c_state[i]
        if p == pre_p:
            continue

        c_state[c_zero_idx] = p
        c_state[i] = 0
        n_zero_idx = i
        n_h_dist = c_h_dist - manhattan_distance_table[p][i] + manhattan_distance_table[p][c_zero_idx]
        n_num_moves = c_num_moves + 1
        if n_h_dist <= depth_limit:
            moves = dls(num_idx, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
                        c_state, n_zero_idx, n_h_dist, n_num_moves, p)
            if moves >= 0:
                return moves

        c_state[c_zero_idx] = 0
        c_state[i] = p
    return -1


def iddfs(num_idx, adjacency_list, manhattan_distance_table, max_depth, start_state, zero_idx, goal_state):
    c_m_dist = calc_manhattan_distance(num_idx, manhattan_distance_table, start_state)
    is_even_start_zero_idx = (zero_idx % 2 == 0)
    g_zero_idx = goal_state.index(0)
    is_even_goal_zero_idx = (g_zero_idx % 2 == 0)
    start_depth = c_m_dist

    # if is_even_start_zero_idx != is_even_goal_zero_idx:
    #     start_depth += 1

    for depth_limit in range(start_depth, max_depth + 2, 2):
        moves = dls(num_idx, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
                    start_state, zero_idx, c_m_dist, 0, None)
        if moves >= 0:
            print(moves)
            break

    return


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    goal_state = []
    width = 4
    height = 4
    num_idx = width * height
    adjacency_list = [[] for _ in range(num_idx)]

    for y in range(height):
        offset = y * width
        for x in range(width):
            idx = offset + x
            goal_state.append(idx + 1)

            for dx, dy in dx_dy_list:
                nx = x + dx
                ny = y + dy
                n_idx = ny * width + nx
                if 0 <= nx < width and 0 <= ny < height:
                    adjacency_list[idx].append(n_idx)

    goal_state[-1] = 0
    manhattan_distance_table = calc_manhattan_distance_table(width, num_idx, goal_state)
    start_state = []
    for _ in range(height):
        row = list(map(int, f.readline().split()))
        start_state += row

    zero_idx = start_state.index(0)
    max_depth = 45
    iddfs(num_idx, adjacency_list, manhattan_distance_table, max_depth, start_state, zero_idx, goal_state)

    return


if __name__ == '__main__':
    main()

