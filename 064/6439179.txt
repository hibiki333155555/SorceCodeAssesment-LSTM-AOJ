import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
const long mod = 1_000_000_000 + 7;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

int mpow (long x, long n, int M) {
  if (n == 0L)
    return 1L;
  long ret = 1L;
  while (n > 0L) {
    if (n % 2L == 0L) {
      x *= x;
      x %= M;
      n /= 2L;
    } else {
      ret *= x;
      ret %= M;
      n -= 1L;
    }
  }
  return cast(int) ret;
}

Tuple!(long, long) calc (string N, int M) {
  const int maxK = N.length.to!int;

  auto dp = new long[][][][][][](2, 2, 10, 2, 500, 3);
  foreach (i; 0 .. 2)
    foreach (k; 0 .. 2)
      foreach (j; 0 .. 10)
        foreach (l; 0 .. 2)
          foreach (m; 0 .. M)
            foreach (n; 0 .. 3)
              dp[i][k][j][l][m][n] = -1L;
  dp[1][0][0][0][0][0] = 1L;

  for (long i = maxK; i > 0; i--) {
    long ni = (N[maxK - i] - '0');

    foreach (k; 0 .. 2)
      foreach (j; 0 .. 10)
        foreach (l; 0 .. 2)
          foreach (m; 0 .. M)
            foreach (n; 0 .. 3) {
              if (dp[1][k][j][l][m][n] < 0L)
                continue;

              foreach (d; 0 .. 10) {
                if (k == 0 && d > ni)
                  continue;
                if (n == 0 && l == 1 && j == d)
                  continue;
                if (n == 1 && j <= d)
                  continue;
                if (n == 2 && j >= d)
                  continue;

                int nk = cast(int)(k == 1 || d < ni);
                int nj = d;
                int nl = cast(int)(l == 1 || d > 0);
                int nm = d * mpow(10L, i - 1L, M);
                nm %= M;
                nm += m;
                nm %= M;
                int nn;
                if (n == 0) {
                  if (l == 0)
                    nn = 0;
                  else if (l == 1 && j < d)
                    nn = 1;
                  else
                    nn = 2;
                } else if (n == 1)
                  nn = 2;
                else
                  nn = 1;

                dp[0][nk][nj][nl][nm][nn] =
                  max(0L, dp[0][nk][nj][nl][nm][nn]) + dp[1][k][j][l][m][n];
                dp[0][nk][nj][nl][nm][nn] %= 10_000L;
              }
            }

    foreach (k; 0 .. 2)
      foreach (j; 0 .. 10)
        foreach (l; 0 .. 2)
          foreach (m; 0 .. M)
            foreach (n; 0 .. 3) {
              dp[1][k][j][l][m][n] = dp[0][k][j][l][m][n];
              dp[0][k][j][l][m][n] = -1L;
            }
  }

  long ret0 = 0L, ret1 = 0L;
  foreach (j; 0 .. 10)
    foreach (l; 0 .. 2)
      foreach (n; 0 .. 3) {
        if (dp[1][0][j][l][0][n] >= 0L) {
          ret0 += dp[1][0][j][l][0][n];
          ret0 %= 10_000L;
        }
        if (dp[1][1][j][l][0][n] >= 0L) {
          ret1 += dp[1][1][j][l][0][n];
          ret1 %= 10_000L;
        }
      }

  return tuple(ret0, ret1);
}

void main () {
  string A = readln.chomp;
  string B = readln.chomp;
  int M = readln.chomp.to!int;

  auto retA = calc(A, M);
  auto retB = calc(B, M);

  long ret = retB[0] + retB[1] - retA[1];
  ret += 10_000L;
  ret %= 10_000L;
  writeln(ret);
}

