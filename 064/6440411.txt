#include <cmath>
#include <cstdio>
#include <algorithm>
using namespace std;

//acos返回0~pi，asin返回-pi/2~pi/2。精度不好所以不用
namespace geo_2d{
const double eps=1e-9;
struct V{  //向量及其运算才是几何基础，点也可以用向量表示
    double x, y;
    V():x(0),y(0){}
    V(const V &a){ *this=a; }
    V(const double &a, const double &b):x(a),y(b){}
    void read(){ scanf("%lf%lf", &x, &y); }
    void print(){ printf("%.9lf %.9lf\n", x, y); }  //位数多精度高
    void print_int(){ printf("%d %d\n", (int)x, (int)y); }
}O;  //三个vector参数abc表示以a为顶点的角bac/cab
inline double sqr(const double &x){ return x*x; }
inline bool zero(const double &x){ return abs(x)<eps; }
inline bool equal(const double &a, const double &b){ return zero(a-b); }
inline bool less(const double &a, const double &b){ return a<b-eps; }
inline bool greater(const double &a, const double &b){ return a>b+eps; }
inline V operator+(const V &a, const V &b){ return V(a.x+b.x, a.y+b.y); }
inline V operator-(const V &a, const V &b){ return V(a.x-b.x, a.y-b.y); }
inline V operator*(const double &x, const V &a){ return V(a.x*x, a.y*x); }
inline V operator*(const V &a, const double &x){ return V(a.x*x, a.y*x); }
inline V operator/(const V &a, const double &x){ return V(a.x/x, a.y/x); }
inline bool operator==(const V &a, const V &b){ return equal(a.x, b.x)&&equal(a.y, b.y);}
inline bool operator!=(const V &a, const V &b){ return !(a==b); }
inline double operator*(const V &a, const V &b){ return a.x*b.x+a.y*b.y; }
inline double operator^(const V &a, const V &b){ return a.x*b.y-a.y*b.x; }
inline double len(const V &a){ return sqrt(a.x*a.x+a.y*a.y); }
inline double dis(const V &a, const V &b){ return len(a-b); }
inline V mid(const V &a, const V &b){ return V((a.x+b.x)/2, (a.y+b.y)/2); }
inline V c_wise(const V &a){ return V(a.y, -a.x); }
inline V unit(const V &a){ return a/len(a); }
inline double S_tri(const V &a, const V &b, const V &c){ return abs((b-a)^(c-a))/2; }
inline bool operator<(const V &a, const V&b){  //二元组排序
    return less(a.x, b.x)||(equal(a.x, b.x)&&less(a.y, b.y));
}
inline double angle(const V &a, const V &b){ return acos(a*b/len(a)/len(b)); }  //0~pi
inline double angle2(const V &a, const V &b){  //-pi~pi，叉乘决定符号，与向量顺序有关
    return (a^b)>=0?angle(a, b):-angle(a, b);
}
inline bool obtuse(const V &a, const V &b, const V &c){ return less((b-a)*(c-a), 0); }
inline bool acute(const V &a, const V &b, const V &c){ return greater((b-a)*(c-a), 0); }
inline bool right(const V &a, const V &b, const V &c){ return zero((b-a)*(c-a)); }
inline V rotate(const V &a, double theta){
    double s=sin(theta), c=cos(theta);
    return V(a.x*c-a.y*s, a.x*s+a.y*c);
}
struct L{  //记录单位方向向量+两点，也可以用来表示线段
    V d, a, b;
    L(){}
    L(const V &x1, const V &x2, const V &x3):d(x1),a(x2),b(x3){}
    L(const V &x, const V &y){ *this=L(unit(y-x), x, y); }
};
inline V project(const V &p, const L &l){
    return l.a+((p-l.a)*l.d)*l.d;
}
inline V reflect(const V &p, const L &l){
    return 2*project(p, l)-p;
}
inline bool on_line(const V &p, const L &l){
    return zero(l.d^(p-l.a));
}
inline bool on_seg(const V &p, const L &l){
    return zero(dis(p, l.a)+dis(p, l.b)-dis(l.a, l.b));
}
inline double dis(const V &p, const L &l){
    return abs((p-l.a)^(p-l.b))/dis(l.a, l.b);
}
inline bool collinear(const V &a, const V &b){ return zero(a^b); }
inline bool orthogonal(const V &a, const V &b){ return zero(a*b); }
inline bool parallel(const L &l1, const L &l2){ return zero(l1.d^l2.d); }
inline bool orthogonal(const L &l1, const L &l2){ return zero(l1.d*l2.d); }
inline bool is_intersect(const L &l1, const L &l2){
    if (greater(min(l1.a.x, l1.b.x), max(l2.a.x, l2.b.x))||
        less(max(l1.a.x, l1.b.x), min(l2.a.x, l2.b.x))||
        greater(min(l1.a.y, l1.b.y), max(l2.a.y, l2.b.y))||
        less(max(l1.a.y, l1.b.y), min(l2.a.y, l2.b.y)))
            return false;
    //以上是快速排斥
    double f1=(l1.a-l2.a)^l2.d;
    double f2=(l1.b-l2.a)^l2.d;
    double f3=(l2.a-l1.a)^l1.d;
    double f4=(l2.b-l1.a)^l1.d;
    if (f1*f2<eps&&f3*f4<eps) return true;
    else return false;
}  //先考虑l1跨立在l2上，再考虑l2跨立在l1上
inline V intersection(const L &l1, const L &l2){
    double k=((l2.a-l1.a)^l2.d)/(l1.d^l2.d);
    return l1.a+k*l1.d;
}
inline L bisector(const V &a, const V &b, const V &c){  //angleBAC
    V d1=(b-a)/len(b-a), d2=(c-a)/len(c-a);
    V d=(d1+d2)/len(d1+d2);
    return L(d, a, a+d);
}
inline L perpendicular(const V &a, const V &b){
    V x=mid(a, b), d=unit(c_wise(b-a));
    return L(d, x, x+d);
}
//为方便操作直接传数组，以O为原点
inline double S(const V *a, const int &n){
    double res=0;
    for (int i=0; i<n; ++i) res+=(a[i]^a[(i+1)%n]);
    return res/2;
}
inline void read_convex(V *a, int &n){
    scanf("%d", &n);
    for (int i=0; i<n; ++i) a[i].read();
}
inline bool is_convex(const V *a, const int &n){
    int j, k, d=0, nd; double o;
    for (int i=0; i<n; ++i){
        j=(i+1)%n, k=(i+2)%n;
        o=(a[j]-a[i])^(a[k]-a[j]);
        if (zero(o)) continue;
        nd=less(o, 0)?-1:1;
        if (!d) d=nd;
        else if (d!=nd) return false;
    }
    return true;
}
inline bool in_convex(const V &p, const V *a, const int &n){
    double x; int j, res=0;
    for (int i=0; i<n; ++i){
        j=(i+1)%n;
        if (equal(a[i].y, a[j].y)) continue;
        if (less(max(a[i].y, a[j].y), p.y)) continue;
        if (!less(min(a[i].y, a[j].y), p.y)) continue;
        x=a[i].x+(p.y-a[i].y)/(a[j].y-a[i].y)*(a[j].x-a[i].x);
        if (x<p.x) res^=1;
    }
    return res?true:false;
}
inline bool cmp(const V &a, const V &b){  //极角排序比较函数
    double dot=(a-O)^(b-O);
    if (dot>0) return true;
    if (dot==0) return dis(a, O)<dis(b, O);  //全共线情况
    return false;
}
inline void polar_sort(V *a, const int &n){
    int id=0;
    for (int i=0; i<n; ++i)
        if (less(a[i].y, a[id].y)||
                equal(a[i].y, a[id].y)&&less(a[i].x, a[id].x)) id=i;
    O=a[id];
    sort(a, a+n, cmp);
    int m;  //最后的共线部分要反转
    for (m=n-1; m>0; --m) if (!zero((a[m]-a[0])^(a[n-1]-a[0]))) break;
    reverse(a+m+1, a+n);
    O=V(0, 0);
}
inline void graham(V *a, int &n, bool include_on_edge){
    polar_sort(a, n); int cnt=0, id1, id2;
    int *s=new int[n];
    for (int i=0; i<n; ++i){
        while (cnt>=2){
            id1=s[cnt-1]; id2=s[cnt-2];
            if (include_on_edge){
                if (!less((a[id1]-a[id2])^(a[i]-a[id1]), 0)) break;
            } else if (greater((a[id1]-a[id2])^(a[i]-a[id1]), 0)) break;
            --cnt;
        }
        s[cnt++]=i;
    }
    n=cnt;
    for (int i=0; i<n; ++i) a[i]=a[s[i]];
}
double height(const V &a, const V &b1, const V &b2){
    return S_tri(a, b1, b2)/dis(b1, b2);
}
inline double diameter(const V *a, int &n){
    double ans=0; int j=0;
    for (int i=0; i<n; ++i){
        while ((height(a[i], a[j], a[(j+1)%n]))<height(a[i], a[(j+1)%n], a[(j+2)%n]))
            j=(j+1)%n;
        ans=max(ans, dis(a[i], a[j]));
        ans=max(ans, dis(a[i], a[(j+1)%n]));
    }
    return ans;
}
}

using namespace geo_2d;

const int maxn=1e5+5;
int n, m;
V a[maxn], p;

int main(){
    read_convex(a, n);
    printf("%.9lf", diameter(a, n));
    return 0;
}
