#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

const int N = 501;
const int inf = 1e9;
int len[N][N];
pair<int,int> dp[N][N];
pair<int,int> pre[N][N];
bool valid_pre[N][10][10];
bool valid_bac[N][10][10];

void init(string s){
    int n = s.size();
    for(int i=0;i<=n;i++){
        for(int a=0;a<10;a++){
            for(int l=0;l<10;l++){
                if(a == 0){
                    if(i+1<=n and s[i]-'0' == l){
                        valid_pre[i][a][l] = 1;
                    }
                }
                else if(l == 0){
                    valid_pre[i][a][l] = 1;
                }
                else{
                    if(a <= i and i+l<=n){
                        bool ok = true;
                        for(int j=0;j<l;j++){
                            if(s[i+j] != s[i+j-a]){
                                ok = false; break;
                            }
                        }
                        if(ok){
                            valid_pre[i][a][l] = 1;
                        }
                    }
                }
            }
        }
    }

    for(int i=0;i<=n;i++){
        for(int a=0;a<10;a++){
            for(int l=0;l<10;l++){
                if(l == 0){
                    if(i+1<=n and s[n-1-i]-'0' == a){
                        valid_bac[i][a][l] = 1;
                    }
                }
                else if(a == 0){
                    valid_bac[i][a][l] = 1;
                }
                else{
                    if(i+a <= n and n-1-i-a+1 >= l){
                        bool ok = true;
                        for(int j=0;j<a;j++){
                            if(s[n-1-i-j] != s[n-1-i-j-l]){
                                ok = false; break;
                            }
                        }
                        if(ok){
                            valid_bac[i][a][l] = 1;
                        }
                    }
                }
            }
        }
    }

    for(int i=0;i<=n;i++){
        for(int j=0;j<=n;j++){
            len[i][j] = inf;
        }
    }
    len[0][0] = 0;
}

int add(int &a,int &l){
    if(a == 0)return 1;
    else return l;
}

void solve(string s){
    int n = s.size();
    queue<pair<int,int>> q;
    q.push({0,0});
    while(q.size()){
        auto p = q.front(); q.pop();
        int x = p.first, y = p.second;
        if(x == n and y == n)break;
        // cout << x << " " << y << " " << dp[x][y] << endl;
        for(int a=0;a<10;a++){
            for(int l=0;l<10;l++){
                if(valid_pre[x][a][l] and valid_bac[y][a][l]){
                    int nx = x+add(a,l);
                    int ny = y+add(l,a);
                    if(len[nx][ny] == inf){
                        len[nx][ny] = len[x][y]+1;
                        dp[nx][ny] = {a,l};
                        pre[nx][ny] = {x,y};
                        q.push({nx,ny});
                    }
                }
            }
        }
    }
}

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    string s; cin >> s;
    int n = s.size();
    init(s);
    solve(s);
    string res = "";
    pair<int,int> cur = {n,n};
    while(cur.first != 0 or cur.second != 0){
        res += (char)dp[cur.first][cur.second].second + '0';
        res += (char)dp[cur.first][cur.second].first + '0';
        cur = pre[cur.first][cur.second];
    }
    reverse(res.begin(), res.end());
    cout << res << endl;
}

