import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
// const long mod = 1_000_000_000 + 7;
const long mod = 998_244_353L;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

int N;
long[] cs, ws;
long[] ss;
long[][] ttl;
int[][] check;

int rec1 (int l, int r) {
  if (check[l][r] != -1)
    return check[l][r];
  if (r == l + 1) {
    check[l][r] = 1;
    return check[l][r];
  }
  if (r < l + 1) {
    check[l][r] = 0;
    return check[l][r];
  }

  if (rec1(l + 1, r) == 1 && cs[l] >= ttl[l + 1][r])
    check[l][r] = 1;
  else if (rec1(l, r - 1) == 1 && cs[r - 1] >= ttl[l][r - 1])
    check[l][r] = 1;
  else
    check[l][r] = 0;

  return check[l][r];
}

long[] dp;
long rec2 (int i) {
  if (dp[i] != INF)
    return dp[i];
  if (check[0][i] == 1) {
    dp[i] = 1L;
    return dp[i];
  }
  foreach (k; 1 .. i)
    if (check[k][i] == 1)
      chmin (dp[i], rec2(k) + 1L);

  return dp[i];
}

void main () {
  N = readln.chomp.to!int;
  cs = new long[](N);
  ws = new long[](N);
  ss = new long[](N);
  ttl = new long[][](N + 1, N + 1);
  foreach (i; 0 .. N)
    readf ("%s %s\n", &(cs[i]), &(ws[i]));
  foreach (i; 0 .. N)
    if (i == 0)
      ss[i] = ws[i];
    else
      ss[i] = ss[i - 1] + ws[i];
  foreach (i; 0 .. N + 1)
    foreach (j; i + 1 .. N + 1)
      if (i == 0)
        ttl[i][j] = ss[j - 1];
      else
        ttl[i][j] = ss[j - 1] - ss[i - 1];

  // 1段階目: 区間[l,r)を1つにまとめることができるか
  check = new int[][](N + 1, N + 1);
  foreach (i; 0 .. N + 1)
    foreach (j; 0 .. N + 1)
      check[i][j] = -1;
  rec1(0, N);

  // 2段階目: 全体で最小何人になるか
  dp = new long[](N + 1);
  foreach (i; 0 .. N + 1)
    dp[i] = INF;
  long ret = rec2(N);
  writeln(ret);
}

