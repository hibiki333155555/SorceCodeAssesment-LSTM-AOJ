#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int,long long> pil;
typedef pair<long long,int> pli;
const int MAX_V = 100, MAX_E = 9900;
const long long INF = 0x3f3f3f3f3f3f3f3fLL;

vector<pil> G[MAX_V+1];
long long dist[MAX_V+1][MAX_V+1];
long long h[MAX_V+1];

void add_edge(int u,int v,long long c){
    G[u].push_back(make_pair(v,c));
}

bool used[MAX_V+1];
long long d[MAX_V+1];
priority_queue<pli> que;
bool relax(int u,int v,long long c){
    if(d[v] > d[u]+c && d[u] != INF){
        d[v] = d[u]+c;
        return true;
    }
    return false;
}
bool bellman_ford(int s, int V){
    for (int v = 0; v < V; ++v) d[v] = INF;
    d[s] = 0;
    for (int i = 0; i < V; ++i){
        bool is_updated = false;
        for (int u = 0; u < V; ++u)
            for (int i = 0; i < G[u].size(); ++i){
                pil p = G[u][i];
                int v = p.first;	long long c = p.second;
                if(relax(u,v,c))    is_updated = true;
            }
        if(i == V-1 && is_updated) return true;
    }
    return false;
}

void dijkstra(int s, int V){
    for (int v = 0; v < V; ++v) d[v] = INF, used[v] = false;
    d[s] = 0;
    que.push(pli(-d[s],s));

    while(!que.empty()){
        pli p = que.top();    que.pop();
        int u = p.second;   long long du = -p.first;

        if(used[u] || du > d[u])    continue;
        used[u] = true;

        for (int i = 0; i < G[u].size(); ++i){
            pil  p = G[u][i];
            int v = p.first;
            long long d_uv = p.second+h[u]-h[v];
            if(relax(u,v,d_uv))
                que.push(pli(-d[v],v));
        }
    }
}


bool johnson(int V){
    int s = V;
    for (int v = 0; v < V; ++v)
        if(v != s)   add_edge(s,v,0);
    if(bellman_ford(s,V+1))   return true;
    for (int v = 0; v < V; ++v) h[v] = d[v];
    for (int v = 0; v < V; ++v){
		//printf("d[%d]=%lld\n",v,d[v]);
	}
    for (int s = 0; s < V; ++s){
        dijkstra(s,V);
		for (int v = 0; v < V; ++v){
			if(d[v] == INF)	dist[s][v] = INF;
			else			dist[s][v] = d[v]-h[s]+h[v];
		}
	}
	return false;
}

const char NEG_CYCLE[] = "NEGATIVE CYCLE";

int main(){
	int V,E;	scanf("%d%d",&V,&E);
	for (int i = 0; i < E; ++i){
		int s,t,d;
		scanf("%d%d%d",&s,&t,&d);
		add_edge(s,t,d);
	}
	if(johnson(V))	puts(NEG_CYCLE);
	else{
		for (int u = 0; u < V; ++u){
			for (int v = 0; v < V; ++v){
				if(dist[u][v] == INF)	printf("INF%c"," \n"[v==V-1]);
				else				printf("%lld%c",dist[u][v], " \n"[v==V-1]);
			}
		}
	}
}


