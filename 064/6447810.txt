#include <bits/stdc++.h>

using namespace std;
using ll = long long;

// UnionFindで素集合を管理するクラス
// 同一グループ判定、結合をおよそO(log N)（実際にはずっと速く定数時間に近い）でできる
// ノードIDは1-indexed
// @ref https://www.slideshare.net/chokudai/union-find-49066733/1
class UnionFind {
  public:
   UnionFind(const size_t N);

   // node_1とnode_2が所属する集合を結合する(Union by size)
   // 計算量: O(almost 1)
   void Unite(size_t node_1, size_t node_2);

   // node_1とnode_2が同じ集合に入っているか
   // 計算量: O(almost 1)
   bool IsSameGroup(size_t node_1, size_t node_2);

   // nodeが所属する集合のサイズを返す
   // 計算量: O(almost 1)
   size_t size(size_t node);

   // 各グループのサイズを返す
   // @param group_size_list: (グループのサイズ、グループの親ノード)ペアのリスト
   // 計算量: O(N)
   void GroupSize(vector<pair<long long, size_t>>* group_size_list);

  private:
   // nodeの親のnode_idを返す
   size_t root(size_t node);

   // parent_node_id_[i]: 親ノードのノードID, rootの場合はparent_node_id_[i] ==
   // iになる
   vector<size_t> parent_node_id_;

   // tree_size_[i]: ルートノードiに含まれる集合のサイズ
   vector<size_t> tree_size_;
};

UnionFind::UnionFind(const size_t N)
    : parent_node_id_(N + 1), tree_size_(N + 1, 1) {
   // 全ノードをrootで初期化する
   for (size_t i = 0; i <= N; i++) {
      parent_node_id_[i] = i;
   }
}

size_t UnionFind::root(size_t node) {
   // ルートノード以外のノードを記録し直接、親ノードをルートノードにつなぎ変える(経路圧縮)
   vector<size_t> internal_nodes;

   while (parent_node_id_[node] != node) {
      internal_nodes.push_back(node);
      node = parent_node_id_[node];
   }

   for (auto n : internal_nodes) {
      parent_node_id_[n] = node;
   }

   return node;
}

bool UnionFind::IsSameGroup(size_t node_1, size_t node_2) {
   auto parent_1 = root(node_1);
   auto parent_2 = root(node_2);

   return parent_1 == parent_2;
}

void UnionFind::Unite(size_t node_1, size_t node_2) {
   if (IsSameGroup(node_1, node_2)) {
      // すでに同じ木の場合は何もしない
      return;
   }

   // サイズの小さい方を大きいにつなぐ
   auto size_1 = size(node_1);
   auto size_2 = size(node_2);

   size_t union_from = node_1, union_to = node_2;

   if (size_1 > size_2) {
      union_from = node_2;
      union_to = node_1;
   }
   auto parent_from = root(union_from);
   auto parent_to = root(union_to);

   parent_node_id_[parent_from] = parent_to;
   tree_size_[parent_to] = tree_size_[parent_to] + tree_size_[parent_from];
}

size_t UnionFind::size(size_t node) {
   auto parent = root(node);
   return tree_size_[parent];
}

void UnionFind::GroupSize(vector<pair<long long, size_t>>* group_size_list) {
   group_size_list->clear();

   for (size_t i = 1; i < parent_node_id_.size(); i++) {
      if (parent_node_id_[i] != i) {
         continue;
      }

      group_size_list->emplace_back(size(i), i);
   }
}

// Gridの上下左右の定義
vector<pair<long long, long long>> dir_list = {
    make_pair(-1, 0),  // 上
    make_pair(1, 0),   // 下
    make_pair(0, -1),  // 左
    make_pair(0, 1),   // 右

    make_pair(-1, -1),  //
    make_pair(1, -1),   //
    make_pair(-1, 1),   //
    make_pair(1, 1)     //
};

// 指定された位置がグリッド内かチェックする
bool InGrid(long long H, long long W, const pair<long long, long long>& p) {
   bool in_grid = 1 <= p.first && p.first <= H;
   in_grid &= 1 <= p.second && p.second <= W;

   return in_grid;
}

int main() {
   cout << fixed << setprecision(15);

   while (true) {
      int w, h;
      cin >> w >> h;

      if (w == 0 && h == 0) {
         break;
      }

      // H行W列, grid[i][j]: 上からi行目左からj列目の要素
      vector<vector<int>> grid(h + 1, vector<int>(w + 1));

      for (ll i = 1; i <= h; i++) {
         for (ll j = 1; j <= w; j++) {
            int c;
            cin >> c;

            grid[i][j] = c;
         }
      }

      UnionFind uf(w * h);

      for (ll i = 1; i <= h; i++) {
         for (ll j = 1; j <= w; j++) {
            int index = (i - 1) * w + j;

            if (grid[i][j] == 0) {
               continue;
            }

            for (auto dir : dir_list) {
               ll n_i = i + dir.first;
               ll n_j = j + dir.second;

               if (!InGrid(h, w, {n_i, n_j})) {
                  continue;
               }

               if (grid[n_i][n_j] == 0) {
                  continue;
               }

               int n_index = (n_i - 1) * w + n_j;

               if (uf.IsSameGroup(index, n_index)) {
                  continue;
               }

               uf.Unite(index, n_index);
            }
         }
      }

      vector<pair<ll, size_t>> group_info;
      uf.GroupSize(&group_info);

      int island_count = 0;

      for (auto group : group_info) {
         auto [size, node] = group;
         int i = (node - 1) / w + 1;
         int j = (node - 1) % w + 1;

         if (grid[i][j] == 1) {
            island_count++;
         }
      }

      cout << island_count << endl;
   }

   return 0;
}

