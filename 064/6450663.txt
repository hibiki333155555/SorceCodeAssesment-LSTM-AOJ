#include <algorithm>
#include <complex>
#include <cstdlib>
#include <ctime>
#include <time.h>
#include <iomanip>
#include <iostream>
#include <map>
#include <math.h>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
#include <numeric>
#include <limits>
#include <type_traits>
#include <locale>
#include <omp.h>
#include <string.h>
#include <bitset>
#include <unordered_map>

using namespace std;

#define SAY_YES cout << "YES" << endl;
#define SAY_Yes cout << "Yes" << endl;
#define SAY_NO cout << "NO" << endl;
#define SAY_No cout << "No" << endl;
#define IFYES(TRUE_OR_FALSE)   \
    if (TRUE_OR_FALSE)         \
    {                          \
        cout << "YES" << endl; \
    }                          \
    else                       \
    {                          \
        cout << "NO" << endl;  \
    }
#define IFYes(TRUE_OR_FALSE)   \
    if (TRUE_OR_FALSE)         \
    {                          \
        cout << "Yes" << endl; \
    }                          \
    else                       \
    {                          \
        cout << "No" << endl;  \
    }
#define IFyes(TRUE_OR_FALSE)   \
    if (TRUE_OR_FALSE)         \
    {                          \
        cout << "yes" << endl; \
    }                          \
    else                       \
    {                          \
        cout << "no" << endl;  \
    }
#define DEBUG_OUTPUT_ARRAY(XXX, ONE)                            \
    for (int i = 0; i < (ONE); i++)                             \
    {                                                           \
        cout << "DEBUG: i = " << i << " -> " << XXX[i] << endl; \
    }
#define DEBUG_OUTPUT_ARRAY2(XXX, ONE, TWO)                             \
    for (int i = 0; i < (ONE); i++)                                    \
    {                                                                  \
        cout << "<<< i = " << i << " >>>" << endl;                     \
        for (int j = 0; j < (TWO); j++)                                \
        {                                                              \
            cout << "DEBUG: j = " << j << " -> " << XXX[i][j] << endl; \
        }                                                              \
    }
#define DEBUG_OUTPUT_ARRAY2_BOX(XXX, ONE, TWO) \
    for (int i = 0; i < (ONE); i++)            \
    {                                          \
        cout << i << "  ";                     \
        for (int j = 0; j < (TWO); j++)        \
        {                                      \
            cout << XXX[i][j] << " ";          \
        }                                      \
        cout << endl;                          \
    }

#define ALL(XXX) (XXX).begin(),(XXX).end()

template<class T>
vector<T> make_vec(size_t a) {
    return vector<T>(a);
}

template<class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}

typedef pair<long long int, long long int> pll;
typedef pair<long long int, pll> lpll;


bool overflow_checker(long long int input_number1, long long int input_number2) {
    if (5000000000000000000 / input_number1 < input_number2) {
        return true;
    } else {
        return false;
    }
}


class Gyouretu {
public:
    //行列の行数
    long long int h_;
    //行列の列数
    long long int w_;
    //行列内のmod
    long long int mod_;
    //行列のデータ(二次元vector)
    vector<vector<long long int>> val_;

    Gyouretu() {

    }

    //H*Wで行列(mod)を作成
    Gyouretu(long long int h_input_, long long int w_input_, long long int mod_input_ = (1LL << 62)) {
        h_ = h_input_;
        w_ = w_input_;
        vector<vector<long long int> > val_tmp_(h_, vector<long long int>(w_));
        val_ = val_tmp_;
        mod_ = mod_input_;
    }

    //H*Wで行列(mod)を作成
    Gyouretu(long long int h_input_, long long int w_input_, vector<vector<long long int> > val_input_,
             long long int mod_input_ = (1LL << 62)) {
        h_ = h_input_;
        w_ = w_input_;
        val_ = val_input_;
        mod_ = mod_input_;
    }

    //N*N単位行列
    Gyouretu IdentityGyouretu(long long int n_input_, long long int mod_input_ = (1LL << 62)) {
        h_ = n_input_;
        w_ = n_input_;
        vector<vector<long long int> > val_tmp_(h_, vector<long long int>(w_));
        val_ = val_tmp_;
        mod_ = mod_input_;
        for (long long int i = 0; i < h_; i++) {
            for (long long int j = 0; j < w_; j++) {
                if (i == j) {
                    val_[i][j] = 1;
                } else {
                    val_[i][j] = 0;
                }
            }

        }
        return *this;
    }

    //行列間の和
    Gyouretu operator+(Gyouretu &gyouretu_tmp_) {
        if (this->h_ == gyouretu_tmp_.h_ && this->w_ == gyouretu_tmp_.w_) {
            Gyouretu gyouretu_return_(this->h_, this->w_, this->val_, this->mod_);
            for (long long int i = 0; i < this->h_; i++) {
                for (long long int j = 0; j < this->w_; j++) {
                    gyouretu_return_.val_[i][j] = this->val_[i][j] + gyouretu_tmp_.val_[i][j];
                    gyouretu_return_.val_[i][j] %= mod_;
                }
            }
            return gyouretu_return_;
        } else {
            cout << "+ Gyouretu Size Error!" << endl;
            return *this;
        }
    }

    Gyouretu operator+=(Gyouretu &gyouretu_tmp_) {
        if (this->h_ == gyouretu_tmp_.h_ && this->w_ == gyouretu_tmp_.w_) {
            for (long long int i = 0; i < this->h_; i++) {
                for (long long int j = 0; j < this->w_; j++) {
                    this->val_[i][j] = this->val_[i][j] + gyouretu_tmp_.val_[i][j];
                    this->val_[i][j] %= mod_;
                }
            }
            return *this;
        } else {
            cout << "+= Gyouretu Size Error!" << endl;
            return *this;
        }
    }

    //行列間の積
    Gyouretu operator*(Gyouretu &gyouretu_tmp_) {
        if (this->w_ == gyouretu_tmp_.h_) {
            Gyouretu gyouretu_return_(this->h_, gyouretu_tmp_.w_, this->mod_);
            for (long long int i = 0; i < this->h_; i++) {
                for (long long int j = 0; j < gyouretu_tmp_.w_; j++) {
                    gyouretu_return_.val_[i][j] = 0;
                    for (long long int k = 0; k < this->w_; k++) {
                        gyouretu_return_.val_[i][j] += this->val_[i][k] * gyouretu_tmp_.val_[k][j];
                        gyouretu_return_.val_[i][j] %= mod_;
                    }
                }
            }
            return gyouretu_return_;
        } else {
            cout << "* Gyouretu Size Error!" << endl;
            return *this;
        }
    }

    Gyouretu operator*=(Gyouretu &gyouretu_tmp_) {
        if (this->w_ == gyouretu_tmp_.h_) {
            Gyouretu gyouretu_return_(this->h_, gyouretu_tmp_.w_, this->mod_);
            for (long long int i = 0; i < this->h_; i++) {
                for (long long int j = 0; j < gyouretu_tmp_.w_; j++) {
                    gyouretu_return_.val_[i][j] = 0;
                    for (long long int k = 0; k < this->w_; k++) {
                        gyouretu_return_.val_[i][j] += this->val_[i][k] * gyouretu_tmp_.val_[k][j];
                        gyouretu_return_.val_[i][j] %= this->mod_;
                    }
                }
            }
            *this = gyouretu_return_;
            return *this;
        } else {
            cout << "* Gyouretu Size Error!" << endl;
            return *this;
        }
    }

    Gyouretu Pow(Gyouretu a_, long long int b_) {
        Gyouretu r_;

        r_ = r_.IdentityGyouretu(a_.h_, a_.mod_);
        while (b_ > 0) {
            if (1 & b_) {
                r_ *= a_;
            }
            a_ *= a_;
            b_ = (b_ >> 1);
        }
        return r_;
    }
};


//和(整数、文字列を右なら可能)
//差(整数、文字列を右なら可能)
//積(整数、文字列を右なら可能)
//商(まだ)
//剰余(まだ)
class BigInt {
private:
//[y_,z_)ブロックのデータを引っこ抜いてくる
BigInt BlockCut(BigInt &x_,long long int y_,long long int z_){

    BigInt ret_(z_-y_,1);
    for (long long int i_ = y_; i_ < z_; i_++)
    {
        ret_.data_[i_-y_]=x_.data_[i_];
    }
    
    return ret_;
}
//y_だけx_からシフト
BigInt BlockShift(BigInt &x_,long long int y_){
    BigInt ret_(x_.block_size_+y_,1);
    for (long long int i_ = max(0LL,y_); i_ < x_.block_size_+y_; i_++)
    {
        ret_.data_[i_]=x_.data_[i_-y_];
    }
    return ret_;
}
public:
    //プラスマイナス
    long long int pm_=1;
    vector<long long int>data_;
    long long int mod_=1000000000;
    long long int keta_=9;
    long long int block_size_=0;
    BigInt() {
    }
    //type==0は通常に構成、type==1はN個のブロックを用意
    BigInt(long long int N_,long long int type_=0) {
        if(type_==1){
            data_=vector<long long int>(N_,0);
            block_size_=N_;
        }else{
            *this=StringToBigInt(to_string(N_));
        }
    }

    //stringで巨大整数を作成
    BigInt(string S_) {
        *this=StringToBigInt(S_);
    }
    
    BigInt StringToBigInt(string S_){
        BigInt bi_;
        if(S_[0]=='-'){
            bi_.data_=vector<long long int>((S_.size()+bi_.keta_-2)/bi_.keta_);
            bi_.pm_=-1;
            long long int now_=0,last_=S_.size();
            for (long long int i_ = S_.size()-bi_.keta_; i_ >=1; i_-=bi_.keta_)
            {
                bi_.data_[now_]=stoll(S_.substr(i_,bi_.keta_));
                now_++;
                last_=i_;
            }
            if(last_!=1){
                bi_.data_[now_]=stoll(S_.substr(1,last_-1));
            }
        }else{
            bi_.data_=vector<long long int>((S_.size()+bi_.keta_-1)/bi_.keta_);
            long long int now_=0,last_=S_.size();
            for (long long int i_ = S_.size()-bi_.keta_; i_ >=0; i_-=bi_.keta_)
            {
                bi_.data_[now_]=stoll(S_.substr(i_,bi_.keta_));
                now_++;
                last_=i_;
            }
            if(last_!=0){
                bi_.data_[now_]=stoll(S_.substr(0,last_));
            }
        }
        bi_.block_size_=bi_.data_.size();
        return bi_;
    }

    void Output(BigInt X_){
        
        cout<<BigIntToString(X_);
        
    }
    string BigIntToString(BigInt X_){
        string ret_;
        if(X_.block_size_==0){return "0";}
        if(X_.pm_==-1){ret_.push_back('-');}
        
        ret_+=to_string(X_.data_[X_.block_size_-1]);
        
        for (long long int i_ = X_.block_size_-2; i_ >=0; i_--)
        {
            string tmp_=to_string(X_.data_[i_]);
            ret_+=string(keta_-tmp_.size(),'0')+tmp_;
        }
        return ret_;
    }

    
    //BigIntの和
    BigInt operator+(BigInt big_int_tmp_) {
        BigInt big_int_return_(max(this->block_size_,big_int_tmp_.block_size_),1);
        if(this->pm_==big_int_tmp_.pm_){
            big_int_return_.pm_=this->pm_;
            for (long long int i_ = 0; i_ < big_int_return_.block_size_; i_++)
            {
                if(i_<(this->block_size_))big_int_return_.data_[i_]+=this->data_[i_];
                if(i_<(big_int_tmp_.block_size_))big_int_return_.data_[i_]+=big_int_tmp_.data_[i_];
            }
            for (long long int i_ = 0; i_ < big_int_return_.block_size_-1; i_++)
            {
                if(big_int_return_.data_[i_]>=mod_){
                    big_int_return_.data_[i_]-=mod_;
                    big_int_return_.data_[i_+1]++;
                }
            }
            if(big_int_return_.data_[big_int_return_.block_size_-1]>=mod_){
                big_int_return_.data_[big_int_return_.block_size_-1]-=mod_;
                big_int_return_.data_.push_back(1);
                big_int_return_.block_size_++;
            }
            return big_int_return_;
        }else{
            big_int_return_.pm_=this->pm_;
            for (long long int i_ = 0; i_ < big_int_return_.block_size_; i_++)
            {
                if(i_<(this->block_size_))big_int_return_.data_[i_]+=this->data_[i_];
                if(i_<(big_int_tmp_.block_size_))big_int_return_.data_[i_]-=big_int_tmp_.data_[i_];
            }
            //先頭の桁が負なら全体をひっくり返す
            for (long long int i_ = big_int_return_.block_size_-1; i_ >=0; i_--)
            {
                if(big_int_return_.data_[i_]>0){
                    big_int_return_.block_size_=i_+1;
                    break;
                }else if(big_int_return_.data_[i_]<0){
                    big_int_return_.block_size_=i_+1;
                    big_int_return_.pm_=-big_int_return_.pm_;
                    for (long long int j_ = i_; j_ >=0; j_--)
                    {
                        big_int_return_.data_[j_]=-big_int_return_.data_[j_];
                    }
                    break;
                }
                if(i_==0){big_int_return_.block_size_=0;}
            }
            for (long long int i_ = 0; i_ < big_int_return_.block_size_-1; i_++)
            {
                if(big_int_return_.data_[i_]<0){
                    big_int_return_.data_[i_]+=mod_;
                    big_int_return_.data_[i_+1]--;
                }
            }
            if(big_int_return_.data_[big_int_return_.block_size_-1]==0){
                big_int_return_.block_size_--;
            }
            return big_int_return_;
        }
    }
    
    BigInt operator+(string S_) {
        return *this+StringToBigInt(S_);
    }
    
    BigInt operator+(long long int i_) {
        return *this+StringToBigInt(to_string(i_));
    }
    BigInt operator+=(BigInt big_int_tmp_) {
        *this=*this+big_int_tmp_;
        return *this;
    }
    BigInt operator+=(string S_) {
        *this+=StringToBigInt(S_);
        return *this;
    }
    BigInt operator+=(long long int i_) {
        *this+=StringToBigInt(to_string(i_));
        return *this;
    }
    //BigIntの差
    BigInt operator-(BigInt big_int_tmp_) {
        big_int_tmp_.pm_=-big_int_tmp_.pm_;
        return *this+big_int_tmp_;
    }
    
    BigInt operator-(string S_) {
        return *this-StringToBigInt(S_);
    }
    
    BigInt operator-(long long int i_) {
        return *this-StringToBigInt(to_string(i_));
    }
    BigInt operator-=(BigInt big_int_tmp_) {
        big_int_tmp_.pm_=-big_int_tmp_.pm_;
        *this=*this+big_int_tmp_;
        return *this;
    }
    BigInt operator-=(string S_) {
        *this-=StringToBigInt(S_);
        return *this;
    }
    BigInt operator-=(long long int i_) {
        *this-=StringToBigInt(to_string(i_));
        return *this;
    }
    BigInt Multiplication(BigInt &x_,BigInt &y_){
        if((x_.block_size_)==0||(y_.block_size_==0))return BigInt();
        BigInt ret_(x_.block_size_+y_.block_size_,1);
        ret_.pm_=(x_.pm_)*y_.pm_;
        
        for (long long int i_ = 0; i_ < x_.block_size_; i_++)
        {
            for (long long int j_ = 0; j_ < y_.block_size_; j_++)
            {
                ret_.data_[i_+j_]+=(x_.data_[i_])*y_.data_[j_];
                long long int now_=i_+j_;
                while(ret_.data_[now_]>=mod_){
                    ret_.data_[now_+1]+=ret_.data_[now_]/mod_;
                    ret_.data_[now_]%=mod_;
                    now_++;
                }
            }
        }
        if(ret_.data_[ret_.block_size_-1]==0){
            ret_.block_size_--;
        }
        return ret_;
    }
    
    BigInt Karatsuba(BigInt x_,BigInt y_){
        
        if(x_.block_size_<=100||y_.block_size_<=100){
            return Multiplication(x_,y_);
        }else{
            long long int block_size_mid=min(x_.block_size_/2,y_.block_size_/2);
            BigInt x_small_=x_.BlockCut(x_,0,block_size_mid),x_big_=x_.BlockCut(x_,block_size_mid,x_.block_size_);
            BigInt y_small_=y_.BlockCut(y_,0,block_size_mid),y_big_=y_.BlockCut(y_,block_size_mid,y_.block_size_);
            BigInt z_small_=Karatsuba(x_small_,y_small_),z_big_=Karatsuba(x_big_,y_big_);
            BigInt z_mid_=z_big_+z_small_-Karatsuba(x_big_-x_small_,y_big_-y_small_);
            return z_big_.BlockShift(z_big_,block_size_mid+block_size_mid)+z_small_+z_mid_.BlockShift(z_mid_,block_size_mid);
        }
    }

    
    //巨大サイズ10^9くらいになるとバグるかも(多分修正済み)
    BigInt operator*(BigInt big_int_tmp_){
        if((this->block_size_)==0||(big_int_tmp_.block_size_==0))return BigInt();
        BigInt big_int_return_(this->block_size_+big_int_tmp_.block_size_,1);
        big_int_return_.pm_=(this->pm_)*big_int_tmp_.pm_;
        
        for (long long int i_ = 0; i_ < this->block_size_; i_++)
        {
            for (long long int j_ = 0; j_ < big_int_tmp_.block_size_; j_++)
            {
                big_int_return_.data_[i_+j_]+=(this->data_[i_])*big_int_tmp_.data_[j_];
                long long int now_=i_+j_;
                while(big_int_return_.data_[now_]>=mod_){
                    big_int_return_.data_[now_+1]+=big_int_return_.data_[now_]/mod_;
                    big_int_return_.data_[now_]%=mod_;
                    now_++;
                }
            }
            
        }
        
        if(big_int_return_.data_[big_int_return_.block_size_-1]==0){
            big_int_return_.block_size_--;
        }
        
        return big_int_return_;
    }


    BigInt operator*(string S_) {
        return (*this)*StringToBigInt(S_);
    }
    
    BigInt operator*(long long int i_) {
        return (*this)*StringToBigInt(to_string(i_));
    }
    BigInt operator*=(BigInt big_int_tmp_){
        (*this)=(*this)*big_int_tmp_;
    
        return *this;
    }
    
    BigInt operator*=(string S_) {
        (*this)*=StringToBigInt(S_);
        return *this;
    }
    BigInt operator*=(long long int i_) {
        (*this)*=StringToBigInt(to_string(i_));
        return *this;
    }
};



//比較関数
bool BunsuuCmp(pll data_a,pll data_b){
    if(data_a.first<0&&data_b.first<0||data_a.first>=0&&data_b.first>=0)return data_a.second*data_b.first<data_a.first*data_b.second;
    else return data_a.second*data_b.first>data_a.first*data_b.second;
}

bool HenkakuCmp(pll data_a,pll data_b){
    long long int type_a,type_b;
    if(data_a.first>=0&&data_a.second==0)type_a=0;
    else if(data_a.first>0&&data_a.second>0)type_a=1;
    else if(data_a.first==0&&data_a.second>0)type_a=2;
    else if(data_a.first<0&&data_a.second>0)type_a=3;
    else if(data_a.first<0&&data_a.second==0)type_a=4;
    else if(data_a.first<0&&data_a.second<0)type_a=5;
    else if(data_a.first==0&&data_a.second<0)type_a=6;
    else if(data_a.first>0&&data_a.second<0)type_a=7;

    if(data_b.first>=0&&data_b.second==0)type_b=0;
    else if(data_b.first>0&&data_b.second>0)type_b=1;
    else if(data_b.first==0&&data_b.second>0)type_b=2;
    else if(data_b.first<0&&data_b.second>0)type_b=3;
    else if(data_b.first<0&&data_b.second==0)type_b=4;
    else if(data_b.first<0&&data_b.second<0)type_b=5;
    else if(data_b.first==0&&data_b.second<0)type_b=6;
    else if(data_b.first>0&&data_b.second<0)type_b=7;

    if(type_a!=type_b)return type_a<type_b;
    else{
        if(type_a==0){
            return data_a.first<data_b.first;
        }else if(type_a==1){
            return data_a.second*data_b.first<data_a.first*data_b.second;
        }else if(type_a==2){
            return data_a.second<data_b.second;
        }else if(type_a==3){
            return data_a.second*data_b.first<data_a.first*data_b.second;
        }else if(type_a==4){
            return data_a.first>data_b.first;
        }else if(type_a==5){
            return data_a.second*data_b.first<data_a.first*data_b.second;
        }else if(type_a==6){
            return data_a.second>data_b.second;
        }else{
            return data_a.second*data_b.first<data_a.first*data_b.second;
        }
    }
}


const long long int MOD = 998244353;
const long long int INF = 4e18;
const long long int inf = -1e15;
const long double PI = 3.14159265358979323;
const long long int pl = 1100;
const long double eps = 0.0000001;

long long int N[2],res=0;
string S[2];

long long int solve(string T){
    long long int tmp=0;
    for (long long int i = 0; i < T.size(); i++)
    {
        tmp=26*tmp+(T[i]-'A'+1);
    }
    return tmp;
}

int main() {
    cout << fixed << setprecision(18);
    cin>>S[0]>>N[0]>>S[1]>>N[1];
    long long int tmp=N[1]-N[0]+1;
    long long int M[2];
    cout<<tmp*(solve(S[1])-solve(S[0])+1)<<endl;
    
}
