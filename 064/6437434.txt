use std::{cmp::Ordering, io::Read};

fn main() {
    let mut input = String::new();
    std::io::stdin().read_to_string(&mut input).unwrap();
    let v = input.lines().skip(1).collect::<String>().split(' ').enumerate().map(|(i,e)|{
        let card = e.as_bytes();
        IdxNum {
            i,
            suit: card[0] as char,
            n: (card[1] as char).to_digit(10).expect("invalid number")
        }
    }).collect::<Vec<_>>();

    let mut v_2 = v.clone();
    let mut v_3 = v.clone();
    bubble_sort(&mut v_2);
    selection_sort(&mut v_3);
    print_vec(&v_2);
    check_stable(&v_2);
    print_vec(&v_3);
    check_stable(&v_3);
}

#[derive(PartialEq, Debug, Clone, Copy)]
struct IdxNum<T: PartialOrd> {i:usize, suit: char, n:T}
impl<T: PartialOrd> PartialOrd for IdxNum<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.n.partial_cmp(&other.n)
    }
}

fn print_vec<T:PartialOrd + std::fmt::Display> (v :&Vec<IdxNum<T>>) {
    v.iter().enumerate().for_each(|(i,e)| {
        if i != 0 {print!(" ");}
        print!("{}{}", e.suit, e.n);
    });
    print!("\n");
}

fn check_stable<T: PartialOrd> (v: &Vec<IdxNum<T>>)  {
    match !v.as_slice().windows(2).any(|e|{
        e[0].n == e[1].n && e[0].i > e[1].i
    }) {
        true => println!("Stable"),
        false => println!("Not Stable")
    }
}

fn selection_sort<T:PartialOrd> (v :&mut Vec<T>) -> i64 {
    let mut cnt = 0i64;
    for i in 0..v.len() {
        let mut minj = i;
        for j in i..v.len() {
            if v[j] < v[minj] {minj = j}
        }
        if i != minj {
            v.swap(i, minj);
            cnt += 1;
        }
    }
    cnt
}

fn bubble_sort<T: PartialOrd>(v: &mut Vec<T>) -> u64 {
    let mut cnt = 0u64;
    loop {
        let mut flag = false;
        for j in (1..v.len()).rev() {
            if v[j] < v[j - 1] {
                v.swap(j, j - 1);
                flag = true;
                cnt += 1;
            }
        }
        if !flag {
            break;
        }
    }
    cnt
}
