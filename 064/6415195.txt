#include <bits/stdc++.h>
using namespace std;
tuple<long long, long long, long long> operator ^(tuple<long long, long long, long long> A, tuple<long long, long long, long long> B){
  return make_tuple(get<0>(A) ^ get<0>(B), get<1>(A) ^ get<1>(B), get<2>(A) ^ get<2>(B));
}
vector<long long> intersection(vector<long long> A, vector<long long> B){
  int N = A.size();
  int M = B.size();
  vector<tuple<long long, long long, long long>> basis;
  for (int i = 0; i < N; i++){
    basis.push_back(make_tuple(A[i], A[i], 0));
  }
  vector<long long> ans;
  for (int i = 0; i < M; i++){
    tuple<long long, long long, long long> p = make_tuple(B[i], 0, B[i]);
    for (auto T : basis){
      p = min(p, p ^ T);
    }
    if (get<0>(p) == 0){
      ans.push_back(get<1>(p));
    } else {
      basis.push_back(p);
    }
  }
  return ans;
}
int main(){
  int K;
  cin >> K;
  vector<int> N(K);
  for (int i = 0; i < K; i++){
    cin >> N[i];
  }
  vector<vector<long long>> A(K);
  for (int i = 0; i < K; i++){
    A[i] = vector<long long>(N[i]);
    for (int j = 0; j < N[i]; j++){
      cin >> A[i][j];
    }
  }
  vector<vector<long long>> B(K);
  for (int i = 0; i < K; i++){
    for (int j = 0; j < N[i]; j++){
      for (long long x : B[i]){
        A[i][j] = min(A[i][j], A[i][j] ^ x);
      }
      if (A[i][j] > 0){
        B[i].push_back(A[i][j]);
      }
    }
  }
  vector<vector<long long>> I(1 << K);
  I[0] = {0};
  for (int i = 0; i < K; i++){
    I[1 << i] = B[i];
  }
  for (int i = 0; i < (1 << K); i++){
    if (__builtin_popcount(i) >= 2){
      int x = i & -i;
      I[i] = intersection(I[x], I[i - x]);
    }
  }
  __int128_t ans = 0;
  for (int i = 1; i < (1 << K); i++){
    long long P = (long long) 1 << I[i].size();
    if (__builtin_parity(i) == 1){
      ans += P;
    } else {
      ans -= P;
    }
  }
  cout << (long long) ans << endl;
}
