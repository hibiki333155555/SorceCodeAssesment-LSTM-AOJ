#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

long long GCD(long long a, long long b) {
	if (b == 0) return a;
	return GCD(b, a % b);
}

long long LCM(long long a, long long b) {
	return (a / GCD(a, b)) * b;
}

// 入力
int N, M;
int A[2009], B[2009], C[2009];
vector<pair<int, int>> G[1009];
bool visited[1009][1009];

// その他の変数
vector<long long> List;
int nex[1 << 20][21];

void Initialize() {
	// LCM の列挙
	for (int i = 0; i < (1 << 20); i++) {
		long long r = 1;
		for (int j = 0; j < 20; j++) {
			if ((i & (1 << j)) != 0) r = LCM(r, j + 1);
		}
		List.push_back(r);
	}
	sort(List.begin(), List.end());
	List.erase(unique(List.begin(), List.end()), List.end());

	// 次の番号を求める
	for (int i = 0; i < (int)List.size(); i++) {
		for (int j = 1; j <= 20; j++) {
			int pos1 = lower_bound(List.begin(), List.end(), LCM(List[i], j)) - List.begin();
			nex[i][j] = pos1;
		}
	}
}

int main() {
	// 入力・初期化
	cin >> N >> M;
	for (int i = 1; i <= M; i++) {
		cin >> A[i] >> B[i] >> C[i];
		G[A[i]].push_back(make_pair(B[i], C[i]));
	}
	Initialize();

	// 幅優先探索
	queue<pair<int, int>> Q;
	Q.push(make_pair(1, 0)); visited[1][0] = true;
	while (!Q.empty()) {
		int pos1 = Q.front().first;
		int pos2 = Q.front().second; Q.pop();
		for (pair<int, int> to : G[pos1]) {
			int cost = nex[pos2][to.second];
			if (visited[to.first][cost] == true) continue;
			visited[to.first][cost] = true;
			Q.push(make_pair(to.first, cost));
		}
	}

	// 出力
	long long AnsL = (1LL << 60), AnsR = -(1LL << 60);
	for (int i = 0; i < (int)List.size(); i++) {
		if (visited[N][i] == false) continue;
		AnsL = min(AnsL, List[i]);
		AnsR = max(AnsR, List[i]);
	}
	if (AnsL == (1LL << 60)) cout << "IMPOSSIBLE" << endl;
	else cout << AnsL << " " << AnsR << endl;
	return 0;
}
