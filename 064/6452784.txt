#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

template <class S, S (*op)(S, S), S (*e)()>
struct segtree {
    int n;
    vector<S> tree;
    segtree() : segtree(0) {}
    segtree(int n) : n(n), tree(vector<S>(n<<1, e())) {}
    void update(int k) { tree[k] = op(tree[k<<1|0], tree[k<<1|1]); }
    S operator[](int i) {return tree[i+n]; }
    void set(int i, S x) {
        i += n;
        tree[i] = x;
        while(i >>= 1) {
            update(i);
        }
    }
    // [l,r)
    S query(int l, int r) {
        S sml = e(), smr = e();
        for(l += n, r += n; l < r; l >>= 1, r >>= 1){
            if(l & 1) sml = op(sml, tree[l++]);
            if(r & 1) smr = op(tree[--r], smr);
        }
        return op(sml,smr);
    }
};

ll op(ll a,ll b){
    return max(a,b);
}
ll e(){
    return 0;
}

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n; cin >> n;
    const int N = 1e5;
    segtree<ll,op,e> seg(N+1);
    for(int i=0;i<n;i++){
        int a; cin >> a;
        auto r = seg.query(0,a);
        seg.set(a,r+a);
    }
    cout << seg.query(0,N+1) << endl;
}


