#line 1 "Contests/Dummy/HUPC2021-day2/g/main.cpp"
//#include "KowerKoint/base.hpp"
#include <bits/stdc++.h>
using namespace std;
using VI = vector<int>;
using ll = long long;
constexpr int mod = 998244353;
#line 1 "library/ei1333/math/combinatorics/mod-int.cpp"
template< int mod >
struct ModInt {
  int x;

  ModInt() : x(0) {}

  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}

  ModInt &operator+=(const ModInt &p) {
    if((x += p.x) >= mod) x -= mod;
    return *this;
  }

  ModInt &operator-=(const ModInt &p) {
    if((x += mod - p.x) >= mod) x -= mod;
    return *this;
  }

  ModInt &operator*=(const ModInt &p) {
    x = (int) (1LL * x * p.x % mod);
    return *this;
  }

  ModInt &operator/=(const ModInt &p) {
    *this *= p.inverse();
    return *this;
  }

  ModInt operator-() const { return ModInt(-x); }

  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }

  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }

  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }

  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }

  bool operator==(const ModInt &p) const { return x == p.x; }

  bool operator!=(const ModInt &p) const { return x != p.x; }

  ModInt inverse() const {
    int a = x, b = mod, u = 1, v = 0, t;
    while(b > 0) {
      t = a / b;
      swap(a -= t * b, b);
      swap(u -= t * v, v);
    }
    return ModInt(u);
  }

  ModInt pow(int64_t n) const {
    ModInt ret(1), mul(x);
    while(n > 0) {
      if(n & 1) ret *= mul;
      mul *= mul;
      n >>= 1;
    }
    return ret;
  }

  friend ostream &operator<<(ostream &os, const ModInt &p) {
    return os << p.x;
  }

  friend istream &operator>>(istream &is, ModInt &a) {
    int64_t t;
    is >> t;
    a = ModInt< mod >(t);
    return (is);
  }

  static int get_mod() { return mod; }
};

using modint = ModInt< mod >;
#line 1 "library/ei1333/math/matrix/matrix.cpp"
template< class T >
struct Matrix {
  vector< vector< T > > A;

  Matrix() {}

  Matrix(size_t n, size_t m) : A(n, vector< T >(m, 0)) {}

  Matrix(size_t n) : A(n, vector< T >(n, 0)) {};

  size_t size() const {
     if(A.empty()) return 0;
     assert(A.size() == A[0].size());
     return A.size();
  }

  size_t height() const {
    return (A.size());
  }

  size_t width() const {
    return (A[0].size());
  }

  inline const vector< T > &operator[](int k) const {
    return (A.at(k));
  }

  inline vector< T > &operator[](int k) {
    return (A.at(k));
  }

  static Matrix I(size_t n) {
    Matrix mat(n);
    for(int i = 0; i < n; i++) mat[i][i] = 1;
    return (mat);
  }

  Matrix &operator+=(const Matrix &B) {
    size_t n = height(), m = width();
    assert(n == B.height() && m == B.width());
    for(int i = 0; i < n; i++)
      for(int j = 0; j < m; j++)
        (*this)[i][j] += B[i][j];
    return (*this);
  }

  Matrix &operator-=(const Matrix &B) {
    size_t n = height(), m = width();
    assert(n == B.height() && m == B.width());
    for(int i = 0; i < n; i++)
      for(int j = 0; j < m; j++)
        (*this)[i][j] -= B[i][j];
    return (*this);
  }

  Matrix &operator*=(const Matrix &B) {
    size_t n = height(), m = B.width(), p = width();
    assert(p == B.height());
    vector< vector< T > > C(n, vector< T >(m, 0));
    for(int i = 0; i < n; i++)
      for(int j = 0; j < m; j++)
        for(int k = 0; k < p; k++)
          C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);
    A.swap(C);
    return (*this);
  }

  Matrix &operator^=(long long k) {
    Matrix B = Matrix::I(height());
    while(k > 0) {
      if(k & 1) B *= *this;
      *this *= *this;
      k >>= 1LL;
    }
    A.swap(B.A);
    return (*this);
  }

  Matrix operator+(const Matrix &B) const {
    return (Matrix(*this) += B);
  }

  Matrix operator-(const Matrix &B) const {
    return (Matrix(*this) -= B);
  }

  Matrix operator*(const Matrix &B) const {
    return (Matrix(*this) *= B);
  }

  Matrix operator^(const long long k) const {
    return (Matrix(*this) ^= k);
  }

  friend ostream &operator<<(ostream &os, Matrix &p) {
    size_t n = p.height(), m = p.width();
    for(int i = 0; i < n; i++) {
      os << "[";
      for(int j = 0; j < m; j++) {
        os << p[i][j] << (j + 1 == m ? "]\n" : ",");
      }
    }
    return (os);
  }


  T determinant() {
    Matrix B(*this);
    assert(width() == height());
    T ret = 1;
    for(int i = 0; i < width(); i++) {
      int idx = -1;
      for(int j = i; j < width(); j++) {
        if(B[j][i] != 0) idx = j;
      }
      if(idx == -1) return (0);
      if(i != idx) {
        ret *= -1;
        swap(B[i], B[idx]);
      }
      ret *= B[i][i];
      T vv = B[i][i];
      for(int j = 0; j < width(); j++) {
        B[i][j] /= vv;
      }
      for(int j = i + 1; j < width(); j++) {
        T a = B[j][i];
        for(int k = 0; k < width(); k++) {
          B[j][k] -= B[i][k] * a;
        }
      }
    }
    return (ret);
  }
};
#line 9 "Contests/Dummy/HUPC2021-day2/g/main.cpp"

/* #include <atcoder/all> */
/* using namespace atcoder; */
/* #include "KowerKoint/expansion/ac-library/all.hpp" */
#define REP(i, n) for(int i = 0; i < (int)(n); i++)
/* #include <atcoder/all> */
/* using namespace atcoder; */
/* #include "KowerKoint/expansion/ac-library/all.hpp" */

using MI3 = ModInt<mod>;
vector<pair<MI3, ll>> ans;
map<char, MI3> variable;

ll number(string str) {
    ll res = 0;
    REP(i, str.length()) {
        res *= 10;
        res += str[i] - '0';
    }
    return res;
}
MI3 term(string str) {
    if('0' <= str[0] && str[0] <= '9') return number(str);
    else return variable[str[0]];
}
pair<MI3, ll> expression(string str, char c) {
    int i = 0;
    int minus = 0;
    if(str[0] == '-') {
        minus = 1;
        i++;
    }
    ll cntchar = 0;
    MI3 sum = 0;
    while(i < str.length()) {
        int j = i;
        while(j < str.length() && str[j] != '+' && str[j] != '-') {
            j++;
        }
        if(str[i] == c) {
            if(minus) cntchar--;
            else cntchar++;
        } else {
            if(minus) sum -= term(str.substr(i, j - i));
            else sum += term(str.substr(i, j - i));
        }
        i = j;
        if(i == str.length()) break;
        if(str[i] == '+') minus = 0;
        else minus = 1;
        i++;
    }
    return {sum, cntchar};
}
void print(string str, ll time) {
    ans.emplace_back(expression(str.substr(6, str.length()-7), '_').first, time);
}
void assign(string str, ll time) {
    char c = str[0];
    auto res = expression(str.substr(3), c);
    Matrix<MI3> mat(2, 2);
    mat[0][0] = res.second;
    mat[0][1] = res.first;
    mat[1][1] = 1;
    mat = mat ^ time;
    variable[c] = mat[0][0] * variable[c] + mat[0][1];
}
void loop(string str) {
    int i = 0;
    ll loopnum = 1;
    while(i+3 <= str.length() && str.substr(i, 3) == "for") {
        int tojikakko = i+3;
        while(str[tojikakko] != ')') tojikakko++;
        loopnum *= expression(str.substr(i+4, tojikakko - i - 4), '_').first.x;
        i = tojikakko + 1;
    }
    string nakami = str.substr(i);
    if(nakami.length() >= 6 && nakami.substr(0, 6) == "print(") {
        print(nakami, loopnum);
    } else {
        assign(nakami, loopnum);
    }
}

void solve(){
    auto run = []() -> bool {
        int n, m; cin>> n >> m;
        if(n == 0) return false;
        vector<vector<pair<MI3, ll>>> thisans(2);
        REP(_, 2) {
            variable.clear();
            ans.clear();
            REP(__, n) {
                string program; cin >> program;
                if(program.length() >= 6 && program.substr(0, 6) == "print(") {
                    print(program, 1LL);
                } else if(program.length() >= 3 && program.substr(0, 3) == "for") {
                    loop(program);
                } else if(program.length() >= 2 && program[1] == '<') {
                    assign(program, 1LL);
                }
            }
            int i = 0, j = 0;
            /* cerr << "ans:"; */
            /* REP(i, ans.size()) cerr << ' ' << ans[i].first.x << ans[i].second; */
            /* cerr << '\n'; */
            while(i < ans.size()) {
                ll sum = 0;
                while(j < ans.size() && ans[i].first == ans[j].first) {
                    sum += ans[j].second;
                    j++;
                }
                if(sum == 0) {
                    i = j;
                    continue;
                }
                thisans[_].emplace_back(ans[i].first, sum);
                i = j;
            }
            /* cerr << "thisans[_]:"; */
            /* REP(i, thisans[_].size()) cerr << ' ' << thisans[_][i].first.x << thisans[_][i].second; */
            /* cerr << '\n'; */
            swap(n, m);
        }
        cout << (thisans[0] == thisans[1]? "Yes" : "No") << '\n';
        return true;
    };
    while(run());
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    // Fasterize input/output script
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << fixed << setprecision(100);
    // scanf/printf user should delete this fasterize input/output script

    int t = 1;
    //cin >> t; // comment out if solving multi testcase
    for(int testCase = 1;testCase <= t;++testCase){
        solve();
    }
    return 0;
}

