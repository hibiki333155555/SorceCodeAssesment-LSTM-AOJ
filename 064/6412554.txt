#include<bits/stdc++.h>
#define double long double
using namespace std;
const int N = 1e5+50;
const double eps=1e-10;
const double PI=acos(-1);
using ll = long long;
struct V{
	double x,y;
	V(double a=0.0,double b=0.0){x=a;y=b;}
};
double operator * (const V&u,const V&v){return u.x*v.x+u.y*v.y;}
double operator ^ (const V&u,const V&v){return u.x*v.y-u.y*v.x;}//u x v 
V operator +(const V&u,const V&v){return V(u.x+v.x,u.y+v.y);}
V operator -(const V&u,const V&v){return V(u.x-v.x,u.y-v.y);}
V operator *(const double&k,const V&v){return V(k*v.x,k*v.y);}
V operator *(const V&v,const double&k){return V(k*v.x,k*v.y);}
V operator /(const V&v,const double&k){return V(v.x/k,v.y/k);}
V operator /(const double&k,const V&v){return V(v.x/k,v.y/k);}
//bool operator <(const V&u,const V&v){return u.x<v.x||(abs(u.x-v.x)<eps&&u.y<v.y);}
bool operator <(const V&u,const V&v){return u.y<v.y||(abs(u.y-v.y)<eps&&u.x<v.x);}
bool operator ==(const V&u,const V&v){return abs(u.x-v.x)<eps&&abs(u.y-v.y)<eps;}
bool operator !=(const V&u,const V&v){return !(u==v);}
double norm(const V&v){return sqrt(v.x*v.x+v.y*v.y);}
struct line{
	V a,b,dir;
	int flag;
	line(){}
	//line(V u, V v){a=u;b=v;dir=(v-u)/norm(v-u);}
	line(V u, V v,int c=0){a=u;b=v;dir=(v-u)/norm(v-u);flag=c;}
};
V Get_Projection_Point(line l,V x){
	return l.a+(((x-l.a)*l.dir)*l.dir);
} 
V Get_Reflection_Point(line l,V x){
	return Get_Projection_Point(l,x)*2.0-x;
} 
bool On_Line(line l,V x){
	return abs(l.dir^(x-l.a))<eps;
}
int Relative_Pos(line l,V x){
	if(On_Line(l,x)){
		if(((x-l.a)*l.dir)<-eps) return 3;//on back
		else if(((x-l.a)*(x-l.b))<eps) return 5;//on seg
		else return 4;//on front
	}
	else{
		if((l.dir^(x-l.a))>eps) return 1;//counter clock wise
		else return 2;//clock wise
	}
}
bool Is_Parallel(line l1,line l2){
	return abs(l1.dir^l2.dir)<eps;
}
bool Is_Orthogonal(line l1,line l2){
	return abs(l1.dir*l2.dir)<eps;
}
bool Is_Intersect(line l1,line l2){
	if(min(l1.a.x,l1.b.x)>max(l2.a.x,l2.b.x)+eps||min(l2.a.x,l2.b.x)>max(l1.a.x,l1.b.x)+eps
	||min(l1.a.y,l1.b.y)>max(l2.a.y,l2.b.y)+eps||min(l2.a.y,l2.b.y)>max(l1.a.y,l1.b.y)+eps) return false;
	return  ((l1.a-l2.a)^l2.dir)*((l1.b-l2.a)^l2.dir)<eps&&((l2.a-l1.a)^l1.dir)*((l2.b-l1.a)^l1.dir)<eps;
} 
V Cross_Point(line l1,line l2){
	return l1.a+((((l2.a-l1.a)^l2.dir)/(l1.dir^l2.dir))*l1.dir);
}
bool Is_Right_Angle(V a,V b,V c){
	return abs((b-a)*(c-a))<eps;
}
bool Is_Acute_Angle(V a,V b,V c){//angle bac
	return (b-a)*(c-a)>eps;
}
bool Is_Obtuse_Angle(V a,V b,V c){//angle bac
	return (b-a)*(c-a)<-eps;
}
double Dis(V u,V v){
	return sqrt((u.x-v.x)*(u.x-v.x)+(u.y*v.y)*(u.y-v.y));
}
double Dis(line l,V v,bool Is_Segment=false){
	if(Is_Segment&&(Is_Obtuse_Angle(l.a,v,l.b)||Is_Obtuse_Angle(l.b,v,l.a))) 
		return min(norm(v-l.a),norm(v-l.b));
	else return abs((v-l.a)^(v-l.b))/norm(l.a-l.b);
}
double Dis(V v,line l,bool Is_Segment=false){
	if(Is_Segment&&(Is_Obtuse_Angle(l.a,v,l.b)||Is_Obtuse_Angle(l.b,v,l.a))) 
		return min(norm(v-l.a),norm(v-l.b));
	else return abs((v-l.a)^(v-l.b))/norm(l.a-l.b);
}
double Seg_To_Seg_Dis(line l1,line l2){
	if(Is_Intersect(l1,l2)) return 0.0;
	return min({Dis(l1.a,l2,1),Dis(l1.b,l2,1),Dis(l2.a,l1,1),Dis(l2.b,l1,1)});
}
double Polygon_Area(V a[],int n){
	double res=0;
	for(int i=1;i<=n;i++) res+=(a[i]^a[i%n+1]);
	return abs(res)/2;
}
bool Is_Convex(V a[],int n){
	a[0]=a[n];a[n+1]=a[1];
	int op=0;
	for(int i=1;i<=n;i++){
		double t=(a[i+1]-a[i])^(a[i]-a[i-1]);
		if(abs(t)<eps) continue;
		int nop=t>eps?1:-1;
		if(!op) op=nop;
		else if(op!=nop) return false;
	}
	return true;
}
bool On_Segment(line l,V v){
	if(!On_Line(l,v)) return false;
	if(v.x>l.a.x+eps&&v.x>l.b.x+eps) return false;
	if(v.x<l.a.x-eps&&v.x<l.b.x-eps) return false;
	if(v.y>l.a.y+eps&&v.y>l.b.y+eps) return false;
	if(v.y<l.a.y-eps&&v.y<l.b.y-eps) return false;
	return true;
} 
bool Is_On_Segment_Of_Polygon(V v,V a[],int n){
	for(int i=1;i<=n;i++) 
		if(On_Segment(line(a[i],a[i%n+1]),v)) return true;
	return false;
}
bool PIP(V v,V a[],int n){//point in polygon
	double sum=0,angle;
	for(int i=1;i<=n;i++){
		angle=atan2(a[i].y-v.y,a[i].x-v.x)-atan2(a[i%n+1].y-v.y,a[i%n+1].x-v.x);
		if(angle>=PI) angle-=PI*2;
		if(angle<=-PI) angle+=PI*2;
		sum+=angle;
	}
	return (int)(sum/PI+0.5)==0?false:true;
}
V a[N],st[N];
/*bool vis[N];
bool cmp(V u,V v){
	double t=((u-a[1])^(v-a[1]));
	if(abs(t)>eps) return t>0;
	if(u.x>a[1].x) return norm(u-a[1])<norm(v-a[1]);
	else return norm(u-a[1])>norm(v-a[1]);
}
void Convex_Hull(int &n){
	sort(a+1,a+n+1);
	sort(a+2,a+n+1,cmp);
	int pos=2;
	for(int i=3;i<=n;i++)
		if(((a[i]-a[1])^(a[2]-a[1]))>=eps){
			pos=i-1;
			break;
		}      
	sort(a+2,a+pos,cmp2);
	cout<<"ALRIGHT\n";
	int top=0;
	for(int i=1;i<=n;i++){
		while(top>1&&((st[top]-st[top-1])^(a[i]-st[top]))<-eps){
			/*cout<<"i="<<i<<" "<<((st[top]-st[top-1])^(a[i]-st[top]))<<"\n";
			cout<<st[top].x<<" "<<st[top].y<<"\n";
			cout<<st[top-1].x<<" "<<st[top-1].y<<"\n";
			cout<<a[i].x<<" "<<a[i].y<<"\n";
			//break; 
			top--;
		}
		st[++top]=a[i];
	}
	int tmp=top;
	for(int i=n;i&&top;i--)
		if(a[i]==st[tmp]){
			vis[i]=1;
			tmp--;
		} 
	for(int i=n;i>1;i--){
		if(vis[i]) continue;
		if(a[i]!=st[top]&&abs(a[i]^st[top])<0) st[++top]=a[i];
	}
	memcpy(a,st,sizeof(st));
	n=top;
}*/
bool cmp(V u,V v){
	return (u.x<v.x||(u.x==v.x&&u.y<v.y));
}
void Convex_Hull(int &n){
	sort(a+1,a+n+1,cmp);
	int top=0;
	for(int i=1;i<=n;i++){
		while(top>1&&((st[top]-st[top-1])^(a[i]-st[top-1]))<0) top--;
		st[++top]=a[i];
	}
	int base=top;
	for(int i=n-1;i;i--){
		while(top>base&&((st[top]-st[top-1])^(a[i]-st[top-1]))<0) top--;
		st[++top]=a[i];
	}
	if(n>1) top--;
	memcpy(a,st,sizeof(st)); 
	n=top;
}
/*bool cmp2(V u,V v){
	return u.y<v.y||(u.y==v.y&&u.x<v.x);
}*/
double Rotating_Calipers(int n){
	double res=0;
	if(n==2) return norm(a[2]-a[1]);
	a[0]=a[n];
	for(int i=0,j=2;i<n;i++){
		while(((a[i+1]-a[i])^(a[j]-a[i+1]))<=((a[i+1]-a[i])^(a[j+1]-a[i+1]))) j=(j+1)%n;
		res=max({res,norm(a[j]-a[i]),norm(a[j]-a[i+1])});
	}
	return res;
} 
int Line_Intersect_Segment(line l,line seg){
	if(Is_Parallel(l,seg))
		return On_Segment(l,seg.a)?-1:0;//-1:ÖØºÏ 0£ºÆ½ÐÐ 
	return 1;//Ïà½» 
} 
double Cut_Convex_Hull(int n,line l){
	int top=0,x;
	int flag=-1;
	a[0]=a[n];
	for(int i=0;i<n;i++){
		if((l.dir^(a[i]-l.b))>0) st[++top]=a[i];
		int t=Line_Intersect_Segment(l,line(a[i],a[i+1]));
		if(t==1) flag=1,st[++top]=Cross_Point(l,line(a[i],a[i+1]));
		else if(t==-1){
			flag=0;
			x=i;
			break;
		}
	}
	if(!flag){
		if((l.dir*(a[x+1]-a[x]))<0) return 0;
		for(int i=1;i<=n;i++) st[i]=a[i];
		top=n;
	}
	return Polygon_Area(st,top);
}
bool cmpx(const V&u,const V&v){
	return abs(u.x-v.x)<eps?u.y<v.y:u.x<v.x;
}
bool cmpy(const V&u,const V&v){
	return abs(u.y-v.y)<eps?u.x<v.x:u.y<v.y;
}
/*
double calc(int l,int r){
	if(l==r) return INF;
	if(l+1==r) return norm(a[l]-a[r]);
	int mid=(l+r)>>1;
	double ll=calc(l,mid);
	double rr=calc(mid+1,r);
	double res=min(ll,rr);
	vector<V>t;
	for(int i=l;i<=r;i++) if(abs(a[mid].x-a[i].x)<=res) t.push_back(a[i]);
	sort(t.begin(),t.end(),cmpy);
	for(int i=0;i<t.size();i++)
		for(int j=i+1;j<t.size();j++){
			if(t[j].y-t[i].y>res) break;
			res=min(res,norm(t[j]-t[i]));
		}
	return res;
}
double Closest_Points(int n){
	sort(a+1,a+n+1,cmpx);
	return calc(1,n);
}
struct SegTree{
	int l,r;
	ll len;
}tree[N<<2];
void build(int l,int r,int x){
	tree[x].l=l,tree[x].r=r;
	tree[x].len=0;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(l,mid,x<<1);
	build(mid+1,r,x<<1|1);
}
void push_up(int x){
	tree[x].len=tree[x<<1].len+tree[x<<1|1].len;
}
void update(int x,int tar,int val){
	int l=tree[x].l,r=tree[x].r;
	if(l==tar&&tar==r){
		tree[x].len+=val;
		return;
	}
	int mid=(l+r)>>1;
	if(tar<=mid)update(x<<1,tar,val);
	else update(x<<1|1,tar,val);
	push_up(x);
}
int query(int x,int L,int R){
	int l=tree[x].l,r=tree[x].r;
	if(L<=l&&r<=R) return tree[x].len;
	int mid=(l+r)>>1;
	int res=0;
	if(L<=mid) res+=query(x<<1,L,R);
	if(mid+1<=R) res+=query(x<<1|1,L,R);
	return res;
}
bool operator<(line&l1,line&l2){
	if(abs(l1.a.y-l2.a.y)<eps) return l1.flag==l2.flag?l1.a.x<l2.a.x:l1.flag<l2.flag;
	return l1.a.y<l2.a.y;
}
/*bool cmpline(line &l1,line &l2){
	if(l1.a.y==l2.a.y) return l1.flag==l2.flag?l1.a.x<l2.a.x:l1.flag<l2.flag;
	return l1.a.y<l2.a.y;
}
void Segment_Intersections(){
	vector<line>l;
	vector<int>X;
	int n;
	cin>>n;
	V u,v;
	for(int i=1;i<=n;i++){
		cin>>u.x>>u.y>>v.x>>v.y;
		if(u.x!=v.x){
			if(u.x>v.x) swap(u,v);
			X.push_back(u.x);
			X.push_back(v.x);
			l.push_back(line(u,v,2));//flag==2 Æ½ÐÐxÖá 
		}
		else{
			if(u.y>v.y) swap(u,v);
			X.push_back(u.x);
			l.push_back(line(u,u,1));//flag==1 ÏÂ¶Ëµã 
			l.push_back(line(v,v,3));//flag==3 ÉÏ¶Ëµã 
		}
	}
	sort(l.begin(),l.end());
	sort(X.begin(),X.end());
	n=unique(X.begin(),X.end())-X.begin();
	X.erase(X.begin()+n,X.end());
	if(n==1){
		cout<<"0\n";
		return;
	}
	build(1,n,1);
	int res=0;
	for(auto it:l){
		if(it.flag!=2){
			int idx=lower_bound(X.begin(),X.end(),it.a.x)-X.begin();
			int c=it.flag==3?-1:1;
			update(1,idx+1,c); 
		}
		else{
			int idx1=lower_bound(X.begin(),X.end(),it.a.x)-X.begin();
			int idx2=lower_bound(X.begin(),X.end(),it.b.x)-X.begin();
			res+=query(1,idx1+1,idx2+1);
		}
	}
	cout<<res<<"\n";
}*/
struct Circle{
	V o;
	double r;
	Circle(){o=V(0,0);r=0.0;}
	Circle(V v,double x){o=v;r=x;}
};
int Intersection(Circle c1,Circle c2){//Ô²ºÍÔ²µÄÇÐÏßÊýÄ¿ 
	double l=norm(c1.o-c2.o);
	if(l>c1.r+c2.r) return 4;
	if(abs(l-c1.r-c2.r)<eps) return 3;
	if(l+min(c1.r,c2.r)>max(c1.r,c2.r)) return 2;
	if(abs(l+min(c1.r,c2.r)-max(c1.r,c2.r))<eps) return 1;
	return 0;
}
Circle Incircle_Of_Triangle(V v1,V v2,V v3){
	double x=atan2(v2.y-v1.y,v2.x-v1.x);
	double y=atan2(v3.y-v1.y,v3.x-v1.x);
	double p=atan2(v1.y-v2.y,v1.x-v2.x);
	double q=atan2(v3.y-v2.y,v3.x-v2.x);
	V vo=Cross_Point(line(v1,v1+V(cos((x+y)/2),sin((x+y)/2))),line(v2,v2+V(cos((p+q)/2),sin((p+q)/2)))); 
	return Circle(vo,Dis(vo,line(v1,v2)));
} 
Circle Circumscribed_Circle_Of_Triangle(V v1,V v2,V v3){
	V vo=Cross_Point(line((v1+v2)/2,v3),line((v1+v3)/2,v2));
	return Circle(vo,norm(vo-v1));
} 
int main(void){
	//freopen("in.txt","r",stdin); 
	//freopen("out.txt","w",stdout);
	ios::sync_with_stdio(false);cin.tie(0);cout<<fixed<<setprecision(12);
	V v1,v2,v3;
	cin>>v1.x>>v1.y>>v2.x>>v2.y>>v3.x>>v3.y;
	Circle c=Incircle_Of_Triangle(v1,v2,v3);
	cout<<c.o.x<<" "<<c.o.y<<" "<<c.r<<"\n"; 
	return 0;
}

