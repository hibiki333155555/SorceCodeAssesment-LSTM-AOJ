import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
const long mod = 1_000_000_000 + 7;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

void main () {
  string N = readln.chomp;
  const int maxK = N.length.to!int;

  auto dp = new long[][][](maxK + 1, 2, 5);
  foreach (i; 0 .. maxK + 1)
    foreach (k; 0 .. 2)
      foreach (j; 0 .. 5)
        dp[i][k][j] = -1L;
  dp[maxK][0][0] = 1L;

  for (int i = maxK; i > 0; i--) {
    int ni = N[maxK - i] - '0';
    foreach (k; 0 .. 2)
      foreach (j; 0 .. 5) {
        if (dp[i][k][j] < 0L)
          continue;

        foreach (d; 0 .. 10) {
          if (k == 0 && d > ni)
            continue;

          int nk = cast(int)(k == 1 || d < ni);
          int nj;
          if (j == 0) {
            if (d == 5)
              nj = 1;
            else
              nj = 0;
          } else if (j == 1) {
            if (d == 1)
              nj = 2;
            else if (d == 5)
              nj = 1;
            else
              nj = 0;
          } else if (j == 2)
            nj = 3;
          else if (j == 3) {
            if (d == 3)
              nj = 4;
            else if (d == 5)
              nj = 1;
            else
              nj = 0;
          } else
            nj = 4;

          dp[i - 1][nk][nj] =
            max(0L, dp[i - 1][nk][nj]) + dp[i][k][j];
        }
      }
  }

  long ret = 0L;
  ret += max(0L, dp[0][0][4]);
  ret += max(0L, dp[0][1][4]);
  writeln(ret);
}

