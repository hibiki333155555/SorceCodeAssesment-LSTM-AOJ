#include <bits/stdc++.h>
using namespace std;
template<const int MOD> struct modint{
    long long val;
    modint(): val(0) {}
    modint(long long x){
        if(x < 0) val = x % MOD + MOD;
        else val = x % MOD;
    }
    modint(const modint &t){
        val = t.val;
    }
    modint& operator =(const modint m){
        val = m.val;
        return *this;
    }
    modint operator -(){
        return modint(-val);
    }
    modint& operator-=(const modint &m){
        val -= m.val;
        if(val < 0) val += MOD;
        return *this;
    }
    modint& operator+=(const modint &m){
        val += m.val;
        if(val >= MOD) val -= MOD;
        return *this;
    }
    modint& operator*=(const modint &m){
        val *= m.val;
        val %= MOD;
        return *this;
    }
    modint& operator/=(modint m){
        *this *= m.inv();
        return *this;
    }
    modint inv(){
        long long x = 1, y = 0;
        long long a = val, b = MOD;
        while(b != 0){
            long long t = a / b;
            a -= t * b;
            x -= t * y;
            swap(a, b);
            swap(x, y);
        }
        x %= MOD;
        if(x < 0) x += MOD;
        return modint(x);
    }
    modint pow(long long k){
        long long res = 1;
        long long v = val;
        if(v == 0) return modint(0);
        while(k > 0){
            if(k & 1) res = res * v % MOD;
            v = v * v % MOD;
            k >>= 1;
    }
        return modint(res);
    }
    bool operator==(const modint &m){
        return val == m.val;
    }
    modint operator+(const modint &m){
        return modint(*this) += m;
    }
    modint operator-(const modint &m){
        return modint(*this) -= m;
    }
    modint operator*(const modint &m){
        return modint(*this) *= m;
    }
    modint operator/(const modint &m){
        return modint(*this) /= m;
    }
    bool operator!=(const modint &m){
        return modint(*this).val != m.val;
    }
    bool operator!=(const int &m){
        return modint(*this).val != m;
    }
};
const int MOD = 998244353;
using mint = modint<MOD>;
const int MAX = 410000;
mint fac[MAX], finv[MAX], inv[MAX];
//MAX < MOD
void COMinit(){
    fac[0] = fac[1] = 1;
    finv[0] = finv[1] = 1;
    inv[1] = 1;
    for(int i = 2; i < MAX; i++){
        fac[i] = fac[i - 1] * i;
        inv[i] = mint(MOD) - inv[MOD % i] * (MOD / i);
        finv[i] = finv[i - 1] * inv[i];
    }
}
mint COM(int n, int k){
    if (n < k) return 0;
    if (n < 0 || k < 0) return 0;
    return fac[n] * finv[k] * finv[n - k];
}
template<const int mod = 998244353, const int primitive_root = 3>
struct NTT{
    const int proot = primitive_root;//998244353の原始根
    using mint = modint<mod>;
    vector<mint> root, iroot;//変換と逆変換用
    vector<int> ind;
    NTT(){
        int temp = mod - 1;
        int cnt = 0;
        while(temp % 2 == 0){
            temp >>= 1;
            ++cnt;
        }
        int LIMIT = cnt;
        root.resize(LIMIT + 1);
        iroot.resize(LIMIT + 1);
        root[LIMIT] = repow((long long)proot, temp);
        iroot[LIMIT] = root[LIMIT].inv();
        for(int i = LIMIT - 1; i >= 0; --i){
            root[i] = root[i + 1] * root[i + 1];
            iroot[i] = iroot[i + 1] * iroot[i + 1];
        }
    }
    int get_mod(){
        return mod;
    }
    mint repow(long long x, long long y){
        if(y == 0) return 1;
        mint res = 1;
        mint x2 = x;
        while(y > 0){
            if(y & 1) res = res * x2;
            x2 = x2 * x2;
            y >>= 1;
        }
        return res;
    }
    void ntt(int sz, vector<mint> &a, bool inverse){
        int index = 1;
        for(int end = 2; end <= sz; end *= 2){
            mint w = (inverse ? iroot[index] : root[index]);
            int ofs = end / 2;
            for(int i = 0; i < sz / end; ++i){
                mint zeta = 1;
                for(int j = 0; j < ofs; ++j){
                    mint s = a[i * end + j], t = a[i * end + j + ofs] * zeta;
                    a[i * end + j] = s + t;
                    a[i * end + j + ofs] = s - t;
                    zeta *= w;
                }
            }   
            ++index;
        }
        if(inverse){
            mint t = mint(sz).inv();
            for(int i = 0; i < sz; ++i) a[i] *= t;
        }
    }
    //nは必ず2のべき乗
    void bit_inv(int n){
        if(ind.size() == n) return;
        ind.resize(n);
        int cnt = __builtin_popcount(n - 1);
        for(int i = 0; i < n; ++i){
            ind[i] = 0;
            int t = i;
            int temp = 0;
            while(t > 0){
                if(t & 1) ind[i] |= (1 << (cnt - 1 - temp));
                t >>= 1;
                ++temp;
            }
        }
    }
    template<typename T>
    vector<T> convolution(vector<T> &a, vector<T> &b){
        int sz = 1;
        int N = a.size(), M = b.size();
        while(sz < N + M - 1) sz *= 2;
        assert(sz >= N + M - 1);
        vector<mint> A(sz), B(sz);
        bit_inv(sz);
        for(int i = 0; i < N; ++i) A[ind[i]] = a[i];
        for(int i = 0; i < M; ++i) B[ind[i]] = b[i];
        ntt(sz, A, false);
        ntt(sz, B, false);
        vector<mint> C(sz);
        for(int i = 0; i < sz; ++i) C[ind[i]] = A[i] * B[i];
        ntt(sz, C, true);
        C.resize(N + M - 1);
        vector<T> res(N + M - 1);
        for(int i = 0; i < N + M - 1; ++i) res[i] = C[i].val;
        return res;
    }
};
int main(){
    int N, K;
    cin >> N >> K;
    vector<int> a(N), p(N);
    for(int i = 0; i < N; i++) cin >> a[i];
    vector<vector<int>> G(N);
    vector<int> cnt(N);
    for(int i = 0; i < N - 1; i++){
        cin >> p[i + 1];
        G[p[i + 1] - 1].push_back(i + 1);
    }
    NTT ntt;
    auto dfs = [&](auto dfs, int now)->vector<mint>{
        vector<mint> dp(K + 1);
        if(a[now] <= K) dp[a[now]] = 1;
        for(int to : G[now]){
            vector<mint> t = dfs(dfs, to);
            vector<mint> temp = ntt.convolution(t, dp);
            temp.resize(K + 1);
            dp.swap(temp);
        }
        dp[0] = 1;
        return dp;
    };
    vector<mint> res =dfs(dfs, 0);
    cout << res[K].val << endl;
}
