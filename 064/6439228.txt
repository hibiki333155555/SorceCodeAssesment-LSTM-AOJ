using System;
using System.Collections.Generic;
using System.Linq;

internal class Program
{
    public static void Main()
    {
        var nq = Console.ReadLine().Split().Select(x => x.ParseInt()).ToArray();
        (var n, var q) = (nq[0], nq[1]);
        var queue = new ReinvQueue<Process>();
        for (int i = 0; i < n; i++)
        {
            var process = Console.ReadLine().Split().ToArray();
            queue.Enqueue(new Process() { Name = process[0], Time = process[1].ParseInt() });
        }
        var output = new List<Process>();
        var elapsed = 0;
        while (!queue.IsEmpty)
        {
            var process = queue.Dequeue();
            if (process.Time > q)
            {
                process.Time -= q;
                elapsed += q;
                queue.Enqueue(process);
            }
            else
            {
                elapsed += process.Time;
                process.Time = elapsed;
                output.Add(process);
            }
        }

        output.ForEach(p => Console.WriteLine(p));
    }
}

struct Process
{
    public string Name;
    public int Time;
    public override string ToString()
    {
        return $"{Name} {Time.ToString()}";
    }
}

class ReinvQueue<T>
{
    T[] data;
    int head;
    int tail;
    int size => tail - head;
    public ReinvQueue()
    {
        data = new T[16];
        head = 0;
        tail = 0;
    }

    public void Enqueue(T item)
    {
        if (data.Length == tail)
        {
            if (size * 2 > data.Length)
            {
                var newData = new T[data.Length * 2];
                Array.Copy(data, newData, data.Length);
                data = newData;
            }
            else
            {
                var newData = new T[data.Length];
                Array.Copy(data, head, newData, 0, size);
                tail = size;
                head = 0;
            }
        }
        data[tail++] = item;
    }

    public T Dequeue()
    {
        if (IsEmpty)
            throw new InvalidOperationException();
        return data[head++];
    }

    public bool IsEmpty => size == 0;
}

internal static class Extensions
{
    public static int ParseInt(this string s) => int.Parse(s);
}
