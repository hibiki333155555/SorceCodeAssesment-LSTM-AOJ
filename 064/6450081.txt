#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)n; i++)
using ll = long long;
constexpr int MAX = 20;
struct edge{int to; ll cost;};
using P = pair<ll,ll>;
const ll INF = 1e18;

ll gcd(ll a, ll b) {return b ? gcd(b, a % b) : a;}

ll lcm(ll a, ll b) {
  ll g = gcd(a,b);
  return (a/g)*(b/g)*g;
}

void dijkstra(int n, int s, vector<vector<edge>>& g, vector<ll>& d){
  priority_queue<P,vector<P>,greater<P>> que;
  rep(i,n) d[i] = INF;
  d[s] = 0;
  que.push(P(0,s));
  while(!que.empty()){
    P p = que.top();
    que.pop();
    int v = p.second;
    if(d[v] < p.first) continue;
    for(auto e : g[v]){
      if(d[e.to] > d[v] + e.cost){
        d[e.to] = d[v] + e.cost;
        que.push(P(d[e.to], e.to));
      }
    }
  }
}

int main(){
  int n, m;
  cin >> n >> m;
  vector<vector<P>> es(n);
  rep(i,m) {
    int a, b, c;
    cin >> a >> b >> c; 
    a--; b--;
    es[a].push_back(P(b,c));
  }
  int all = (1<<MAX);
  set<ll> st;
  rep(bit,all) {
    ll res = 1;
    rep(j,MAX) if(bit & (1<<j)) res = lcm(j+1,res);
    st.insert(res);
  }
  
  int sz = st.size();
  vector<ll> v;
  for(auto x : st) v.push_back(x);
  vector<vector<edge>> g(n*sz);
  rep(i,n) rep(j,sz) {
    for(auto e : es[i]) {
      ll nex = lower_bound(v.begin(),v.end(),lcm(e.second,v[j]))-v.begin();
      g[i*sz+j].push_back(edge{e.first*sz+nex,1});
    }
  }
  vector<ll> d(n*sz);
  dijkstra(n*sz,0,g,d);
  ll r = -INF, l = INF;
  rep(i,sz) {
    if(d[(n-1)*sz+i] != INF) {
      r = max(r,v[i]);
      l = min(l,v[i]);
    }
  } 
  if(r == -INF) {
    cout << "IMPOSSIBLE" << endl;
  } else {
    cout << l << " " << r << endl;
  }
  return 0;
}

