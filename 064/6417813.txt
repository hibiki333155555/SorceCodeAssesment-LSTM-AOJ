#include <bits/stdc++.h>
//#include <atcoder/all>
using namespace std;
//using namespace atcoder;

using ll = long long int ;
using ld = long double ;
using P = pair<ll,ll>;
using PD = pair<ld,ld>;
using Graph= vector<vector<ll>>;
struct edge{ll to ; ll cost ;} ;
using graph =vector<vector<edge>> ;
#define rep(i,n) for (ll i=0; i < (n); ++i)
#define rep2(i,n,m) for(ll i=n;i<=m;i++)
#define rep3(i,n,m) for(ll i=n;i>=m;i--)
#define pb push_back 
#define eb emplace_back 
#define ppb pop_back 
#define mpa make_pair 
#define fi first  
#define se second  
#define set20 cout<<fixed<<setprecision(20)  ;
const ll INF=1e18 ;   
inline void chmax(ll& a,ll b){a=max(a,b);}  
inline void chmin(ll& a,ll b){a=min(a,b);} 
long double pi=acos(-1) ;  
ll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}  
ll lcm(ll a, ll b) { return a/gcd(a,b)*b;} 
ll dx[4] {1,0,-1,0} ;
ll dy[4] {0,1,0,-1} ;
#define debug cout<<888<<endl ;

struct UnionFind {
  vector<int> d;
  UnionFind(int n=0): d(n,-1) {}
  int find(int x) {
    if (d[x] < 0) return x;
    return d[x] = find(d[x]);
  }
  bool unite(int x, int y) {
    x = find(x); y = find(y);
    if (x == y) return false;
    if (d[x] > d[y]) swap(x,y);
    d[x] += d[y];
    d[y] = x;
    return true;
  }
  bool same(int x, int y) { return find(x) == find(y);}
  int size(int x) { return -d[find(x)];}
};


// sum(x) x以下の和
// sum(a,b) a以上b以下の和
template<typename T>
struct BIT {
  int n;
  vector<T> d;
  BIT(int n=0):n(n),d(n+1) {}
  void add(int i, T x=1) {  //x=1ならsumは個数のカウント
    for (i++; i <= n; i += i&-i) {
      d[i] += x;
    }
  }
  T sum(int i) {
    T x = 0;
    for (i++; i; i -= i&-i) {
      x += d[i];
    }
    return x;
  }
  T sum(int i,int j) {
    if(i>0) return sum(j)-sum(i-1);
    else return sum(j) ; } 
};

//using mint = modint998244353;
//using mint = modint1000000007;
/*
void dfs(ll s,ll t,Graph &g,vector<ll> &d){
  for(auto u:g[t]){
    if(u==s) continue;
    d[u]=d[t]+1;
  }
}
*/


int main(){
  ios::sync_with_stdio(false) ;
  cin.tie(nullptr) ; 

  ll h,w; cin>>h>>w;
  ll n; cin>>n;

  ll A[h][w];
  rep(i,h)rep(j,w) A[i][j]=0ll;

  ll a,b,c,d; cin>>a>>b>>c>>d;
  a-- ; b--; c--; d--;

  rep(i,n){
    ll x,y; cin>>x>>y; 
    x--; y--;
    ll k ;cin>>k;
    queue<pair<P,ll>> q;
    q.push({{x,y},k}); 

    while(!q.empty()){
      auto u=q.front();
      q.pop();
      A[u.fi.fi][u.fi.se]=1; 
      rep(i,4){
        ll xx=u.fi.fi+dx[i];
        ll yy=u.fi.se+dy[i]; 
        if(xx<0||h<=xx||yy<0||w<=yy) continue;
        if(A[xx][yy]==0&&u.se>0){ 
          A[xx][yy]=1ll;
          q.push({{xx,yy},u.se-1});
        }
      }
    }

  }

  

  ll dist[h][w];
  rep(i,h)rep(j,w) dist[i][j]=-1;
  dist[a][b]=0ll;

  queue<P> p;

  p.push({a,b});

  while(!p.empty()){
    auto u=p.front();
    p.pop();
    rep(i,4){
      ll xx=u.fi+dx[i];
      ll yy=u.se+dy[i];
      if(xx<0||h<=xx||yy<0||w<=yy) continue;
      if(dist[xx][yy]==-1&&A[xx][yy]==0){ 
        dist[xx][yy]=dist[u.fi][u.se]+1;
        p.push({xx,yy});
      }
    }
  }
  
  if(dist[c][d]!=-1) cout<<"Yes"<<endl;
  else cout<<"No"<<endl;
  
  /*
  rep(i,h){
    rep(j,w) cout<<A[i][j];
    cout<<endl;
  }
  */

  return 0 ;
  }

