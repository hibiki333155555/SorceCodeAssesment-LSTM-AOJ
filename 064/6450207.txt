#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)
#define all(x) (x).begin(), (x).end()
#define sz(x) int(x.size())
using namespace std;
using ll = long long;
const int INF = 1e9;
const ll LINF = 1e18;
template <class T>
bool chmax(T& a, const T& b) {
    if (a < b) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T>
bool chmin(T& a, const T& b) {
    if (b < a) {
        a = b;
        return 1;
    }
    return 0;
}
template <class T>
vector<T> make_vec(size_t a) {
    return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}
template <typename T>
istream& operator>>(istream& is, vector<T>& v) {
    for (int i = 0; i < int(v.size()); i++) {
        is >> v[i];
    }
    return is;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
    for (int i = 0; i < int(v.size()); i++) {
        os << v[i];
        if (i < int(v.size()) - 1) os << ' ';
    }
    return os;
}
#pragma region MultiSet
template <typename T>
struct MultiSet {
    map<T, int> mp;
    MultiSet() {
    }
    MultiSet(const vector<T>& v) {
        for (int x : v) mp[x]++;
    }
    void insert(T x) {
        mp[x]++;
    }
    void erase(T x) {
        assert(mp[x] > 0);
        mp[x]--;
        if (mp[x] == 0) {
            mp.erase(x);
        }
    }
    bool empty() {
        return mp.empty();
    }
    T max() {
        assert(int(mp.size()) > 0);
        return mp.rbegin()->first;
    }
    T min() {
        assert(int(mp.size()) > 0);
        return mp.begin()->first;
    }
    int count(T x) {
        if (!mp.count(x)) return 0;
        return mp[x];
    }
};
#pragma endregion
#pragma region FenwickTree

#include <cassert>
#include <numeric>
#include <type_traits>
namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value ||
                                  std::is_same<T, __int128>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using is_unsigned_int128 =
    typename std::conditional<std::is_same<T, __uint128_t>::value ||
                                  std::is_same<T, unsigned __int128>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using make_unsigned_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t,
                              unsigned __int128>;

template <class T>
using is_integral =
    typename std::conditional<std::is_integral<T>::value ||
                                  is_signed_int128<T>::value ||
                                  is_unsigned_int128<T>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using is_signed_int =
    typename std::conditional<(is_integral<T>::value &&
                               std::is_signed<T>::value) ||
                                  is_signed_int128<T>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<(is_integral<T>::value &&
                               std::is_unsigned<T>::value) ||
                                  is_unsigned_int128<T>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
    is_signed_int128<T>::value, make_unsigned_int128<T>,
    typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>,
                              std::common_type<T>>::type>::type;

#else

template <class T>
using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<is_integral<T>::value &&
                                  std::is_unsigned<T>::value,
                              std::true_type, std::false_type>::type;

template <class T>
using to_unsigned =
    typename std::conditional<is_signed_int<T>::value, std::make_unsigned<T>,
                              std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T>
using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

#include <cassert>
#include <vector>

// Reference: https://en.wikipedia.org/wiki/Fenwick_tree
template <class T>
struct FenwickTree {
    using U = internal::to_unsigned_t<T>;

public:
    FenwickTree() : _n(0) {
    }
    FenwickTree(int n) : _n(n), data(n) {
    }

    void add(int p, T x) {
        assert(0 <= p && p < _n);
        p++;
        while (p <= _n) {
            data[p - 1] += U(x);
            p += p & -p;
        }
    }

    T sum(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        return sum(r) - sum(l);
    }

    int lower_bound(T x) {
        int i = 0;
        for (int k = 1 << (std::__lg(_n) + 1); k > 0; k >>= 1) {
            if (i + k - 1 < _n && data[i + k - 1] < U(x)) {
                x -= data[i + k - 1];
                i += k;
            }
        }
        return i;
    }

    int upper_bound(T x) {
        int i = 0;
        for (int k = 1 << (std::__lg(_n) + 1); k > 0; k >>= 1) {
            if (i + k - 1 < _n && data[i + k - 1] <= U(x)) {
                x -= data[i + k - 1];
                i += k;
            }
        }
        return i;
    }

private:
    int _n;
    std::vector<U> data;

    U sum(int r) {
        U s = 0;
        while (r > 0) {
            s += data[r - 1];
            r -= r & -r;
        }
        return s;
    }
};
#pragma endregion
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> rs(100100);
    MultiSet<int> st;
    FenwickTree<ll> ft(100100);
    rep(_, n) {
        int l, r;
        ll c;
        cin >> c >> l >> r;
        ft.add(l, c);
        ft.add(r + 1, -c);
        rs[l].push_back(r);
    }
    st.insert(-INF);

    int q;
    cin >> q;
    vector<ll> mn(100100);
    rep(_, q) {
        ll d;
        int e;
        cin >> d >> e;
        mn[e] += d;
    }
    /* rep(i, 7) cout << mn[i] << ' ';
    cout << '\n';
    rep(i, 7) cout << ft.sum(0, i) << ' ';
    cout << '\n'; */

    ll ans = 0;
    for (int l = 0; l < 100100; l++) {
        /* insert */
        for (int rr : rs[l]) {
            st.insert(rr);
        }

        /* dope */
        ll x = mn[l] - ft.sum(0, l + 1);
        if (x > 0) {
            ans += x;
            int r = st.max();
            if (r == -INF) {
                cout << -1 << '\n';
                return 0;
            }
            ft.add(l, x);
            ft.add(r + 1, -x);
        }

        /* erase */
        while (st.count(l)) {
            st.erase(l);
        }
    }
    cout << ans << '\n';
}
