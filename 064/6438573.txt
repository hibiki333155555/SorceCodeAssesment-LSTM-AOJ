#include <iostream>
#include <vector>
#include <queue>
#include <tuple>

using namespace std;

using Graph = vector<vector<pair<int, int>>>; // [移動元][移動先] = {容量, コスト/容量}

tuple<int, int, vector<int>> f(const Graph& G)
{
	vector<int> R(G.size(), -1), D(G.size(), 1 << 30); D[0] = 0;
	priority_queue<tuple<int, int, int>> Q; // {コスト/容量, 移動先, 容量}
	int minC = 0;
	for (Q.push({0, 0, 1 << 30}); !Q.empty();) {
		auto [d, j, c] = Q.top(); Q.pop();
		for (int k = 0; k < (int) G[j].size(); ++k) if (G[j][k].first > 0) {
			int dd = -d + G[j][k].second, cc = min(c, G[j][k].first);
			if (D[k] <= dd) continue;
			D[k] = dd;
			R[k] = j;
			if (k == (int) G.size() - 1) minC = cc; else Q.push({-dd, k, cc});
		}
	}
	return {minC, D.back(), R};
}

int main()
{
	int nV, nE, F; cin >> nV >> nE >> F;
	Graph G(nV, vector<pair<int, int>>(nV, {0, 0}));
	for (int u, v, c, d; --nE >= 0; G[u][v] = {c, d}, G[v][u] = {0, -d}) cin >> u >> v >> c >> d;
	for (int r = 0;;) {
		auto [c, d, P] = f(G);
		if (d >= 1 << 30) {
			cout << -1 << endl;
			break;
		}
		c = min(c, F);
		F -= c;
		r += c * d;
		if (F <= 0) {
			cout << r << endl;
			break;
		}
		for (int k = nV - 1, j = P[k]; j >= 0; k = j, j = P[k]) {
			G[j][k].first -= c;
			G[k][j].first += c;
		}
	}
	return 0;
}

