#!/usr/bin/env python3
import sys
import math
from functools import lru_cache
from heapq import heappush, heappop, heappushpop
from itertools import permutations, accumulate
from operator import itemgetter, le
from collections import deque, Counter, defaultdict
from bisect import bisect_right as br
from bisect import bisect_left as bl
inf = float('inf')
input=lambda: sys.stdin.readline().rstrip("\r\n")
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))

h, w = LI()
c = [input() for _ in range(h)]
m = I()
abt = [LI() for _ in range(m)]
dp = [[inf]*w for _ in range(h)]
limit = [[inf]*w for _ in range(h)]
for a, b, t in abt:
    limit[a-1][b-1] = t
for i in range(h):
    for j in range(w):
        if c[i][j] == 'S': sy, sx = i, j
        if c[i][j] == 'V': gy, gx = i, j
dp[sy][sx] = 0
que = deque([(sy, sx, 0)])
while que:
    y, x, t = que.popleft()
    for dy, dx in zip([-1, 1, 0, 0], [0, 0, -1, 1]):
        ny, nx = y+dy, x+dx
        if 0 <= ny < h and 0 <= nx < w:
            if c[ny][nx] == '#': continue
            if limit[ny][nx] <= t+1: continue
            if dp[ny][nx] > t+1:
                dp[ny][nx] = t+1
                que.append((ny, nx, t+1))
if dp[gy][gx] == inf: 
    print("No")
    quit()
T = dp[gy][gx]
dp = [[inf]*w for _ in range(h)]
dp[gy][gx] = T
que = deque([(gy, gx, T)])
while que:
    y, x, t = que.popleft()
    for dy, dx in zip([-1, 1, 0, 0], [0, 0, -1, 1]):
        ny, nx = y+dy, x+dx
        if 0 <= ny < h and 0 <= nx < w:
            if c[ny][nx] == '#': continue
            if limit[ny][nx] <= t+1: continue
            if dp[ny][nx] > t+1:
                dp[ny][nx] = t+1
                que.append((ny, nx, t+1))
if dp[sy][sx] == inf: print("No")
else: print("Yes")

