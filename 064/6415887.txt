#include <bits/stdc++.h>
#include <random>

using namespace std;
using i64 = int64_t;
#define REP(i, l, r) for (int i = (int)(l); i < (int)(r); ++i)
#define RVP(i, l, r) for (int i = (int)(r - 1); i >= (int)(l); --i)
#define FCH(e, x) for (const auto e : (x))
#define ALL(x) (x).begin(), (x).end()
#define pb push_back
#define eb emplace_back

template <typename T, T div = 2>
constexpr T infty = numeric_limits<T>::max() / div;

template <typename C> int len(const C &c) { return (int)c.size(); }

template <typename T> int lwb(const vector<T> &c, const T &v) {
  return (int)(lower_bound(ALL(c), v) - c.begin());
}

template <typename T> bool chmin(T &v, const T a) {
  if (v > a) {
    v = a;
    return true;
  }
  return false;
}
template <typename T> bool chmax(T &v, const T a) {
  if (v < a) {
    v = a;
    return true;
  }
  return false;
}

template <class T, class U> string to_string(const pair<T, U> &p) {
  string res = "[" + to_string(p.first) + ", " + to_string(p.second) + "]";
  return res;
}

template <typename T> string to_string(const vector<T> &vec) {
  string res = "[";
  const int s = len(vec);
  REP(i, 0, s) {
    if (i != 0)
      res += ", ";
    res += to_string(vec[i]);
  }
  return res + "]";
}

vector<int> SCC(const vector<vector<int>> &graph) {
  const int n = len(graph);
  vector<vector<int>> rgraph(n);
  REP(i, 0, n) {
    for (const int t : graph[i]) {
      rgraph[t].pb(i);
    }
  }
  vector<int> order;
  vector<bool> visited(n);
  auto dfs1 = [&](auto &&f, const int v) -> void {
    visited[v] = true;
    for (const int t : graph[v]) {
      if (visited[t])
        continue;
      f(f, t);
    }
    order.pb(v);
  };
  REP(i, 0, n) {
    if (not visited[i]) {
      dfs1(dfs1, i);
    }
  }

  vector<int> res(n);
  auto dfs2 = [&](auto &&f, const int v, const int id) -> void {
    res[v] = id;
    for (const int t : rgraph[v]) {
      if (visited[t])
        continue;
      visited[t] = true;
      f(f, t, id);
    }
  };

  fill(ALL(visited), false);
  reverse(ALL(order));
  int cnt = 0;
  for (const int v : order) {
    if (visited[v])
      continue;
    dfs2(dfs2, v, cnt++);
  }

  return res;
}

int main() {
  int V, E;
  cin >> V >> E;
  vector<int> S(E), T(E);
  vector<vector<int>> graph(V);
  REP(i, 0, E) {
    cin >> S[i] >> T[i];
    graph[S[i]].pb(T[i]);
  }
  const auto group = SCC(graph);

  int Q;
  cin >> Q;
  while (Q--) {
    int u, v;
    cin >> u >> v;
    if (group[u] == group[v]) {
      cout << 1 << endl;
    } else {
      cout << 0 << endl;
    }
  }
}
