#include <set>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

class state {
public:
	long long pos; int tp, id;
	state() : pos(-1LL), tp(-1), id(-1) {};
	state(long long pos_, int tp_, int id_) : pos(pos_), tp(tp_), id(id_) {};
	bool operator<(const state& s) const {
		return pos != s.pos ? pos < s.pos : tp < s.tp;
	}
};

long long solve(int N, long long M, int Q, vector<long long> A, vector<long long> B, vector<long long> C, vector<long long> D, vector<long long> E) {
	vector<state> qs;
	for (int i = 0; i < N; i++) {
		qs.push_back(state(B[i], 1, i));
		qs.push_back(state(C[i], 3, i));
	}
	for (int i = 0; i < Q; i++) {
		qs.push_back(state(E[i], 2, i));
	}
	sort(qs.begin(), qs.end());
	set<pair<int, int> > d;
	long long strength = 0, power = 0;
	long long answer = 0;
	long long prepos = 0;
	for (state s : qs) {
		if (s.tp == 1) {
			d.insert(make_pair(C[s.id], s.id));
			power += A[s.id];
		}
		if (s.tp == 3) {
			d.erase(make_pair(C[s.id], s.id));
			power -= A[s.id];
		}
		if (prepos != s.pos || s.tp != 2) {
			strength = 0;
		}
		prepos = s.pos;
		if (s.tp == 2) {
			strength += D[s.id];
			if (power < strength) {
				if (d.empty()) {
					return -1LL;
				}
				int rpos = prev(d.end())->second;
				A[rpos] += strength - power;
				answer += strength - power;
				power = strength;
			}
		}
	}
	return answer;
}

int main() {
	cin.tie(0);
	ios_base::sync_with_stdio(false);
	int N, M;
	cin >> N >> M;
	vector<long long> A(N), B(N), C(N);
	for (int i = 0; i < N; i++) {
		cin >> A[i] >> B[i] >> C[i];
	}
	int Q;
	cin >> Q;
	vector<long long> D(Q), E(Q);
	for (int i = 0; i < Q; i++) {
		cin >> D[i] >> E[i];
	}
	long long answer = solve(N, M, Q, A, B, C, D, E);
	cout << answer << endl;
	return 0;
}
