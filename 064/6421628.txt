#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)
#define rep2(i, a, b) for (int i = (int)a; i < (int)(b); i++)
#define rrep2(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }
constexpr int dx[] = {-1,0,1,0};
constexpr int dy[] = {0,-1,0,1};

int main(){
    int H, W;
    scanf("%d %d", &H, &W);
    char S[H][W+1];
    rep(i, H) scanf("\n%s", S[i]);
    int close[H][W];
    memset(close,0,sizeof close);
    int testcase_i;
    scanf("%d", &testcase_i);
    for (int ___ = 0; ___ < testcase_i; ___++){
        int A, B, T;
        scanf("%d %d %d", &A, &B, &T);
        close[A-1][B-1] = T;
    }
    int dist[H][W];
    memset(dist,-1,sizeof dist);
    int start_r, start_c, treasure_r, treasure_c;
    rep(i, H) rep(j, W){
        if(S[i][j] == 'S') start_r = i, start_c = j;
        else if(S[i][j] == 'V') treasure_r = i, treasure_c = j;
    }
    dist[start_r][start_c] = 0;
    queue<pair<int, int> > que;
    que.emplace(start_r, start_c);
    auto inside = [&](int row, int column){return 0 <= row && row < H && 0 <= column && column < W;};
    while(!que.empty()){
        auto [row, column] = que.front();que.pop();
        rep(i, 4) if(int n_r = row + dx[i], n_c = column + dy[i]; inside(n_r, n_c) && S[n_r][n_c] != '#' && dist[n_r][n_c] < 0 && (!close[n_r][n_c] || close[n_r][n_c] > dist[row][column]+1)){
            dist[n_r][n_c] = dist[row][column]+1;
            if(n_r == treasure_r && n_c == treasure_c){
                while(!que.empty()) que.pop();
                break;
            }
            que.emplace(n_r, n_c);
        }
    }
    if(dist[treasure_r][treasure_c] < 0){
        printf("No\n");
        return 0;
    }
    int half = dist[treasure_r][treasure_c];
    memset(dist,-1,sizeof dist);
    dist[treasure_r][treasure_c] = half;
    que.emplace(treasure_r, treasure_c);
    while(!que.empty()){
        auto [row, column] = que.front();que.pop();
        rep(i, 4) if(int n_r = row + dx[i], n_c = column + dy[i]; inside(n_r, n_c) && S[n_r][n_c] != '#' && dist[n_r][n_c] < 0 && (!close[n_r][n_c] || close[n_r][n_c] > dist[row][column]+1)){
            dist[n_r][n_c] = dist[row][column]+1;
            if(n_r == start_r && n_c == start_c){
                printf("Yes\n");
                return 0;
            }
            que.emplace(n_r, n_c);
        }
    }
    printf("No\n");
    return 0;
}
