#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// グラフを表す構造体
struct Graph
{
  // 辺を表す構造体
  // rev: 逆辺(to,from) がG[to]の中で何番目の要素か
  // cap:辺(from,to)の容量
  struct Edge
  {
    int rev, from, to, cap, icap;
    // メンバ初期化子リスト
    Edge(int r, int f, int t, int c) : rev(r), from(f), to(t), cap(c), icap(c) {}
  };

  // 隣接リスト
  vector<vector<Edge>> list;

  // N: 頂点数
  Graph(int N = 0) : list(N) {}

  // グラフの頂点数取得
  size_t size()
  {
    return list.size();
  }

  // Graphインスタンスを0として,
  // G.list[v]をG[v]と書けるようにしておく
  // 演算子のオーバーロード
  vector<Edge> &operator[](int i)
  {
    return list[i];
  }

  // 辺 e = (u,v)の逆辺(v,u)を取得する
  Edge &redge(const Edge &e)
  {
    return list[e.to][e.rev];
  }

  // 辺 e = (u,v)に流量fのフローを流す
  // e = (u,v)の流量がfだけ減少する
  // このとき逆辺(v,u)の流量を増やす
  void run_flow(Edge &e, int f)
  {
    e.cap -= f;
    redge(e).cap += f;
  }

  // 頂点 from から頂点 to　へ容量capの辺を張る
  // このときtoからfromへも容量0の辺を張っておく
  void addedge(int from, int to, int cap)
  {
    int fromrev = (int)list[from].size();
    int torev = (int)list[to].size();
    list[from].push_back(Edge(torev, from, to, cap));
    list[to].push_back(Edge(fromrev, to, from, 0));
  }
};

struct FordFulkerson
{
  static const int INF = 1 << 30; // 無限大を表す値を適切に
  vector<int> seen;

  FordFulkerson() {}

  // 残余グラフ上でs-tパスを見つける（深さ優先探索）
  // 返り値はs-tパス上の容量の最小値（見つからなかったら0)
  // f:sからvへ到達した過程の各辺の容量の最小値
  int fodfs(Graph &G, int v, int t, int f)
  {
    // 終端tに到達したらリターン
    if (v == t)
      return f;

    // 深さ優先探索
    seen[v] = true;
    for (auto &e : G[v])
    {
      if (seen[e.to])
        continue;

      // 容量0の辺は実際には存在しない
      if (e.cap == 0)
        continue;

      // s-tパスを探す
      // 見つかったらflowはパス上の最小容量
      // 見つからなかったらf=0
      int flow = fodfs(G, e.to, t, min(f, e.cap));

      // s-tパスが見つからなかったら次辺を試す
      if (flow == 0)
        continue;

      // 辺 e に容量flowのフローを流す
      G.run_flow(e, flow);

      // s-tパスを見つけたらパス上最小容量を返す
      return flow;
    }
    // s-tパスが見つからなかったことを示す
    return 0;
  }

  // グラフGのs-t間の最大流量を求める
  // ただしリターン時にGは残余グラフになる
  int solve(Graph &G, int s, int t)
  {
    int res = 0;

    // 残余グラフにs-tパスがなくなるまで反復
    while (true)
    {
      seen.assign((int)G.size(), 0);
      int flow = fodfs(G, s, t, INF);

      // s-tパスが見つからなかったら終了
      if (flow == 0)
        return res;

      // 答えを加算
      res += flow;
    }
    // no reach
    return 0;
  }
};

void solve(Graph &G, int N, int s, int t)
{
  // 一旦フローを流す
  FordFulkerson ff;
  int B = ff.solve(G, s, t);

  // sから到達可能な頂点,tへ到達可能な頂点
  vector<int> S(N, false), T(N, false);
  queue<int> que;
  que.push(s);
  S[s] = true;
  while (!que.empty())
  {
    int v = que.front();
    que.pop();
    for (auto e : G[v])
    {
      if (e.cap > 0 && !S[e.to])
      {
        S[e.to] = true;
        que.push(e.to);
      }
    }
  }
  que.push(t);
  T[t] = true;
  while (!que.empty())
  {
    int v = que.front();
    que.pop();
    for (auto e : G[v])
    {
      // 逆辺がある時（逆辺から到達可能なところだけを見る）
      if (G.redge(e).cap > 0 && !T[e.to])
      {
        T[e.to] = true;
        que.push(e.to);
      }
    }
  }
  // TからSに向かう辺のうちs-tパスに使われなかった辺数
  int res = 0;
  for (int v = 0; v < N; ++v)
  {
    // Tから到達可能であり
    if (T[v])
    {
      for (auto e : G[v])
      {
        // 容量が1でありもとの容量と同じ＝s-tパスに使われていない && 行き先がSから到達可能な辺である。
        if (e.cap > 0 && e.cap == e.icap && S[e.to])
          ++res;
      }
    }
  }
  // answer resが一つでも存在すれば
  int ma = (res ? B + 1 : B);
  cout << ma << " " << res << endl;
}

int main()
{
  // Input
  int N, M, s, t;
  while (cin >> N >> M >> s >> t)
  {
    if (N == 0)
      break;
    --s, --t;
    Graph G(N);
    for (int i = 0; i < M; ++i)
    {
      int a, b;
      cin >> a >> b;
      --a, --b;
      G.addedge(a, b, 1);
    }
    solve(G, N, s, t);
  }
}

