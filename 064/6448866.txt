using System;
using System.Collections.Generic;
using System.Linq;
using static Tools;

internal class Program
{
    public static void Main()
    {
        if (new System.Diagnostics.StackFrame(1).GetMethod() == null)
            Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });

        var n = Console.ReadLine().ParseInt();
        var cards = new Card[n];
        for (int i = 0; i < n; i++)
        {
            var input = Console.ReadLine().Split();
            cards[i] = new Card(input[0], input[1].ParseInt());
        }
        var sortedCards = Sort.QuickSort(cards, Comparer<Card>.Create((a, b) => a.Number.CompareTo(b.Number)));

        Console.WriteLine(Sort.IsStable(cards, sortedCards, new CardNumbersEqualityComparer(), (Card c) => c.Number) ? "Stable" : "Not stable");
        foreach (var item in sortedCards)
        {
            Console.WriteLine($"{item.Suit} {item.Number}");
        }
        Console.Out.Flush();
    }
}

class CardNumbersEqualityComparer : IEqualityComparer<Card>
{
    public bool Equals(Card x, Card y) => x.Number == y.Number;
    public int GetHashCode(Card obj) => obj.Number;
}
struct Card : IEquatable<Card>
{
    public string Suit { get; }
    public int Number { get; }
    public Card(string suit, int number)
    {
        this.Suit = suit;
        this.Number = number;
    }
    public bool Equals(Card other) => Suit == other.Suit && Number == other.Number;
}
static class Sort
{
    public static bool IsStable<T, U>(T[] before, T[] after, IEqualityComparer<T> keycomparer, Func<T, U> keyselector)
    {
        var ddic = before.GroupBy(keyselector).ToDictionary(g => g.Key, g => new Queue<T>(g));
        for (int i = 0; i < after.Length - 1; i++)
        {
            if (keycomparer.Equals(after[i], after[i + 1]))
            {
                if (!after[i].Equals(ddic[keyselector(after[i])].Dequeue()))
                {
                    return false;
                }
            }
        }
        return true;
    }
    public static T[] QuickSort<T>(T[] array, IComparer<T> comparer)
    {
        var A = (T[])array.Clone();
        internalQuickSort(A, 0, A.Length - 1, comparer);
        return A;
    }
    static void internalQuickSort<T>(T[] A, int p, int r, IComparer<T> comparer)
    {
        if (p < r)
        {
            var q = internalPartition(A, p, r, comparer);
            internalQuickSort(A, p, q - 1, comparer);
            internalQuickSort(A, q + 1, r, comparer);
        }
    }
    static int internalPartition<T>(T[] A, int p, int r, IComparer<T> comparer)
    {
        var x = A[r];
        var i = p;
        for (int j = p; j < r; j++)
        {
            if (comparer.Compare(A[j], x) <= 0)
            {
                Swap(ref A[i++], ref A[j]);
            }
        }
        Swap(ref A[i], ref A[r]);
        return i;
    }
}
internal class Tools
{
    public static void Swap<T>(ref T a, ref T b)
    {
        var t = a;
        a = b;
        b = t;
    }
}

internal static class Extensions
{
    public static int ParseInt(this string s) => int.Parse(s);
}
