#include<bits/stdc++.h>
/*
#include<atcoder/all>
using namespace atcoder;
//using mint = modint1000000007;
using mint = modint998244353;
*/
//g++ -I/opt/ac-library ./**.cpp
using namespace std;
using ll = long long;
using ull = unsigned long long;
//const long long MOD = 1000000007;
const long long MOD = 998244353;
const long double PI = 3.14159265358979;
const long long INF = 1LL<<60;
template <typename T> bool chmax(T &a, const T& b){if(a < b){a = b;return true;}return false;}
template <typename T> bool chmin(T &a, const T& b){if(a > b){a = b;return true;}return false;}
#define deb(var) do{cout << #var << " : "; view(var);}while(0)
template<typename T> void view(T e){cout << e << endl;}
void view(vector<string>& v){cout << endl;for(auto& s :v){view(s);}cout << endl;}
template<typename T> void view(vector<T>& v){for(auto& e :v){cout << e << " ";}cout << endl;}
template<typename T> void view(vector<vector<T>>& vv){cout << endl;for(auto& v:vv){view(v);}}
ll gcd(ll a, ll b){if (b == 0) return a;else return gcd(b, a % b);}
ll lcm(ll x,ll y){return ll(x/gcd(x,y))*y;}
template<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define int long long

int di[] = {-1, 0, 1, 0};
int dj[] = {0, -1, 0, 1};

bool valid(int i, int j, int h, int w) {
    if(0<=i and 0<=j and i<h and j<w) return true;
    else return false;
}

template<class T, class U>
vector<vector<int>> grid_bfs(int si, int sj, const T& field, U ok) {
    int di[4] = {-1, 0, 1, 0};
    int dj[4] = {0, -1, 0, 1};
    int h = field.size();
    int w = field[0].size();
    vector< vector<int> > dist(h, vector<int> (w, INF));
    dist[si][sj] = 0;
    queue<int> qi, qj;
    qi.push(si); qj.push(sj);

    while (!qi.empty()) {
        int ci = qi.front();
        int cj = qj.front();
        qi.pop(); qj.pop();
        for (int k = 0; k < 4; k++) {
            int ni = ci + di[k];
            int nj = cj + dj[k];
            if (0 <= ni and 0 <= nj and ni < h and nj < w and field[ni][nj] == ok) {
                if (chmin( dist[ni][nj], dist[ci][cj] + 1 )) {
                    qi.push(ni); qj.push(nj);
                }
            } 
        }
    }
    return dist;
}

int32_t main() {
    int h, w, n; cin >> h >> w >> n;
    int si, sj, gi, gj; cin >> si >> sj >> gi >> gj;
    si--; sj--; gi--; gj--;
    vector<int> x(n), y(n), k(n);
    vector<vector<int>> s(h, vector<int>(w, 0));
    for (int _i=0; _i<n; _i++) {
        cin >> x[_i] >> y[_i] >> k[_i];
        x[_i]--; y[_i]--;
        int X = x[_i];
        int Y = y[_i];
        int K = k[_i];
        int i = X;
        int j = Y - K;
        for (int _=0; _<=K; _++) {
            s[i][j] = 1;
            i++; j++;
        }
        i = X + K;
        j = Y;
        for (int _=0; _<=K; _++) {
            s[i][j] = 1;
            i--; j++;
        }
        i = X;
        j = Y + K;
        for (int _=0; _<=K; _++) {
            s[i][j] = 1;
            i--; j--;
        }
        i = X - K;
        j = Y;
        for (int _=0; _<=K; _++) {
            s[i][j] = 1;
            i++; j--;

        }
    }
    auto res = grid_bfs (si, sj, s, 0);
    if (res[gi][gj] != INF) cout << "Yes" << endl;
    else cout << "No" << endl;
}


