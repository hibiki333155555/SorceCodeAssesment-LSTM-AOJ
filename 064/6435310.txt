#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
using pll = pair<ll, ll>;
using tlll = tuple<ll, ll, ll>;
constexpr ll INF = 1LL << 60;
template<class T> bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}
template<class T> bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}
ll safemod(ll A, ll M) {return (A % M + M) % M;}
ll divfloor(ll A, ll B) {if (B < 0) {return divfloor(-A, -B);} return (A - safemod(A, B)) / B;}
ll divceil(ll A, ll B) {if (B < 0) {return divceil(-A, -B);} return divfloor(A + B - 1, B);}
template<class T> void unique(vector<T> &V) {V.erase(unique(V.begin(), V.end()), V.end());}
template<class T> void sortunique(vector<T> &V) {sort(V.begin(), V.end()); V.erase(unique(V.begin(), V.end()), V.end());}
#define FINALANS(A) do {cout << (A) << '\n'; exit(0);} while (false)
template<class T> void printvec(vector<T> &V) {int _n = V.size(); for (int i = 0; i < _n; i++) cout << V[i] << (i == _n - 1 ? "" : " ");cout << '\n';}
template<class T> void printvect(vector<T> &V) {for (auto v : V) cout << v << '\n';}
template<class T> void printvec2(vector<vector<T>> &V) {for (auto &v : V) printvec(v);}

template <typename Cost>
struct Edge
{
  int from, to;
  Cost cost;
  Edge(int s, int t, Cost c = 1) : from(s), to(t), cost(c) {}
  operator int() const { return to; }
};
template <typename Cost>
struct Graph : vector<vector<Edge<Cost>>>
{
  Graph(int n) : vector<vector<Edge<Cost>>>(n) {}
  void add_edge(int s, int t, Cost c = 1) { (*this)[s].emplace_back(s, t, c); }
  void add_edge2(int s, int t, Cost c = 1) { add_edge(s, t, c), add_edge(t, s, c); }
};

// https://qiita.com/drken/items/a803d4fc4a727e02f7ba#4-6-%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E6%A4%9C%E5%87%BA
template<typename Cost>
struct Cycle : Graph<Cost>
{
  vector<bool> seen, finished;
  int pos;
  stack<int> his;

  Cycle(int n) : Graph<Cost>::Graph(n) {}

  vector<int> run()
  {
    seen.resize((*this).size(), false);
    finished.resize((*this).size(), false);
    pos = -1;
    dfs(0, -1);

    vector<int> cycle;
    while (!his.empty())
    {
      int t = his.top();
      cycle.emplace_back(t);
      his.pop();
      if (t == pos)
        break;
    }
    return cycle;
  }

  void dfs(int v, int pv)
  {
    seen[v] = true;
    his.push(v);
    for (auto nv : (*this)[v])
    {
      if (nv == pv)
        continue;
      if (finished[nv])
        continue;
      if (seen[nv] && !finished[nv])
      {
        pos = nv;
        return;
      }

      dfs(nv, v);

      if (pos != -1)
        return;
    }
    his.pop();
    finished[v] = true;
  }
};

int main()
{
  ll N;
  cin >> N;
  Cycle<ll> gr(N);
  for (ll i = 0; i < N; i++)
  {
    ll u, v;
    cin >> u >> v;
    u--, v--;
    gr.add_edge2(u, v);
  }

  auto res = gr.run();
  vector<bool> in(N, false);
  for (auto v : res)
    in[v] = true;

  ll Q;
  cin >> Q;
  for (ll q = 0; q < Q; q++)
  {
    ll a, b;
    cin >> a >> b;
    a--, b--;
    cout << (in[a] && in[b] ? 2 : 1) << '\n';
  }
}
