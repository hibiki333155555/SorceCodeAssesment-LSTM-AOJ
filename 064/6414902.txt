#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
#define inf 1000000007
#define MP make_pair
#define MT make_tuple
#define PB push_back
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (int)(n); ++i)
#define rrep(i,n) for(int i = (int)n-1; i >= 0; --i)
#define srep(i,a,b) for(int i = (int)a; i < (int)(b); ++i)
#define all(x) (x).begin(),(x).end()
#define SUM(v) accumulate(all(v), 0LL)
#define MIN(v) *min_element(all(v))
#define MAX(v) *max_element(all(v))
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())
#define SZ(c) (int)(c).size()
template<typename T>
ostream& operator << (ostream& os, vector<T>& vec) {
    os << "{";
    for (int i = 0; i<(int)vec.size(); i++) {
        os << vec[i] << (i + 1 == (int)vec.size() ? "" : ", ");
    }
    os << "}";
    return os;
}
// pair出力
template<typename T, typename U>
ostream& operator << (ostream& os, pair<T, U> pair_var) {
    os << "(" << pair_var.first << ", " << pair_var.second << ")";
    return os;
}
// map出力
template<typename T, typename U>
ostream& operator << (ostream& os, map<T, U>& map_var) {
    os << "{";
    for(auto itr = map_var.begin(); itr != map_var.end(); itr++){
        os << "(" << itr->first << ", " << itr->second << ")";
        itr++;
        if(itr != map_var.end()) os << ", ";
        itr--;
    }
    os << "}";
    return os;
}
// set 出力
template<typename T>
ostream& operator << (ostream& os, set<T>& set_var) {
    os << "{";
    for(auto itr = set_var.begin(); itr != set_var.end(); itr++){
        os << (*itr);
        ++itr;
        if(itr != set_var.end()) os << ", ";
        itr--;
    }
    os << "}";
    return os;
}
// tuple 出力
template<int N,class Tuple>
void out(ostream &os,const Tuple &t){}
template<int N,class Tuple,class H,class ...Ts>
void out(ostream &os,const Tuple &t){
    if(N)os<<", ";
    os<<get<N>(t);
    out<N+1,Tuple,Ts...>(os,t);
}
template<class ...Ts>
ostream& operator<<(ostream &os, const tuple<Ts...> &t){
    os<<"(";
    out<0,tuple<Ts...>,Ts...>(os,t);
    os<<")";
    return os;
}
int scan() { return getchar(); }
void scan(int &a) { cin >> a; }
void scan(long long &a) { cin >> a; }
void scan(char &a) { cin >> a; }
void scan(double &a) { cin >> a; }
void scan(string &a) { cin >> a; }
template <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }
template <class T> void scan(vector<T> &);
template <class T> void scan(vector<T> &a) {
    for(auto &i : a) scan(i);
}
template <class T> void scan(T &a) { cin >> a; }
void IN() {}
template <class Head, class... Tail> void IN(Head &head, Tail &...tail) {
    scan(head);
    IN(tail...);
}
const string YESNO[2] = {"NO", "YES"};
const string YesNo[2] = {"No", "Yes"};
const string yesno[2] = {"no", "yes"};
void YES(bool t = 1) { cout << YESNO[t] << endl; }
void NO(bool t = 1) { YES(!t); }
void Yes(bool t = 1) { cout << YesNo[t] << endl; }
void No(bool t = 1) { Yes(!t); }
void yes(bool t = 1) { cout << yesno[t] << endl; }
void no(bool t = 1) { yes(!t); }
#ifdef LOCAL
void debug_out() { cerr << endl; }
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
    cerr << " " << H;
    debug_out(T...);
}
#define dbg(...) \
    cerr << __LINE__ << " [" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
#else
#define dbg(...) (void(0))
#define dump(x) (void(0))
#endif
template<typename A, typename T>
std::enable_if_t<std::is_convertible<T, A>::value> fill(A& array, const T& val)
{
    array = val;
}
template<typename A, typename T>
std::enable_if_t<!std::is_convertible<T, A>::value> fill(A& array, const T& val)
{
    for (auto& a : array) {
        fill(a, val);
    }
}
template <typename T, typename S> T ceil(T x, S y) {
    assert(y);
    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));
}
template <typename T, typename S> T floor(T x, S y) {
    assert(y);
    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));
}
vector<int> iota(int n) {vector<int> a(n);iota(all(a), 0);return a;}
template <class T> T POW(T x, int n) {T res = 1;for(; n; n >>= 1, x *= x){if(n & 1) res *= x;}return res;}
ll pow2(int i) { return 1LL << i; }
int topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }
int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }
int lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }
int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }
// int allbit(int n) { return (1 << n) - 1; }
ll allbit(ll n) { return (1LL << n) - 1; }
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }


template <class S> void fold_in(vector<S> &v) {}
template <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {
    for(auto e : a) v.emplace_back(e);
    fold_in(v, tail...);
}
template <class S> void renumber(vector<S> &v) {}
template <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {
    for(auto &&e : a) e = lb(v, e);
    renumber(v, tail...);
}
template <class S, class... Args> void zip(vector<S> &head, Args &&...args) {
    vector<S> v;
    fold_in(v, head, args...);
    sort(all(v)), v.erase(unique(all(v)), v.end());
    renumber(v, head, args...);
}
template<class T> inline bool chmax(T &a, T b){
    if(a<b){
        a = b;
        return true;
    }
    return false;
}
template<class T> inline bool chmin(T &a, T b){
    if(a>b){
        a = b;
        return true;
    }
    return false;
}

#define MOD 998244353

template <unsigned int mod>
class ModInt {
private:
    unsigned int v;
    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }
    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }
    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }
    static unsigned int inverse(int a, int m){
        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;
        while(*v){
            t = *u / *v;
            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);
        }
        return (u[1] % m + m) % m;
    }

public:
    ModInt() : v{0}{}
    ModInt(const long long val) : v{norm(val % mod + mod)} {}
    ModInt(const ModInt<mod>& n) : v{n()} {}
    explicit operator bool() const noexcept { return v != 0; }
    bool operator!() const noexcept { return !static_cast<bool>(*this); }
    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }
    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }
    ModInt operator+() const { return *this; }
    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }
    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }
    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }
    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }
    ModInt operator/(const ModInt& val) const { return *this * inv(val); }
    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }
    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }
    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }
    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }
    ModInt operator+(const long long val) const { return ModInt{v + val}; }
    ModInt operator-(const long long val) const { return ModInt{v - val}; }
    ModInt operator*(const long long val) const { return ModInt{(long long)(v * (val % mod))}; }
    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }
    ModInt& operator+=(const long long val){ return *this = *this + val; }
    ModInt& operator-=(const long long val){ return *this = *this - val; }
    ModInt& operator*=(const long long val){ return *this = *this * val; }
    ModInt& operator/=(const long long val){ return *this = *this / val; }
    bool operator==(const ModInt& val) const { return v == val.v; }
    bool operator!=(const ModInt& val) const { return !(*this == val); }
    bool operator==(const long long val) const { return v == norm(val % mod + mod); }
    bool operator!=(const long long val) const { return !(*this == val); }
    unsigned int operator()() const { return v; }
    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }
    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }
    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }
    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }
    friend bool operator==(const long long val, const ModInt& n) { return n == val; }
    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }
    friend istream& operator>>(istream& is, ModInt& n){
        unsigned int v;
        return is >> v, n = v, is;
    }
    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }
    friend ModInt mod_pow(ModInt x, long long n){
        ModInt ans = ((mod == 1) ? 0 : 1);
        while(n){
            if(n & 1) ans *= x;
            x *= x, n >>= 1;
        }
        return ans;
    }
};

template<typename T> class mat : public vector<vector<T> > {
private:
    int r, c;    //行,列
public:
    inline int row() const {
        return r;
    }
    inline int column() const {
        return c;
    }
    mat(int n, int m, T val = 0){
        r = n, c = m;
        for(int i = 0; i < n; i++){
            this->push_back(vector<T>(m, val));
        }
    }
    mat operator+(const mat& another) const {
        if(r != another.r && c != another.c){
            cout << "足し算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] + another[i][j];
            }
        }
        return X;
    }
    mat operator+(const T val) const {
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] + val;
            }
        }
        return X;
    }
    mat operator-(const mat& another) const {
        if(r != another.r && c != another.c){
            cout << "引き算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] - another[i][j];
            }
        }
        return X;
    }
    mat operator-(const T val) const {
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = (*this)[i][j] - val;
            }
        }
        return X;
    }
    vector<T> operator*(const vector<T>& another) const {
        if(c != (int)another.size()){
            cout << "掛け算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        vector<T> vec(r,0);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                vec[i] += (*this)[i][j] * another[j];
            }
        }
        return vec;
    }
    mat operator*(const mat& another) const {
        if(c != another.r){
            cout << "掛け算失敗(サイズ不一致)" << endl;
            exit(1);
        }
        mat<T> X(r, another.c);
        for(int i = 0; i < r; i++){
            for(int k = 0; k < c; k++){
                for(int j = 0; j < (another.c); j++){
                    X[i][j] += (*this)[i][k] * another[k][j];
                }
            }
        }
        return X;
    }
    mat operator-() const {
        mat<T> X(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                X[i][j] = -(*this)[i][j];
            }
        }
        return X;
    }
    int rank() const {
        int res = 0;
        mat B(r, c);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                B[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i < c; i++){
            if(res == r) return res;
            int pivot = res;
            for(int j = res; j < r; j++){
                if(B[j][i]){
                    pivot = j;
                    break;
                }
            }
            if(!B[pivot][i]) continue;
            swap(B[pivot], B[res]);
            const T d = (T)1 / B[res][i];
            for(int j = i + 1; j < c; j++){
                B[res][j] *= d;
            }
            for(int j = res + 1; j < r; j++){
                if(!B[j][i]) continue;
                for(int k = i + 1; k < c; k++){
                    B[j][k] -= B[res][k] * B[j][i];
                }
            }
            ++res;
        }
        return res;
    }
    T det() const {
        if(r != c){
            cout << "正方行列でない(行列式定義不可)" << endl;
            exit(1);
        }
        T ans = 1;
        mat B(r, r);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < c; j++){
                B[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i < c; i++){
            int pivot = i;
            for(int j = i; j < r; j++){
                if(B[j][i]){
                    pivot = j;
                    break;
                }
            }
            if(!B[pivot][i]) return (T)0;
            if(pivot != i) swap(B[i], B[pivot]), ans = -ans;
            ans *= B[i][i];
            const T d = (T)1 / B[i][i];
            for(int j = i + 1; j < c; j++){
                B[i][j] *= d;
            }
            for(int j = i + 1; j < r; j++){
                if(!B[j][i]) continue;
                for(int k = i + 1; k < c; k++){
                    B[j][k] -= B[i][k] * B[j][i];
                }
            }
        }
        return ans;
    }
    mat inverse() const {
        if(r != c){
            cout << "正方行列でない(逆行列定義不可)" << endl;
            exit(1);
        }
        mat B(r, 2*r);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < r; j++){
                B[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i < r; i++){
            B[i][r+i] = 1;
        }
        for(int i = 0; i < r; i++){
            int pivot = i;
            for(int j = i; j < r; j++){
                if(B[j][i]){
                    pivot = j;
                    break;
                }
            }
            if(!B[pivot][i]){
                cout << "正則でない" << endl;
                exit(1);
            }
            swap(B[i], B[pivot]);
            const T d = (T)1 / B[i][i];
            for(int j = i + 1; j < 2*r; j++){
                B[i][j] *= d;
            }
            for(int j = 0; j < r; j++){
                if(j == i || !B[j][i]) continue;
                for(int k = i + 1; k < 2*r; k++){
                    B[j][k] -= B[i][k] * B[j][i];
                }
            }
        }
        mat res(r, r);
        for(int i = 0; i < r; i++){
            for(int j = 0; j < r; j++){
                res[i][j] = B[i][r+j];
            }
        }
        return res;
    }
    inline void print() const {
        for(int i = 0; i < r; i++){
            for(int j = 0; j < (c-1); j++){
                cout << (*this)[i][j] << ",";
            }
            cout << (*this)[i][c-1] << endl;
        }
    }
};

template<typename T> vector<T> eq_solve(const mat<T>& A, const vector<T>& b){
    if(A.row() != A.column()){
        cout << "正方行列でない(解なしor不定)" << endl;
        exit(1);
    }
    int n = A.row();
    mat<T> B(n, n+1);
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            B[i][j] = A[i][j];
        }
    }
    for(int i = 0; i < n; i++){
        B[i][n] = b[i];
    }
    for(int i = 0; i < n; i++){
        int pivot = i;
        for(int j = i; j < n; j++){
            if(B[j][i]){
                pivot = j;
                break;
            }
        }
        if(!B[pivot][i]){
            cout << "解なしor不定" << endl;
            exit(1);
        }
        swap(B[i], B[pivot]);
        const T d = (T)1 / B[i][i];
        for(int j = i + 1; j <= n; j++){
            B[i][j] *= d;
        }
        for(int j = 0; j < n; j++){
            if(i != j){
                for(int k = i + 1; k <= n; k++){
                    B[j][k] -= B[i][k] * B[j][i];
                }
            }
        }
    }
    vector<T> res(n);
    for(int i = 0; i < n; i++){
        res[i] = B[i][n];
    }
    return res;
}

template<typename T> mat<T> pow(mat<T> A, long long cnt)
{
    if(A.row() != A.column()){
        cout << "累乗不可" << endl;
    }
    int n = A.row();
    mat<T> B(n, n);
    for(int i = 0; i < n; i++){
        B[i][i] = 1;
    }
    while(cnt > 0){
		if(cnt & 1) B = B * A;
        A = A * A;
        cnt >>= 1;
    }
    return B;
}

using mod = ModInt<MOD>;

// 宣言 mat<mod> A(n, m); 
int main(){
    int n;
    cin >> n;
    if(n==2){
        cout << 2 << endl;
        return 0;
    }
    map<vector<int>,int> num;
    vector<int> p(3);
    int c = 0;
    auto dfs = [&](auto&&f,int id,int s){
        if(id==2){
            p[2] = n-s;
            num[p] = c;
            c++;
            return;
        }
        rrep(i,n-s+1){
            p[id] = i;
            f(f,id+1,s + p[id]);
        }
    };
    dfs(dfs,0,0);
    mat<mod> P(c-1,c-1);
    rep(i,c-1)P[i][i] = 1;
    mod DV = n*(n-1)/2;
    DV = (mod)1/DV;
    auto dfs2 = [&](auto&&f,int id,int s){
        if(id==2){
            p[2] = n-s;
            int a = num[p];
            if(a==c-1)return;
            rep(i,3){
                rep(j,i+1){
                    vector<int> q = p;
                    mod C;
                    int b;
                    if(i==j){
                        if(q[i]<2)continue;
                        C = q[i]*(q[i]-1)/2 * DV;
                        q[i] -= 2;
                        q[(i+1)%3]+=2;
                        b = num[q];
                    }else{
                        if(q[i]<1||q[j]<1)continue;
                        C = q[i]*q[j] * DV;
                        q[i]--;
                        q[(i+1)%3]++;
                        q[j]--;
                        q[(j+1)%3]++;
                        b = num[q];
                    }
                    if(b==c-1)continue;
                    
                    P[a][b] -= C;
                }
            }
            return;
        }
        rrep(i,n-s+1){
            p[id] = i;
            f(f,id+1,s + p[id]);
        }
    };
    dfs2(dfs2,0,0);
    vector<mod> ss(c-1,1);
    auto res = eq_solve(P,ss);
    cout << res[0] << endl;
    return 0;
}
