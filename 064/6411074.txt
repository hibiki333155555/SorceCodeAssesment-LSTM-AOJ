
from collections import deque, defaultdict
import heapq

class CostGraph:
    '''辺に重みがあるグラフ
    使い方:
        頂点名にはイミュータブルなものが使える
            int, str, tuple等
        単一始点最短経路
        ・幅優先探索 bfs() O(|E|)
            重みが 1 のとき
        ・ベルマンフォード法 bellman() O(|V||E|)
            負の重みも可
        ・ダイクストラ法 dijkstra() O(|E|log|V|)
            重みは正のみ
        全点対最短経路
        ・ワーシャルフロイド法 warshall() O(|V|^3)
            メモリも O(|V|^2) 使う
        最小全域木
        ・プリム法 prim() O(|V|^2)
        ・クラスカル法 kruskal() O(|E|log|V|)
    '''

    def __init__(self):
        '''初期化 CostGraph()
        Returns:
            void
        '''
        self.vertex = set()
        self.edges = defaultdict(list)  # 辺の情報
        self.pos = []  # 辺の番号 (From, edges[From]内の辺情報の位置)
        self.dist = dict()  # 距離をメモするところ
        self.prev = dict()  # 直前の通過点をメモするところ [i][j] := i→jでjの直前に訪れる場所

    def addVertex(self, name):
        '''頂点の追加 addVertex(頂点名)
        使い方:
            頂点名は int, str, tuple等イミュータブルなもの
            辺を追加するときにも頂点が追加される
        Args:
            name (immutable): 頂点の名前
        Returns:
            void
        '''
        self.vertex.add(name)

    def addEdge(self, From, To, dist=1):
        '''辺の追加 addEdge(始点名, 終点名, 重み)
        Args:
            From (immutable): 始点の名前
            To (immutable): 終点の名前
            dist (num): 辺の重み, 初期値 1
        Returns:
            int: 辺の番号
        '''
        self.addVertex(From)
        self.addVertex(To)
        m = len(self.pos)
        self.pos.append((From, len(self.edges[From])))
        self.edges[From].append({'to':To, 'dist':dist})
        return m

    def getEdge(self, i):
        '''辺情報の取得 getEdge(辺番号)
        Args:
            i (int): 辺の番号
        Returns:
            dict: 辺の情報 {'from':始点, 'to':終点, 'dist':重み}
        '''
        assert 0 <= i < len(self.pos)
        e = self.edges[self.pos[i][0]][self.pos[i][1]]
        return {'from':self.pos[i][0],
                'to':e['to'],
                'dist':e['dist']}

    def getGraph(self):
        '''全ての辺の情報を取得
        Returns:
            list: i番目の辺のdict
        '''
        res = []
        for i in range(len(self.pos)):
            res.append(self.getEdge(i))
        return res

    def changeEdge(self, i, dist):
        '''辺の容量を変更する changeEdge(辺番号, 新重み)
        Args:
            i (int): 変更する辺の番号
            dist (num): 変更後の重み
        Returns:
            void
        '''
        assert 0 <= i < len(self.pos)
        e = self.edges[self.pos[i][0]][self.pos[i][1]]
        e['dist'] = dist

    def getDistance(self, st, gl):
        '''2点間の最短距離を取得
        使い方:
            先に距離を求める関数を実行しておく
        Args:
            st (immutable): 始点の名前
            gl (immutable): 終点の名前
        Returns:
            num: 2点間の距離
        '''
        return self.dist[st][gl]

    def getRoute(self, st, gl):
        '''2点間の最短ルートを取得 O(min(|E|,|V|))?
        使い方:
            先にgetDistanceで到達可能か判定しておく
        Args:
            st (immutable): 始点の名前
            gl (immutable): 終点の名前
        Returns:
            immutable[]: 始点終点を含む、通過する点
        '''
        route = [gl]
        while route[-1] != st:
            route.append(self.prev[st][route[-1]])
        route.reverse()
        return route

    # ---------- ここから 単一始点最短経路 ----------

    def bfs(self, st, inf=-1):
        '''1点からの最短距離を計算 bfs(始点, inf=到達不可能を表すモノ) O(|E|)
        Args:
            st (int): 始点の番号
            inf (any): 到達不可能なときの値 初期値-1
        Returns:
            void
        '''
        d = defaultdict(lambda :inf)
        d[st] = 0
        pre = {key: key for key in self.vertex}
        q = deque()
        q.append(st)
        while q:
            now = q.popleft()
            for e in self.edges[now]:
                if d[e['to']] != inf:
                    continue
                d[e['to']] = d[now] + e['dist']
                pre[e['to']] = now
                q.append(e['to'])
        self.dist[st] = d
        self.prev[st] = pre

    def bellman(self, st, inf=(1<<63)-1):
        '''1点からの最短距離を計算 bellman(始点, inf=到達不可能を表すモノ) O(|V||E|)
        Args:
            st (int): 始点の番号
            inf (any): 到達不可能なときの値 初期値-1
        Returns:
            boolean: 負の閉路の有無
        '''
        d = defaultdict(lambda :inf)
        d[st] = 0
        pre = {key: key for key in self.vertex}
        V = len(self.vertex)
        for i in range(V):
            for e in self.pos:
                efrom = e[0]
                eto = self.edges[efrom][e[1]]['to']
                edist = self.edges[efrom][e[1]]['dist']
                if d[efrom] != inf:
                    if d[eto] == inf or d[eto] > d[efrom] + edist:
                        if i == V-1:
                            return True
                        d[eto] = d[efrom] + edist
                        pre[eto] = efrom
        self.dist[st] = d
        self.prev[st] = pre
        return False

    def dijkstra(self, st, inf=-1):
        '''1点からの最短距離を計算 dijkstra(始点, inf=到達不可能を表すモノ) O(|E|log|V|)
        Args:
            st (int): 始点の番号
            inf (any): 到達不可能なときの値 初期値-1
        Returns:
            void
        '''
        d = defaultdict(lambda :inf)
        d[st] = 0
        pre = {key: key for key in self.vertex}
        q = [(0, st)]
        while q:
            [dist, now] = heapq.heappop(q)
            for e in self.edges[now]:
                next = e['to']
                if d[next] == inf or d[next] > dist + e['dist']:
                    d[next] = dist + e['dist']
                    pre[next] = now
                    heapq.heappush(q, (d[next], next))
        self.dist[st] = d
        self.prev[st] = pre

    # ---------- ここから 全点対最短経路 ----------

    def warshall(self, inf=(1<<63)-1):
        '''全ての点の組の最短距離を計算 warshall(inf=到達不可能を表すモノ) O(|V|^3)
        Args:
            inf (any): 到達不可能なときの値 初期値-1
        Returns:
            boolean: 負の閉路の有無
        '''
        d = defaultdict(lambda :defaultdict(lambda :inf))
        for key in self.vertex:
            d[key][key] = 0
        for fro, val in self.edges.items():
            for e in val:
                d[fro][e['to']] = e['dist']
        pre = {key1: {key: key for key in self.vertex} for key1 in self.vertex}
        for k in self.vertex:
            for i in self.vertex:
                for j in self.vertex:
                    if d[i][k] != inf and d[k][j] != inf:
                        if d[i][j] == inf or d[i][j] > d[i][k] + d[k][j]:
                            d[i][j] = d[i][k] + d[k][j]
                            pre[i][j] = k
        self.dist = d
        self.prev = pre
        for key in self.vertex:
            if d[key][key] < 0:
                return True
        return False

def main():
    # 入力・下処理
    V, E = map(int, input().split())
    # 計算・出力
    cg = CostGraph()
    for _ in range(E):
        s, t, d = map(int, input().split())
        cg.addEdge(s, t, d)
    if cg.warshall('INF'):
        print('NEGATIVE CYCLE')
    else:
        for i in range(V):
            print(*[cg.getDistance(i, r) for r in range(V)])



if __name__ == "__main__":
    main()

