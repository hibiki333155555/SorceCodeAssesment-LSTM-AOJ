//#include "KowerKoint/base.hpp"

/* #include <atcoder/all> */
/* using namespace atcoder; */
/* #include "KowerKoint/expansion/ac-library/all.hpp" */
#include <bits/stdc++.h>
using namespace std;
using VI = vector<int>;
using ll = long long;
constexpr int mod = 998244353;
#include "ei1333/math/combinatorics/mod-int.cpp"
#include "ei1333/math/matrix/matrix.cpp"
using VL = vector<ll>;
using VVL = vector<VL>;
using VP = vector<pair<int, int>>;
#define REP(i, n) for(int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for(ll i = a; i < (ll)(b); i++)
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

void solve(){
    int H, W, n; cin >> H >> W >> n;
    int sx, sy, gx, gy ; cin >> sx >> sy >> gx >> gy; sx--; sy--; gx--; gy--;
    bool reverse = false;
    if(H > W) {
        reverse = true;
        swap(H, W);
        swap(sx, sy);
        swap(gx, gy);
    }
    VVL imos(H, VL(W+1));
    REP(_, n) {
        int x, y, k; cin >> x >> y >> k;
        x--; y--;
        if(reverse) swap(x, y);
        FOR(xx, x - k, x+k+1) {
            int d = k - abs(x - xx);
            imos[xx][y-d]++;
            imos[xx][y+1+d]--;
        }
    }
    REP(h, H) {
        FOR(w, 1, W+1) {
            imos[h][w] += imos[h][w-1];
        }
    }
    VP edges;
    REP(h, H) REP(w, W) {
        REP(_, 4) {
            int dh = DX[_], dw = DY[_];
            if(0<=h+dh && h+dh<H && 0<=w+dw && w+dw < W && imos[h][w] == 0 && imos[h+dh][w+dw] == 0) {
                edges.emplace_back(h*W+w, (h+dh)*W+(w+dw));
            }
        }
    }
    using VVI =vector<VI>;
    VVI g(H*W);
    for(auto [u, v] : edges) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    constexpr ll LINF = 1001001001001001001ll;
    VL dist(H*W, LINF);
    queue<int> que;
    que.push(sx*W+sy);
    while(!que.empty()) {
        int from = que.front(); que.pop();
        for(int to : g[from]) {
            if(dist[to] == LINF) {
                dist[to] = dist[from]+1;
                que.push(to);
            }
        }
    }
    cout << (dist[gx*W+gy] == LINF? "Yes" : "No") << '\n';
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    // Fasterize input/output script
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << fixed << setprecision(100);
    // scanf/printf user should delete this fasterize input/output script

    int t = 1;
    //cin >> t; // comment out if solving multi testcase
    for(int testCase = 1;testCase <= t;++testCase){
        solve();
    }
    return 0;
}

