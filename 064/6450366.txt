#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<pll> vpll;

#define FOR(i, a, b) for(ll i=(a); i<(b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define NREP(i, n) FOR(i, 1, n+1)

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

using SimpleGraph = vector<vector<ll>>;
struct Edge{
    ll to, cost;
    Edge(ll t, ll c) : to(t), cost(c) { }
};
using Graph = vector<vector<Edge>>;
struct Edge3{
    ll from, to, cost;
    Edge3(ll f, ll t, ll c) : from(f), to(t), cost(c) { }
};
using EdgeGraph = vector<vector<Edge3>>;

ll gcd(ll a, ll b){
	if(a%b==0) return b;
	else return gcd(b,a%b);
}

ll lcm(ll a, ll b){
	return a/gcd(a,b)*b;
}

const ll INF = 1e18;

ll L[1<<21];

void init() {
    REP(bit, 1<<20) {
        ll res = 1;
        REP(i, 20) {
            if(bit & (1<<i)) {res = lcm(res, i+1);}
        }
        L[bit] = res;
    }
    return;
}

ll bert(ll v, ll n) {
    return v * 1000 + n;
}

int main(void){
    init();
    ll N, M; cin >> N >> M;
    vector<tuple<ll, ll, ll>> edge(M);
    REP(i, M) {
        ll a, b, c; cin >> a >> b >> c;
        a--, b--;
        edge[i] = {a, b, c};
    }
    
    ll cnt = 1;
    unordered_map<ll, ll> mp;
    mp[1] = 0;
    vl dict(1000, 1);
    REP(bit, 1<<20) {
        ll l = L[bit];
        if(mp[l] > 0) {continue;}
        mp[l] = cnt;
        dict[cnt] = l;
        cnt++;
    }
    dict.resize(cnt);
    
    SimpleGraph G(1000*N);
    REP(i, M) {
        auto [a, b, c] = edge[i];
        REP(i, cnt) {
            ll d = dict[i];
            ll l = lcm(d, c);
            
            ll v = bert(a, i), nv = bert(b, mp[l]);
            G[v].push_back(nv);
        }
    }
    
    vl dist(N * 1000, INF);
    queue<ll> que;
    que.push(0);
    dist[0] = 0;
    
    while(que.size()) {
        ll v = que.front();
        que.pop();
        
        for(auto nv:G[v]) {
            if(dist[nv] != INF) {continue;}
            dist[nv] = dist[v] + 1;
            que.push(nv);
        }
        
    }
    
    ll mn = INF, MX = -1;
    REP(i, cnt) {
        ll v = bert(N-1, i);
        if(dist[v] != INF) {
            ll mid = dict[i];
            chmin(mn, mid);
            chmax(MX, mid);
        }
    }
    
    if(MX == -1) {cout << "IMPOSSIBLE" << endl;}
    else {cout << mn << " " << MX << endl;}
    
    return 0;
}
