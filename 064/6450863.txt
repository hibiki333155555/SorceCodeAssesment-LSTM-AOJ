#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <numeric>
#include <algorithm>
#include <queue>
#include <string>
#include <random>
#include <array>
#include <climits>
#include <map>
#include <cassert>
#include <stack>
#include <iomanip>
#include <cfloat>
#include <bitset>
#include <fstream>
#include <chrono>


constexpr int MOD = 998244353;
long long int pow_mod(long long int base, int exp) {
	long long int result{ 1 };
	base %= MOD;
	while (exp > 0) {
		if (exp & 1) {
			result = result * base % MOD;
		}
		base = base * base % MOD;
		exp >>= 1;
	}
	return result;
}


constexpr int segment = 320;
int main() {
	std::vector<std::vector<int>> prime_factors(1'000'001);
	std::vector<int> inverse(prime_factors.size(), 1) ;
	for (auto i = 2; i < prime_factors.size(); ++i) {
		inverse[i] = (long long int)(MOD - MOD / i) * inverse[MOD % i] % MOD;
		if (prime_factors[i].empty()) {
			for (auto j = i; j < prime_factors.size(); j += i) {
				prime_factors[j].push_back(i);
			}
		}
	}
	int n; std::cin >> n;
	std::vector<int> num(n);
	for (auto& a : num) {
		std::cin >> a;
	}
	int q; std::cin >> q;
	std::vector<std::pair<int, int>> queries(q);
	for (auto& [from, until] : queries) {
		std::cin >> from >> until; --from;
	}
	std::vector<int> sorted(q); std::iota(sorted.begin(), sorted.end(), 0);
	std::sort(sorted.begin(), sorted.end(), [&queries](const int i, const int j) {return (queries[i].first / segment == queries[j].first / segment) ? queries[i].second < queries[j].second : queries[i].first / segment < queries[j].first / segment; });
	std::vector<int> prime_count(prime_factors.size(), 0);
	int left = 0;
	int right = 0;
	long long int value = 1L;
	std::vector<int> result(q);
	for (const auto i : sorted) {
		const auto [from, until] = queries[i];
		while (right < until) {
			const auto a = num[right++];
			value = value * a % MOD;
			for (const auto p : prime_factors[a]) {
				if (prime_count[p]++ == 0) {
					value = value * (p - 1) % MOD * inverse[p] % MOD;
				}
			}
		}
		while (until < right) {
			const auto a = num[--right];
			value = value * inverse[a] % MOD;
			for (const auto p : prime_factors[a]) {
				if (--prime_count[p] == 0) {
					value = value * p % MOD * inverse[p - 1] % MOD;
				}
			}
		}
		while (from < left) {
			const auto a = num[--left];
			value = value * a % MOD;
			for (const auto p : prime_factors[a]) {
				if (prime_count[p]++ == 0) {
					value = value * (p - 1) % MOD * inverse[p] % MOD;
				}
			}
		}
		while (left < from) {
			const auto a = num[left++];
			value = value * inverse[a] % MOD;
			for (const auto p : prime_factors[a]) {
				if (--prime_count[p] == 0) {
					value = value * p % MOD * inverse[p - 1] % MOD;
				}
			}
		}
		result[i] = (value + MOD) % MOD;
	}
	for (const auto r : result) {
		std::cout << r << '\n';
	}
}
