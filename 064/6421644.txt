#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> PP;
//#define MOD 1000000007
#define MOD 998244353
//#define INF 2305843009213693951
//#define INF 810114514
#define PI 3.141592653589
#define setdouble setprecision
#define REP(i,n) for(ll i=0;i<(n);++i)
#define OREP(i,n) for(ll i=1;i<=(n);++i)
#define RREP(i,n) for(ll i=(n)-1;i>=0;--i)
#define ALL(v) (v).begin(), (v).end()
#define GOODBYE do { cout << "-1" << endl; return 0; } while (false)
#define MM <<" "<<
#define Endl endl
#define debug true
#define debug2 false

template< typename T >
struct edge {
  int src, to;
  T cost;

  edge(int to, T cost) : src(-1), to(to), cost(cost) {}

  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}

  edge &operator=(const int &x) {
    to = x;
    return *this;
  }

  operator int() const { return to; }
};

template< typename T >
using Edges = vector< edge< T > >;
template< typename T >
using WeightedGraph = vector< Edges< T > >;
using UnWeightedGraph = vector< vector< int > >;
template< typename T >
using Matrix = vector< vector< T > >;


template< typename T >
vector< T > dijkstra(WeightedGraph< T > &g, int s) {
  const auto INF = numeric_limits< T >::max();
  vector< T > dist(g.size(), INF);

  using Pi = pair< T, int >;
  priority_queue< Pi, vector< Pi >, greater< Pi > > que;
  dist[s] = 0;
  que.emplace(dist[s], s);
  while(!que.empty()) {
    T cost;
    int idx;
    tie(cost, idx) = que.top();
    que.pop();
    if(dist[idx] < cost) continue;
    for(auto &e : g[idx]) {
      auto next_cost = cost + e.cost;
      if(dist[e.to] <= next_cost) continue;
      dist[e.to] = next_cost;
      que.emplace(dist[e.to], e.to);
    }
  }
  return dist;
}


int main(void){
    
    cin.tie(nullptr);
    ios::sync_with_stdio(false);

    ll H,W;
    cin >> H >> W;
    vector<string> C(H);
    REP(i,H){cin >> C[i];}

    ll sy,sx,gy,gx;
    REP(i,H){
        REP(j,W){
            if(C[i][j]=='S'){
                sy=i;sx=j;
            }
            if(C[i][j]=='G'){
                gy=i;gx=j;
            }
        }
    }

    ll dx[4] = {1,0,-1,0};
    ll dy[4] = {0,1,0,-1};

    WeightedGraph<ll> G(H*W);

    REP(i,H){
        REP(j,W){

            if(C[i][j]=='U'){
                if(i!=0 && C[i-1][j]!='#'){
                    G[i*W+j].emplace_back((i-1)*W+j,0);
                }
            }else if(C[i][j]=='D'){
                if(i!=H-1 && C[i+1][j]!='#'){
                    G[i*W+j].emplace_back((i+1)*W+j,0);
                }
            }else if(C[i][j]=='L'){
                if(j!=0 && C[i][j-1]!='#'){
                    G[i*W+j].emplace_back(i*W+(j-1),0);
                }
            }else if(C[i][j]=='R'){
                if(j!=W-1 && C[i][j+1]!='#'){
                    G[i*W+j].emplace_back(i*W+(j+1),0);
                }
            }else{
                REP(k,4){
                    ll y = i+dy[k], x = j+dx[k];
                    if(!(0<=y && y<H))continue;
                    if(!(0<=x && x<W))continue;
                    if(C[y][x]=='#')continue;
                    
                    G[i*W+j].emplace_back(y*W+x,1);
                }
            }

        }
    }

    vector<ll> d = dijkstra(G,sy*W+sx);
    ll Ans = d[gy*W+gx];
    
    if(Ans==9223372036854775807)Ans = -1;
    cout << Ans << endl;

    /*REP(i,H){
        REP(j,W){
            ll r = d[i*W+j];
            if(r==INF)r=-1;
            cout << r << " ";
        }cout << endl;
    }*/

    return 0;
}

