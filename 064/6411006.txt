#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    string s;
    while(cin >> s,s != "-1"){
        vector<char> node;
        node.push_back('?');
        vector<int> par;
        par.push_back(-1);
        int cur = 0;
        for(char c:s){
            if(c == '('){
                int v = (int)node.size();
                par.push_back(cur);
                node.push_back('?');
                cur = v;
            }
            else if(c == ')'){
                cur = par[cur];
            }
            else if(c == '+' or c == '-'){
                node[cur] = c;
            }
            else{
                par.push_back(cur);
                node.push_back(c);
            }
        }
        int n =  node.size();
        vector<vector<int>> g(n);
        for(int i=0;i<n;i++){
            if(par[i] == -1)continue;
            g[i].push_back(par[i]);
            g[par[i]].push_back(i);
        }
        const int inf = 1e9;
        // max
        map<pair<int,int>,int> dp1;
        // min
        map<pair<int,int>,int> dp2;
        int res = -inf;
        auto calc=[&](auto self,int s,int p)->pair<int,int>{
            if(dp1.find({s,p}) != dp1.end()){
                return {dp1[{s,p}],dp2[{s,p}]};
            }
            if(node[s] != '+' and node[s] != '-'){
                int u = node[s]-'0';
                dp1[{s,p}] = dp2[{s,p}] = u;
                return {u,u};
            }
            else if(node[s] == '+'){
                int u = 0;
                int uu = 0;
                for(int t:g[s]){
                    if(t == p)continue;
                    auto r = self(self,t,s);
                    u += r.first;
                    uu += r.second;
                }
                dp1[{s,p}] = u;
                dp2[{s,p}] = uu;
                return {u,uu};
            }
            else{ // '-'
                vector<pair<int,int>> v;
                for(int t:g[s]){
                    if(t == p)continue;
                    auto r = self(self,t,s);
                    v.push_back(r);
                }
                int u = -inf;
                int uu = inf;
                int sum = 0;
                for(auto p:v){
                    sum += p.second;
                }
                for(auto p:v){
                    u = max(u, p.first+p.second-sum);
                }
                sum = 0;
                for(auto p:v){
                    sum += p.first;
                }
                for(auto p:v){
                    uu = min(uu, p.first+p.second-sum);
                }
                dp1[{s,p}] = u;
                dp2[{s,p}] = uu;
                return {u,uu};
            }
        };
        for(int i=0;i<n;i++){
            if(node[i] == '+' or node[i] == '-'){
                res = max(res, calc(calc,i,n).first);
            }
        }
        cout << res << "\n";
    }
}

