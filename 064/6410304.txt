#include<bits/stdc++.h>
#include<cstdlib>
#include<string>
using namespace std;

struct Node{
    long long key;
    Node *parent, *left, *right;
};

struct Node *root, *NIL, *deleteKey;

void insert(long long k){
    Node *y = NIL;
    Node *x = root;
    Node *z;

    z = (Node *)malloc(sizeof(Node));
    z -> key = k;
    z -> left = NIL;
    z -> right = NIL;

    while(x != NIL){
        y = x;
        if(z -> key < x -> key){
            x = x -> left;
        }
        else{
            x = x -> right;
        }
    }
    z -> parent = y;
    if(y == NIL){
        root = z;
    }
    else{
        if(z -> key < y -> key){
            y -> left = z;
        }
        else{
            y -> right = z;
        }
    }
}

bool find(long long k){
    Node *x = root;
    while(x != NIL){
        if(x -> key == k){
            deleteKey = x;
            return true;
        }

        if(k < x-> key){
            x = x -> left;
        }
        else{
            x = x -> right;
        }
    }
    return false;
}

void findReport(long long k){
    if(find(k)){
        cout << "yes" << endl;
    }
    else{
        cout << "no" << endl;
    }
}

Node* getMinimum(Node *x){
    while(x -> left != NIL){
        x = x -> left;
    }
    return x;
}

Node* getSuccessor(Node *x){
    if(x -> right != NIL){
        return getMinimum(x -> right);
    }

    Node *y = x -> parent;
    while(y != NIL && x == y -> right){
        x = y;
        y = y -> parent;
    }
    return y;
}

void deleteNode(int k){
    if(!find(k)){ //キーとして値kを持つノードを特定
        return;
    }

    Node *y, *x;//yが削除対象のノード,xがyの子

    if(deleteKey -> left == NIL || deleteKey -> right == NIL){
        //子がいない、または子がちょうど一人
        y = deleteKey;
    }
    else{
        //子が2人いる
        y = getSuccessor(deleteKey);
        deleteKey -> key = y -> key;
    }


    //yの子の特定
    if(y -> left != NIL){
        //左に子がいる
        x = y -> left;
        x -> parent = y -> parent;
    }
    else if(y -> right != NIL){
        //左に子がいる
        x = y -> right;
        x -> parent = y -> parent;
    }
    else{
        x = NIL;
    }

    //yの親の特定
    if(y -> parent == NIL){
        x -> parent = NIL;
        root = x;
    }
    if(y -> parent -> left == y){
        //yがyの親の左の子であるとき
        y -> parent -> left = x;
    }
    else{
        y -> parent -> right = x;
    }

    free(y);

}



void inorder(Node *root){
    if(root == NIL){
        return;
    }
    inorder(root -> left);
    printf(" %lld", root -> key);
    inorder(root -> right);
}

void preorder(Node *root){
    if(root == NIL){
        return;
    }
    printf(" %lld", root -> key);
    preorder(root -> left);
    preorder(root -> right);
}

bool compareSize(char a[], char b[]){
    int sizeA = 0, sizeB = 0;
    while(a[sizeA] != '\0'){
        sizeA++;
    }

    while(b[sizeB] != '\0'){
        sizeB++;
    }

    if(sizeA == sizeB){
        return true;
    }
    else{
        return false;
    }
}

bool match(char a[], char b[]){
    bool flag = true;
    if(compareSize(a, b)){
        for(int i = 0; a[i] != '\0'; i++){
            if(a[i] != b[i]){
                flag = false;
                break;
            }
        }
        return flag;
    }
    else{
        return false;
    }
}

int main(){
    long long m, k;
    char call[10];
    char b[10] = "insert";
    char c[10] = "find";
    char d[10] = "delete";
    cin >> m;
    for(int i = 0; i < m; i++){
        scanf("%s", call);
        if(match(call, b)){
            cin >> k;
            insert(k);
        }
        else if(match(call, c)){
            cin >> k;
            findReport(k);
        }
        else if(match(call, d)){
            cin >> k;
            deleteNode(k);
        }
        else{
            inorder(root);
            cout << endl;
            preorder(root);
            cout << endl;
        }
    }
}

/*void nodeDelete(int k){
    if(!find(k)){
        return;
    }
    Node *child, *parentChild;
    bool leftExist = (deleteKey -> left != NIL), rightExist = (deleteKey -> right != NIL);

    if(leftExist && rightExist){ //ｚが2人の子を持つとき
        child = getSuccessor(deleteKey);
        deleteKey -> key = child -> key;
        Node *tmp = deleteKey;
        deleteKey = child;
        child = tmp;
    }
    else if(leftExist || rightExist){ //zが一人の子を持つとき
        if(leftExist){ //左の子がいる
            child = deleteKey -> left;
        }
        else{ //右の子がいる
            child = deleteKey -> right;
        }

        if(deleteKey -> parent -> left == deleteKey){ //ｚが親の左の子
            parentChild = deleteKey -> parent -> left;
        }
        else{ //zが親の右ノ子
            parentChild = deleteKey -> parent ->right;
        }
        parentChild = child;
        free(deleteKey);
    }
    else{ //子を持たないとき
        free(deleteKey);
    }


}*/

/*void deleteNode(long long k){
    if(!find(k)){
        return;
    }

    Node *y; //削除する節点

    if(deleteKey -> left == NIL || deleteKey -> right == NIL){
        //子がいない、または子が一人
        y = deleteKey;
    }
    else{ //子が2人いる
        y = getSuccessor(deleteKey);
    }
    Node *x;
    if(y -> left != NIL){
        x = y -> left;
    }
    else{
        x = y -> right;
    }

    if(x != NIL){
        x -> parent = y -> parent;
    }

    if(y -> parent == NIL){
        root = x;
    }
    else if(y == y -> parent -> left){
        y -> parent -> left = x; 
    }
    else{
        y -> parent -> right = x;
    }

    if(y != deleteKey){
        deleteKey -> key = y -> key;
    }

    free(y);
}*/
