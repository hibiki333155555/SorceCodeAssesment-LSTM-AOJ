use std::collections::{HashSet, VecDeque};

fn main() {
    let (n, m) : (usize, usize) = input_t();
    let mut g = vec![vec![]; n];

    for _ in 0..m {
        let (mut a, mut b, c) : (usize, usize, usize) = input_t3();
        a -= 1; b -= 1;
        g[a].push((b, c));
    }



    let mut q = VecDeque::new(); q.push_front(0);

    let mut lcms = vec![HashSet::new(); n];
    lcms[0].insert(1);

    while let Some(v) = q.pop_front() {
        for &(u, c) in g[v].iter() {
            let mut updated = false;

            let mut vec = HashSet::new();

            for &l in lcms[v].iter() { vec.insert(lcm(l, c)); }
            for v in vec { updated |= lcms[u].insert(v); }

            if updated { q.push_back(u); }
        }
    }

    if lcms[n-1].is_empty() { println!("IMPOSSIBLE"); return; }

    let min = *lcms[n-1].iter().min().unwrap();
    let max = *lcms[n-1].iter().max().unwrap();

    println!("{} {}", min, max);
}

fn gcd(a:usize, b:usize) -> usize {
    if a % b == 0 { b }
    else { gcd(b, a%b) }
}

fn lcm(a:usize, b:usize) -> usize {
    a / gcd(a,b) * b
}

#[allow(dead_code)] fn input<T: std::str::FromStr>() -> T { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); s.trim().parse().ok().unwrap() } #[allow(dead_code)] fn input_t<T: std::str::FromStr, U: std::str::FromStr>() -> (T, U) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap()) } #[allow(dead_code)] fn input_t3<T1: std::str::FromStr, T2: std::str::FromStr, T3: std::str::FromStr>() -> (T1, T2, T3) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap(), s[2].parse().ok().unwrap()) } #[allow(dead_code)] fn input_t4<T1: std::str::FromStr, T2: std::str::FromStr, T3: std::str::FromStr, T4: std::str::FromStr>() -> (T1, T2, T3, T4) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap(), s[2].parse().ok().unwrap(), s[3].parse().ok().unwrap()) } #[allow(dead_code)] fn input_t5<T1: std::str::FromStr, T2: std::str::FromStr, T3: std::str::FromStr, T4: std::str::FromStr, T5: std::str::FromStr>() -> (T1, T2, T3, T4, T5) { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); let s = s.trim().split_whitespace().collect::<Vec<&str>>(); (s[0].parse().ok().unwrap(), s[1].parse().ok().unwrap(), s[2].parse().ok().unwrap(), s[3].parse().ok().unwrap(), s[4].parse().ok().unwrap()) } #[allow(dead_code)] fn input_vec<T: std::str::FromStr>() -> Vec<T> { let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); s.trim().split_whitespace().map(|s| s.parse().ok().unwrap()).collect() }
