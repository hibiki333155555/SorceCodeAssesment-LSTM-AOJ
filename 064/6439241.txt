import std.stdio, std.string, std.conv;
import std.algorithm, std.math;
import std.range;
import std.container.rbtree, std.container.dlist;
import std.container.binaryheap, std.container.array;
import std.typecons;

alias mstring = char[];
const long INF = 1L << 60L;
const long mod = 1_000_000_000 + 7;

void chmin (T)(ref T x, T y) {
  x = min(x, y);
}

void chmax (T)(ref T x, T y) {
  x = max(x, y);
}

// 単一の数値を取得
// readln.chomp.to!int;
//  or
// int a;
// readf("%s\n", a);

// 複数の数値を取得(可変数個の場合推奨)
// readln.chomp.split.map!(to!long).array

// 複数の数値を取得(固定数個の場合、推奨)
// int a, b;
// readf("%s %s\n", &a, &b);

// インデントを一個ずらして複数の数値を取得(累積和とかで1-indexedの方が良い時がある)
// long[] vs = readln.chomp.split.map!(to!long).array;
// vs = [0L] ~ vs;

// 小数点は以下で指定
// double ret = 10.0;
// writefln("%.12f", ret);

// 配列の最後の要素は arr[$-1] でアクセスできる

void main () {
  string N = readln.chomp;
  const int maxK = N.length.to!int;

  auto dp = new long[][][](maxK + 1, 2, 15);
  foreach (i; 0 .. maxK + 1)
    foreach (k; 0 .. 2)
      foreach (j; 0 .. 15)
        dp[i][k][j] = -1L;
  dp[maxK][0][0] = 1L;

  for (int i = maxK; i > 0; i--) {
    int ni = N[maxK - i] - '0';
    foreach (k; 0 .. 2)
      foreach (j; 0 .. 15) {
        if (dp[i][k][j] < 0L)
          continue;

        foreach (d; 0 .. 10) {
          if (k == 0 && d > ni)
            continue;

          int nk = cast(int)(k == 1 || d < ni);
          int nj;
          if (j == 0)
            nj = (d == 5) ? 1 : 0;
          else if (j == 1)
            nj = (d == 1) ? 2 : (d == 5) ? 1 : 0;
          else if (j == 2)
            nj = (d == 5) ? 4 : 3;
          else if (j == 3)
            nj = (d == 3) ? 7 : (d == 5) ? 1 : 0;
          else if (j == 4)
            nj = (d == 1) ? 5 : (d == 3) ? 8 : (d == 5) ? 1 : 0;
          else if (j == 5)
            nj = (d == 5) ? 4 : 6;
          else if (j == 6)
            nj = (d == 3) ? 8 : (d == 5) ? 1 : 0;
          else if (j == 7)
            nj = 7;
          else if (j == 8)
            nj = (d == 5) ? 9 : 8;
          else if (j == 9)
            nj = (d == 1) ? 10 : (d == 5) ? 9 : 8;
          else if (j == 10)
            nj = (d == 5) ? 12 : 11;
          else if (j == 11)
            nj = (d == 3) ? 7 : (d == 5) ? 9 : 8;
          else if (j == 12)
            nj = (d == 1) ? 13 : (d == 5) ? 9 : 8;
          else if (j == 13)
            nj = (d == 5) ? 12 : 14;
          else
            nj = (d == 5) ? 9 : 8;

          dp[i - 1][nk][nj] =
            max(0L, dp[i - 1][nk][nj]) + dp[i][k][j];
        }
      }
  }

  long ret = 0L;
  foreach (j; 7 .. 15)
    ret += max(0L, dp[0][0][j]) + max(0L, dp[0][1][j]);
  writeln(ret);
}

