#pragma GCC optimize("Ofast")
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <cstdio>
#include <ctime>
#include <assert.h>
#include <chrono>
#include <random>
#include <numeric>
#include <set>
#include <deque>
#include <stack>
#include <sstream>
#include <utility>
#include <cstring>
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <bitset>
using namespace std;
typedef long long int ll;
typedef unsigned long long ull;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}
inline ll time() {
    return static_cast<long double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()) * 1e-9;
}

constexpr ll mod = 998244353;

ll mod_pow(ll a,ll b){
    a%=mod;
    if(b==0)return 1;
    if(b==1)return a;
    ll res=mod_pow(a,b/2)%mod;
    res*=res; res%=mod;
    if(b%2)res*=a;
    return res%mod;
}

const int N = 2001;
ll f[N],inv[N];

int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n,m; cin >> n >> m;
    vector<int> a(m);
    for(int i=0;i<m;i++){
        cin >> a[i];
    }
    f[0] = 1;
    for(int i=1;i<N;i++){
        f[i] = f[i-1]*i%mod;
        inv[i] = mod_pow(f[i], mod-2);
    }
    vector<ll> dp(n+1);
    dp[n] = f[n];
    for(int i=0;i<m;i++){
        vector<ll> ndp(n+1);
        ll sum = 0;
        for(int j=n;j>=0;j--){
            sum += dp[j];
            if(sum >= mod)sum -= mod;
            if(j+a[i]+1 <= n)sum += mod-dp[j+a[i]+1];
            if(sum >= mod)sum -= mod;
            ndp[j] += sum;
            if(ndp[j] >= mod)ndp[j] -= mod;
        }
        swap(dp,ndp);
    }
    cout << dp[0] << endl;
}


